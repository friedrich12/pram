
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>pram package &#8212; PyPRAM  documentation</title>
    <link rel="stylesheet" href="_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/language_data.js"></script>
    <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="pram.log package" href="pram.log.html" />
    <link rel="prev" title="Front-Ends" href="front-ends.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="section" id="pram-package">
<h1>pram package<a class="headerlink" href="#pram-package" title="Permalink to this headline">¶</a></h1>
<div class="section" id="subpackages">
<h2>Subpackages<a class="headerlink" href="#subpackages" title="Permalink to this headline">¶</a></h2>
<div class="toctree-wrapper compound">
<ul>
<li class="toctree-l1"><a class="reference internal" href="pram.log.html">pram.log package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="pram.log.html#submodules">Submodules</a></li>
<li class="toctree-l2"><a class="reference internal" href="pram.log.html#pram-log-log-module">pram.log.log module</a></li>
<li class="toctree-l2"><a class="reference internal" href="pram.log.html#pram-log-man-module">pram.log.man module</a></li>
<li class="toctree-l2"><a class="reference internal" href="pram.log.html#module-contents">Module contents</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="pram.model.html">pram.model package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="pram.model.html#submodules">Submodules</a></li>
<li class="toctree-l2"><a class="reference internal" href="pram.model.html#module-pram.model.epi">pram.model.epi module</a></li>
<li class="toctree-l2"><a class="reference internal" href="pram.model.html#module-pram.model.model">pram.model.model module</a></li>
<li class="toctree-l2"><a class="reference internal" href="pram.model.html#module-pram.model">Module contents</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div class="section" id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-pram.data">
<span id="pram-data-module"></span><h2>pram.data module<a class="headerlink" href="#module-pram.data" title="Permalink to this headline">¶</a></h2>
<p>Contains data-capturing code.</p>
<p>One purpose of simulating a model is to elucidate the dynamics captured by that model.  In the case of PRAMs, an
organic example of such dynamics is agent mass dynamics, i.e., the ways in which agent mass moves between groups as a
result of the application of rules.  PyPRAM’s <em>probes</em> are the facility the user can deploy to capture the interesting
aspects of the model’s dynamics.  For example, a probe could monitor and persist the sizes of all groups at every step
of the simulation.</p>
<dl class="class">
<dt id="pram.data.Const">
<em class="property">class </em><code class="sig-prename descclassname">pram.data.</code><code class="sig-name descname">Const</code><a class="headerlink" href="#pram.data.Const" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pram.data.Const" title="pram.data.Const"><code class="xref py py-class docutils literal notranslate"><span class="pre">pram.data.Const</span></code></a></p>
<p>Probe’s constant.</p>
<p>A probe can be in charge of storing multiple constants that relate to the simulation context at large.  Naturally,
being constants their values will not change, but it may beneficial to have them as database table columns for later
data processing and analysis (e.g., forming a UNION of two or more tables with congruent schemas).  This class shows
how such a constant can be defined.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>name</strong> (<em>str</em>) – The constants’s name.  If relational database persistance is used, this name will become the name of a
table column.  While PyPRAM escapes special characters, problematic names should be avoided (e.g., those
containing spaces or weird characters).</p></li>
<li><p><strong>type</strong> (<em>str</em>) – The constants’s type.  If relational database persistance is used, this needs to be a valid data types
of the RDBMS of choice.</p></li>
<li><p><strong>val</strong> (<em>Any</em>) – The variable’s value (must match the <code class="docutils literal notranslate"><span class="pre">type</span></code>, although in case of database persistance the driver
or the RDBMS itself may attempt to cast).</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="class">
<dt id="pram.data.GroupAttrProbe">
<em class="property">class </em><code class="sig-prename descclassname">pram.data.</code><code class="sig-name descname">GroupAttrProbe</code><span class="sig-paren">(</span><em class="sig-param">name</em>, <em class="sig-param">queries</em>, <em class="sig-param">qry_tot=None</em>, <em class="sig-param">var_names=None</em>, <em class="sig-param">consts=None</em>, <em class="sig-param">persistance=None</em>, <em class="sig-param">msg_mode=0</em>, <em class="sig-param">pop=None</em>, <em class="sig-param">memo=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.data.GroupAttrProbe" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pram.data.GroupProbe" title="pram.data.GroupProbe"><code class="xref py py-class docutils literal notranslate"><span class="pre">pram.data.GroupProbe</span></code></a></p>
<p>A probe that monitors a PRAM group’s attribute values.</p>
<p>See <code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code> for more details.</p>
<dl class="method">
<dt id="pram.data.GroupAttrProbe.run">
<code class="sig-name descname">run</code><span class="sig-paren">(</span><em class="sig-param">iter</em>, <em class="sig-param">t</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.data.GroupAttrProbe.run" title="Permalink to this definition">¶</a></dt>
<dd><p>Runs the probe.</p>
<p>More details in the <a class="reference internal" href="#pram.data.GroupProbe.run" title="pram.data.GroupProbe.run"><code class="xref py py-meth docutils literal notranslate"><span class="pre">abstract</span> <span class="pre">method</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>iter</strong> (<em>int</em>) – The simulation iteration.</p></li>
<li><p><strong>t</strong> (<em>int</em>) – The simulation time.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pram.data.GroupProbe">
<em class="property">class </em><code class="sig-prename descclassname">pram.data.</code><code class="sig-name descname">GroupProbe</code><span class="sig-paren">(</span><em class="sig-param">name</em>, <em class="sig-param">queries</em>, <em class="sig-param">qry_tot=None</em>, <em class="sig-param">consts=None</em>, <em class="sig-param">persistance=None</em>, <em class="sig-param">msg_mode=&lt;ProbeMsgMode.DISP: 2&gt;</em>, <em class="sig-param">pop=None</em>, <em class="sig-param">memo=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.data.GroupProbe" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pram.data.Probe" title="pram.data.Probe"><code class="xref py py-class docutils literal notranslate"><span class="pre">pram.data.Probe</span></code></a>, <code class="xref py py-class docutils literal notranslate"><span class="pre">abc.ABC</span></code></p>
<p>A probe that monitors any aspect of a PRAM group.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>name</strong> (<em>str</em>) – Probe’s name; probes are identified by names.</p></li>
<li><p><strong>queries</strong> (<em>Iterable</em><em>[</em><a class="reference internal" href="#pram.entity.GroupQry" title="pram.entity.GroupQry"><em>GroupQry</em></a><em>]</em>) – A GroupQry object selects one of more PRAM groups based on their attributes and
relations.  For example, <code class="docutils literal notranslate"><span class="pre">GroupQry(attr={</span> <span class="pre">'flu':</span> <span class="pre">'s'</span> <span class="pre">},</span> <span class="pre">rel={</span> <span class="pre">Site.AT:</span> <span class="pre">Site('home')</span> <span class="pre">})</span></code> selects all
groupsof agents that are susceptible to flu that are at the particular site called <code class="docutils literal notranslate"><span class="pre">home</span></code>.</p></li>
<li><p><strong>qry_tot</strong> (<a class="reference internal" href="#pram.entity.GroupQry" title="pram.entity.GroupQry"><em>GroupQry</em></a><em>, </em><em>optional</em>) – Apart from capturing the absolute numbers of agents residing in a group or being
moved between groups, a probe also calculates those numbers as proportions; naturally, both of these
happen every iteration of the simulation.  To calculate proportions, the total agent population mass needs
to be known.  <code class="docutils literal notranslate"><span class="pre">qry_tot</span></code> provides that total mass.  It can be a <code class="docutils literal notranslate"><span class="pre">GroupQry</span></code> object that selects groups to
have their masses summed to form the total mass (e.g., all agents that have the flu irrespective of where
they currently are).  Alternatively, if left at the default value of None, the entire population mass will
be used as the normalizing factor.</p></li>
<li><p><strong>consts</strong> (<em>Iterable</em><em>[</em><a class="reference internal" href="#pram.data.Const" title="pram.data.Const"><em>Const</em></a><em>]</em><em>, </em><em>optional</em>) – Constants (see <a class="reference internal" href="#pram.data.Const" title="pram.data.Const"><code class="xref py py-class docutils literal notranslate"><span class="pre">pram.data.Const</span></code></a> class for details).</p></li>
<li><p><strong>persistance</strong> (<a class="reference internal" href="#pram.data.ProbePersistance" title="pram.data.ProbePersistance"><em>ProbePersistance</em></a><em>, </em><em>optional</em>) – A ProbePersistance object reference.</p></li>
<li><p><strong>msg_mode</strong> (<em>int</em>) – Probe’s message mode (see <a class="reference internal" href="#pram.data.ProbeMsgMode" title="pram.data.ProbeMsgMode"><code class="xref py py-class docutils literal notranslate"><span class="pre">ProbeMsgMode</span></code></a> enum).</p></li>
<li><p><strong>pop</strong> (<a class="reference internal" href="#pram.pop.GroupPopulation" title="pram.pop.GroupPopulation"><em>GroupPopulation</em></a><em>, </em><em>optional</em>) – The group population in question.</p></li>
<li><p><strong>memo</strong> (<em>str</em><em>, </em><em>optional</em>) – Probe’s description.</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>All classes extending this class must populate the <code class="docutils literal notranslate"><span class="pre">self.vars</span></code> list before calling the constructor of this
class.</p>
</div>
<div class="admonition-todo admonition" id="id1">
<p class="admonition-title">Todo</p>
<p>Figure out the relation between the ‘self.persistance’ and registering probes with multiple ProbePersistance
objects.  At this point it looks like due to the interaction of multiple designs the probe can only be
associated with one such objects.</p>
</div>
<dl class="method">
<dt id="pram.data.GroupProbe.by_attr">
<em class="property">classmethod </em><code class="sig-name descname">by_attr</code><span class="sig-paren">(</span><em class="sig-param">probe_name</em>, <em class="sig-param">attr_name</em>, <em class="sig-param">attr_values</em>, <em class="sig-param">qry_tot=None</em>, <em class="sig-param">var_names=None</em>, <em class="sig-param">consts=None</em>, <em class="sig-param">persistance=None</em>, <em class="sig-param">msg_mode=0</em>, <em class="sig-param">pop=None</em>, <em class="sig-param">memo=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.data.GroupProbe.by_attr" title="Permalink to this definition">¶</a></dt>
<dd><p>Instantiates the probe by attributes.</p>
<p>This constructor generates QueryGrp objects automatically for the attribute name and values specified.  It is a
convenience method for probes that only use only a single attribute of PRAM groups and do not use relations.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>probe_name</strong> (<em>str</em>) – Probe’s name; probes are identified by names.</p></li>
<li><p><strong>attr_name</strong> (<em>str</em>) – The name of the attribute.</p></li>
<li><p><strong>attr_values</strong> (<em>Iterable</em><em>[</em><em>str</em><em>]</em>) – The values of the attribute to be monitored.  Sizes of PRAM groups with
different values of the attribute in question will not be monitored.</p></li>
<li><p><strong>qry_tot</strong> (<a class="reference internal" href="#pram.entity.GroupQry" title="pram.entity.GroupQry"><em>GroupQry</em></a><em>, </em><em>optional</em>) – See <code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></p></li>
<li><p><strong>var_names</strong> (<em>Iterable</em><em>[</em><em>str</em><em>]</em><em>, </em><em>optional</em>) – Names which should be assigned to the attribute values.  Those names
must correspond to <code class="docutils literal notranslate"><span class="pre">attr_values</span></code> in that every element of <code class="docutils literal notranslate"><span class="pre">attr_values</span></code> must resolve to <strong>two</strong>
elements in <code class="docutils literal notranslate"><span class="pre">var_names</span></code>.  That is because both the proportion and the absolute number of the agents
are recorded by the probe.  In case of database persistance, the variable names will be column names.
If left None, default names will be used (i.e., <code class="docutils literal notranslate"><span class="pre">p0</span></code>, <code class="docutils literal notranslate"><span class="pre">p1</span></code>, … for proportions and <code class="docutils literal notranslate"><span class="pre">m0</span></code>, <code class="docutils literal notranslate"><span class="pre">m1</span></code>,
… for mass).</p></li>
<li><p><strong>consts</strong> (<em>Iterable</em><em>[</em><a class="reference internal" href="#pram.data.Const" title="pram.data.Const"><em>Const</em></a><em>]</em><em>, </em><em>optional</em>) – Constants (see <a class="reference internal" href="#pram.data.Const" title="pram.data.Const"><code class="xref py py-class docutils literal notranslate"><span class="pre">pram.data.Const</span></code></a> class for details).</p></li>
<li><p><strong>persistance</strong> (<a class="reference internal" href="#pram.data.ProbePersistance" title="pram.data.ProbePersistance"><em>ProbePersistance</em></a><em>, </em><em>optional</em>) – A ProbePersistance object reference.</p></li>
<li><p><strong>msg_mode</strong> (<em>int</em>) – Probe’s message mode (see <a class="reference internal" href="#pram.data.ProbeMsgMode" title="pram.data.ProbeMsgMode"><code class="xref py py-class docutils literal notranslate"><span class="pre">ProbeMsgMode</span></code></a> enum).</p></li>
<li><p><strong>pop</strong> (<a class="reference internal" href="#pram.pop.GroupPopulation" title="pram.pop.GroupPopulation"><em>GroupPopulation</em></a><em>, </em><em>optional</em>) – The group population in question.</p></li>
<li><p><strong>memo</strong> (<em>str</em><em>, </em><em>optional</em>) – Probe’s description.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pram.data.GroupProbe.by_rel">
<em class="property">classmethod </em><code class="sig-name descname">by_rel</code><span class="sig-paren">(</span><em class="sig-param">probe_name</em>, <em class="sig-param">rel_name</em>, <em class="sig-param">rel_values</em>, <em class="sig-param">qry_tot=None</em>, <em class="sig-param">var_names=None</em>, <em class="sig-param">consts=None</em>, <em class="sig-param">persistance=None</em>, <em class="sig-param">msg_mode=0</em>, <em class="sig-param">pop=None</em>, <em class="sig-param">memo=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.data.GroupProbe.by_rel" title="Permalink to this definition">¶</a></dt>
<dd><p>Instantiates the probe by relations.</p>
<p>This constructor generates QueryGrp objects automatically for the relation name and values specified.  It is a
convenience method for probes that only use only a single relation of PRAM groups and do not use attributes.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>probe_name</strong> (<em>str</em>) – Probe’s name; probes are identified by names.</p></li>
<li><p><strong>rel_name</strong> (<em>str</em>) – The name of the relation.</p></li>
<li><p><strong>rel_values</strong> (<em>Iterable</em><em>[</em><em>str</em><em>]</em>) – The values of the relation to be monitored.  Sizes of PRAM groups with
different values of the relation in question will not be monitored.</p></li>
<li><p><strong>qry_tot</strong> (<a class="reference internal" href="#pram.entity.GroupQry" title="pram.entity.GroupQry"><em>GroupQry</em></a><em>, </em><em>optional</em>) – See <code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></p></li>
<li><p><strong>var_names</strong> (<em>Iterable</em><em>[</em><em>str</em><em>]</em><em>, </em><em>optional</em>) – Names which should be assigned to the relation values.  Those names
must correspond to <code class="docutils literal notranslate"><span class="pre">rel_values</span></code> in that every element of <code class="docutils literal notranslate"><span class="pre">rel_values</span></code> must resolve to <strong>two</strong>
elements in <code class="docutils literal notranslate"><span class="pre">var_names</span></code>.  That is because both the proportion and the absolute number of the agents
are recorded by the probe.  In case of database persistance, the variable names will be column names.
If left None, default names will be used (i.e., <code class="docutils literal notranslate"><span class="pre">p0</span></code>, <code class="docutils literal notranslate"><span class="pre">p1</span></code>, … for proportions and <code class="docutils literal notranslate"><span class="pre">m0</span></code>, <code class="docutils literal notranslate"><span class="pre">m1</span></code>,
… for mass).</p></li>
<li><p><strong>consts</strong> (<em>Iterable</em><em>[</em><a class="reference internal" href="#pram.data.Const" title="pram.data.Const"><em>Const</em></a><em>]</em><em>, </em><em>optional</em>) – Constants (see <a class="reference internal" href="#pram.data.Const" title="pram.data.Const"><code class="xref py py-class docutils literal notranslate"><span class="pre">pram.data.Const</span></code></a> class for details).</p></li>
<li><p><strong>persistance</strong> (<a class="reference internal" href="#pram.data.ProbePersistance" title="pram.data.ProbePersistance"><em>ProbePersistance</em></a><em>, </em><em>optional</em>) – A ProbePersistance object reference.</p></li>
<li><p><strong>msg_mode</strong> (<em>int</em>) – Probe’s message mode (see <a class="reference internal" href="#pram.data.ProbeMsgMode" title="pram.data.ProbeMsgMode"><code class="xref py py-class docutils literal notranslate"><span class="pre">ProbeMsgMode</span></code></a> enum).</p></li>
<li><p><strong>pop</strong> (<a class="reference internal" href="#pram.pop.GroupPopulation" title="pram.pop.GroupPopulation"><em>GroupPopulation</em></a><em>, </em><em>optional</em>) – The group population in question.</p></li>
<li><p><strong>memo</strong> (<em>str</em><em>, </em><em>optional</em>) – Probe’s description.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pram.data.GroupProbe.clear_msg">
<code class="sig-name descname">clear_msg</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pram.data.GroupProbe.clear_msg" title="Permalink to this definition">¶</a></dt>
<dd><p>Clear any cumulated messages.</p>
</dd></dl>

<dl class="method">
<dt id="pram.data.GroupProbe.get_data">
<code class="sig-name descname">get_data</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pram.data.GroupProbe.get_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieves data associated with the probe.</p>
<p>For this to work the probe needs to be associated with a ProbePersistance object.</p>
</dd></dl>

<dl class="method">
<dt id="pram.data.GroupProbe.get_msg">
<code class="sig-name descname">get_msg</code><span class="sig-paren">(</span><em class="sig-param">do_join=True</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.data.GroupProbe.get_msg" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieve all cumulated messages.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>do_join</strong> (<em>bool</em>) – Flag: Join the messages with the new-line character?</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The message.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>str</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pram.data.GroupProbe.plot">
<code class="sig-name descname">plot</code><span class="sig-paren">(</span><em class="sig-param">series</em>, <em class="sig-param">fig_fpath=None</em>, <em class="sig-param">figsize=(8</em>, <em class="sig-param">8)</em>, <em class="sig-param">legend_loc='upper right'</em>, <em class="sig-param">dpi=300</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.data.GroupProbe.plot" title="Permalink to this definition">¶</a></dt>
<dd><p>Plots data associated with a probe.</p>
<p>This method calls <a class="reference internal" href="#pram.data.ProbePersistance.plot" title="pram.data.ProbePersistance.plot"><code class="xref py py-meth docutils literal notranslate"><span class="pre">plot()</span></code></a>.</p>
</dd></dl>

<dl class="method">
<dt id="pram.data.GroupProbe.run">
<em class="property">abstract </em><code class="sig-name descname">run</code><span class="sig-paren">(</span><em class="sig-param">iter</em>, <em class="sig-param">t</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.data.GroupProbe.run" title="Permalink to this definition">¶</a></dt>
<dd><p>Runs the probe.</p>
<p>A probe is run by the <a class="reference internal" href="#pram.sim.Simulation.run" title="pram.sim.Simulation.run"><code class="xref py py-meth docutils literal notranslate"><span class="pre">run()</span></code></a> method of the
<a class="reference internal" href="#pram.sim.Simulation" title="pram.sim.Simulation"><code class="xref py py-class docutils literal notranslate"><span class="pre">Simulation</span></code></a> class as it steps through the simulation.  Probes are
run as the last order of business before the simulation advances to the next iteration which is congruent with
probe capturing the state of the simulation after it has settled at every iteration.</p>
<p>Setting both the ‘iter’ and ‘t’ to ‘None’ will prevent persistance from being invoked and message cumulation to
occur.  It will still allow printint to stdout however.  In fact, this mechanism is used by the
<a class="reference internal" href="#pram.sim.Simulation" title="pram.sim.Simulation"><code class="xref py py-class docutils literal notranslate"><span class="pre">Simulation</span></code></a> class to print the intial state of the system (as seen by those probes that
actually print), that is before the simulation run begins.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>iter</strong> (<em>int</em>) – The simulation iteration.</p></li>
<li><p><strong>t</strong> (<em>int</em>) – The simulation time.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pram.data.GroupProbe.set_consts">
<code class="sig-name descname">set_consts</code><span class="sig-paren">(</span><em class="sig-param">consts=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.data.GroupProbe.set_consts" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the probe’s constants.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>consts</strong> (<em>Iterable</em><em>[</em><a class="reference internal" href="#pram.data.Const" title="pram.data.Const"><em>Const</em></a><em>]</em><em>, </em><em>optional</em>) – The constants (see <a class="reference internal" href="#pram.data.Const" title="pram.data.Const"><code class="xref py py-class docutils literal notranslate"><span class="pre">pram.data.Const</span></code></a> class for details).</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pram.data.GroupProbe.set_persistance">
<code class="sig-name descname">set_persistance</code><span class="sig-paren">(</span><em class="sig-param">persistance</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.data.GroupProbe.set_persistance" title="Permalink to this definition">¶</a></dt>
<dd><p>Associates the probe with a ProbePersistance object.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>persistance</strong> (<a class="reference internal" href="#pram.data.ProbePersistance" title="pram.data.ProbePersistance"><em>ProbePersistance</em></a>) – The ProbePersistance object.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pram.data.GroupProbe.set_pop">
<code class="sig-name descname">set_pop</code><span class="sig-paren">(</span><em class="sig-param">pop</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.data.GroupProbe.set_pop" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the group population the probe should interact with.</p>
<p>Currently, a PyPRAM simulation operates on a single instance of the GroupPopulation object.  This may change in
the future and this method will associate the probe with one of the group populations.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>pop</strong> (<a class="reference internal" href="#pram.pop.GroupPopulation" title="pram.pop.GroupPopulation"><em>GroupPopulation</em></a>) – Group population.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pram.data.GroupSizeProbe">
<em class="property">class </em><code class="sig-prename descclassname">pram.data.</code><code class="sig-name descname">GroupSizeProbe</code><span class="sig-paren">(</span><em class="sig-param">name</em>, <em class="sig-param">queries</em>, <em class="sig-param">qry_tot=None</em>, <em class="sig-param">var_names=None</em>, <em class="sig-param">consts=None</em>, <em class="sig-param">persistance=None</em>, <em class="sig-param">msg_mode=0</em>, <em class="sig-param">pop=None</em>, <em class="sig-param">memo=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.data.GroupSizeProbe" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pram.data.GroupProbe" title="pram.data.GroupProbe"><code class="xref py py-class docutils literal notranslate"><span class="pre">pram.data.GroupProbe</span></code></a></p>
<p>A probe that monitors a PRAM group’s size.</p>
<p>See <a class="reference internal" href="#pram.data.GroupProbe" title="pram.data.GroupProbe"><code class="xref py py-class docutils literal notranslate"><span class="pre">GroupProbe</span></code></a> for more details.</p>
<dl class="method">
<dt id="pram.data.GroupSizeProbe.run">
<code class="sig-name descname">run</code><span class="sig-paren">(</span><em class="sig-param">iter</em>, <em class="sig-param">t</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.data.GroupSizeProbe.run" title="Permalink to this definition">¶</a></dt>
<dd><p>Runs the probe.</p>
<p>More details in the <a class="reference internal" href="#pram.data.GroupProbe.run" title="pram.data.GroupProbe.run"><code class="xref py py-meth docutils literal notranslate"><span class="pre">abstract</span> <span class="pre">method</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>iter</strong> (<em>int</em>) – The simulation iteration.</p></li>
<li><p><strong>t</strong> (<em>int</em>) – The simulation time.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pram.data.Probe">
<em class="property">class </em><code class="sig-prename descclassname">pram.data.</code><code class="sig-name descname">Probe</code><a class="headerlink" href="#pram.data.Probe" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">abc.ABC</span></code></p>
<p>Probe base class.</p>
</dd></dl>

<dl class="class">
<dt id="pram.data.ProbeMsgMode">
<em class="property">class </em><code class="sig-prename descclassname">pram.data.</code><code class="sig-name descname">ProbeMsgMode</code><a class="headerlink" href="#pram.data.ProbeMsgMode" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">enum.Flag</span></code></p>
<p>Probe’s message mode enum.</p>
<p>A probe can be designated to send messages to stdout which is useful for testing and debugging.  This class
determines how those messages are handled.  The three options are:</p>
<blockquote>
<div><ul class="simple">
<li><p>Ignore (do not cumulate nor display any messages)</p></li>
<li><p>Display (Display messages right away)</p></li>
<li><p>Cumulate (Store messages in an internal list for future retrieval)</p></li>
</ul>
</div></blockquote>
<p>When testing or debugging a simulation with only one probe, the display mode seems most useful (and it is in fact
the default).  However, the simulation output can quickly become unreasable if multiple probes are sending messages
to stdout.  The cumulate mode addresses this scenario; messages are stored and can be retrieved at any point with
the end of the simulation being one reasonable choice.</p>
<p>Probe messages are a simpler and chronologically older alternative to probe persistance.</p>
<dl class="attribute">
<dt id="pram.data.ProbeMsgMode.CUMUL">
<code class="sig-name descname">CUMUL</code><em class="property"> = 4</em><a class="headerlink" href="#pram.data.ProbeMsgMode.CUMUL" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pram.data.ProbeMsgMode.DISP">
<code class="sig-name descname">DISP</code><em class="property"> = 2</em><a class="headerlink" href="#pram.data.ProbeMsgMode.DISP" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pram.data.ProbeMsgMode.NONE">
<code class="sig-name descname">NONE</code><em class="property"> = 1</em><a class="headerlink" href="#pram.data.ProbeMsgMode.NONE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pram.data.ProbePersistance">
<em class="property">class </em><code class="sig-prename descclassname">pram.data.</code><code class="sig-name descname">ProbePersistance</code><a class="headerlink" href="#pram.data.ProbePersistance" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">abc.ABC</span></code></p>
<p>Probe persistance base class.</p>
<p>After being instantiated, probes are registered with an ProbePersistace object.  This design allows a single probe
to persist values to multiple databases, files, etc.</p>
<dl class="attribute">
<dt id="pram.data.ProbePersistance.VAR_NAME_KEYWORD">
<code class="sig-name descname">VAR_NAME_KEYWORD</code><em class="property"> = ['id', 'ts', 'i', 't']</em><a class="headerlink" href="#pram.data.ProbePersistance.VAR_NAME_KEYWORD" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.data.ProbePersistance.flush">
<em class="property">abstract </em><code class="sig-name descname">flush</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pram.data.ProbePersistance.flush" title="Permalink to this definition">¶</a></dt>
<dd><p>Flushes all buffered values to the persistance layer.</p>
</dd></dl>

<dl class="method">
<dt id="pram.data.ProbePersistance.get_data">
<em class="property">abstract </em><code class="sig-name descname">get_data</code><span class="sig-paren">(</span><em class="sig-param">probe</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.data.ProbePersistance.get_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieves data associated with a probe.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>probe</strong> (<a class="reference internal" href="#pram.data.Probe" title="pram.data.Probe"><em>Probe</em></a>) – The probe.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A dictionary based on the SQL SELECT query of the probe</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pram.data.ProbePersistance.persist">
<em class="property">abstract </em><code class="sig-name descname">persist</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pram.data.ProbePersistance.persist" title="Permalink to this definition">¶</a></dt>
<dd><p>Stores values to be persisted and persists them in accordance with the flushing frequency set.</p>
</dd></dl>

<dl class="method">
<dt id="pram.data.ProbePersistance.plot">
<em class="property">abstract </em><code class="sig-name descname">plot</code><span class="sig-paren">(</span><em class="sig-param">probe</em>, <em class="sig-param">series</em>, <em class="sig-param">figpath=None</em>, <em class="sig-param">figsize=(12</em>, <em class="sig-param">4)</em>, <em class="sig-param">legend_loc='upper right'</em>, <em class="sig-param">dpi=150</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.data.ProbePersistance.plot" title="Permalink to this definition">¶</a></dt>
<dd><p>Plots data associated with a probe.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>probe</strong> (<a class="reference internal" href="#pram.data.Probe" title="pram.data.Probe"><em>Probe</em></a>) – The probe.</p></li>
<li><p><strong>series</strong> (<em>dict</em>) – Series specification (see examples below).</p></li>
<li><p><strong>figpath</strong> (<em>str</em><em>, </em><em>optional</em>) – Filepath to save the figure.</p></li>
<li><p><strong>figsize</strong> (<em>(</em><em>int</em><em>,</em><em>int</em><em>)</em>) – Figure size in (w,h) format.</p></li>
<li><p><strong>legend_loc</strong> (<em>str</em>) – Legend location (e.g., ‘upper right’).</p></li>
<li><p><strong>dpi</strong> (<em>int</em>) – Resolution.</p></li>
</ul>
</dd>
</dl>
<p>Examples:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">p</span> <span class="o">=</span> <span class="n">GroupSizeProbe</span><span class="o">.</span><span class="n">by_attr</span><span class="p">(</span><span class="s1">&#39;flu&#39;</span><span class="p">,</span> <span class="s1">&#39;flu&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;s&#39;</span><span class="p">,</span> <span class="s1">&#39;i&#39;</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">],</span> <span class="n">persistance</span><span class="o">=</span><span class="n">ProbePersistanceDB</span><span class="p">())</span>

<span class="c1"># create a simulation</span>

<span class="n">series</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">{</span> <span class="s1">&#39;var&#39;</span><span class="p">:</span> <span class="s1">&#39;p0&#39;</span><span class="p">,</span> <span class="s1">&#39;lw&#39;</span><span class="p">:</span> <span class="mf">0.75</span><span class="p">,</span> <span class="s1">&#39;linestyle&#39;</span><span class="p">:</span> <span class="s1">&#39;-&#39;</span><span class="p">,</span>  <span class="s1">&#39;marker&#39;</span><span class="p">:</span> <span class="s1">&#39;o&#39;</span><span class="p">,</span> <span class="s1">&#39;color&#39;</span><span class="p">:</span> <span class="s1">&#39;red&#39;</span><span class="p">,</span>   <span class="s1">&#39;markersize&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;lbl&#39;</span><span class="p">:</span> <span class="s1">&#39;S&#39;</span> <span class="p">},</span>
    <span class="p">{</span> <span class="s1">&#39;var&#39;</span><span class="p">:</span> <span class="s1">&#39;p1&#39;</span><span class="p">,</span> <span class="s1">&#39;lw&#39;</span><span class="p">:</span> <span class="mf">0.75</span><span class="p">,</span> <span class="s1">&#39;linestyle&#39;</span><span class="p">:</span> <span class="s1">&#39;--&#39;</span><span class="p">,</span> <span class="s1">&#39;marker&#39;</span><span class="p">:</span> <span class="s1">&#39;+&#39;</span><span class="p">,</span> <span class="s1">&#39;color&#39;</span><span class="p">:</span> <span class="s1">&#39;blue&#39;</span><span class="p">,</span>  <span class="s1">&#39;markersize&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;lbl&#39;</span><span class="p">:</span> <span class="s1">&#39;I&#39;</span> <span class="p">},</span>
    <span class="p">{</span> <span class="s1">&#39;var&#39;</span><span class="p">:</span> <span class="s1">&#39;p2&#39;</span><span class="p">,</span> <span class="s1">&#39;lw&#39;</span><span class="p">:</span> <span class="mf">0.75</span><span class="p">,</span> <span class="s1">&#39;linestyle&#39;</span><span class="p">:</span> <span class="s1">&#39;:&#39;</span><span class="p">,</span>  <span class="s1">&#39;marker&#39;</span><span class="p">:</span> <span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;color&#39;</span><span class="p">:</span> <span class="s1">&#39;green&#39;</span><span class="p">,</span> <span class="s1">&#39;markersize&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;lbl&#39;</span><span class="p">:</span> <span class="s1">&#39;R&#39;</span> <span class="p">}</span>
<span class="p">]</span>
<span class="n">p</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">series</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
    <span class="c1"># while the probe&#39;s plot() method is being called, that method simply comes here</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pram.data.ProbePersistance.reg_probe">
<em class="property">abstract </em><code class="sig-name descname">reg_probe</code><span class="sig-paren">(</span><em class="sig-param">probe</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.data.ProbePersistance.reg_probe" title="Permalink to this definition">¶</a></dt>
<dd><p>Registeres a probe.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>probe</strong> (<a class="reference internal" href="#pram.data.Probe" title="pram.data.Probe"><em>Probe</em></a>) – The probe.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pram.data.ProbePersistanceDB">
<em class="property">class </em><code class="sig-prename descclassname">pram.data.</code><code class="sig-name descname">ProbePersistanceDB</code><span class="sig-paren">(</span><em class="sig-param">fpath=':memory:'</em>, <em class="sig-param">mode=&lt;ProbePersistanceMode.APPEND: 1&gt;</em>, <em class="sig-param">flush_every=16</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.data.ProbePersistanceDB" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pram.data.ProbePersistance" title="pram.data.ProbePersistance"><code class="xref py py-class docutils literal notranslate"><span class="pre">pram.data.ProbePersistance</span></code></a></p>
<p>Relational database based probe persistance.</p>
<p>At this point, the SQLite3 database is used.  More serious RDBMSs will be added later (PostgreSQL being the first
of them).</p>
<p>Database inserts are cached and flushed when the buffer fills up.  The buffer size is under the user’s control.
The default size of 16 decreases the time spent persisting data to the database about 15 times.  Higher values
can be used to achieve even better results, but memory utilization cost needs to be considered too.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>fpath</strong> (<em>str</em>) – Path to the database file (<code class="docutils literal notranslate"><span class="pre">':memory:'</span></code> for in-memory database which is good for testing).</p></li>
<li><p><strong>mode</strong> (<em>int</em>) – Persistance mode (see <a class="reference internal" href="#pram.data.ProbePersistanceMode" title="pram.data.ProbePersistanceMode"><code class="xref py py-class docutils literal notranslate"><span class="pre">ProbePersistanceMode</span></code></a> enum).</p></li>
<li><p><strong>flush_every</strong> (<em>int</em>) – Memory-to-database flush frequency.</p></li>
</ul>
</dd>
</dl>
<dl class="attribute">
<dt id="pram.data.ProbePersistanceDB.FLUSH_EVERY">
<code class="sig-name descname">FLUSH_EVERY</code><em class="property"> = 16</em><a class="headerlink" href="#pram.data.ProbePersistanceDB.FLUSH_EVERY" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.data.ProbePersistanceDB.conn_close">
<code class="sig-name descname">conn_close</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pram.data.ProbePersistanceDB.conn_close" title="Permalink to this definition">¶</a></dt>
<dd><p>Closes the database connection.</p>
</dd></dl>

<dl class="method">
<dt id="pram.data.ProbePersistanceDB.conn_open">
<code class="sig-name descname">conn_open</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pram.data.ProbePersistanceDB.conn_open" title="Permalink to this definition">¶</a></dt>
<dd><p>Opens the database connection.</p>
</dd></dl>

<dl class="method">
<dt id="pram.data.ProbePersistanceDB.flush">
<code class="sig-name descname">flush</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pram.data.ProbePersistanceDB.flush" title="Permalink to this definition">¶</a></dt>
<dd><p>Flushes all buffered values to the database.</p>
</dd></dl>

<dl class="method">
<dt id="pram.data.ProbePersistanceDB.get_data">
<code class="sig-name descname">get_data</code><span class="sig-paren">(</span><em class="sig-param">probe</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.data.ProbePersistanceDB.get_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieves data associated with a probe from the database.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>probe</strong> (<a class="reference internal" href="#pram.data.Probe" title="pram.data.Probe"><em>Probe</em></a>) – The probe.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A dictionary based on the SQL SELECT query of the probe</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pram.data.ProbePersistanceDB.persist">
<code class="sig-name descname">persist</code><span class="sig-paren">(</span><em class="sig-param">probe</em>, <em class="sig-param">vals</em>, <em class="sig-param">iter</em>, <em class="sig-param">t</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.data.ProbePersistanceDB.persist" title="Permalink to this definition">¶</a></dt>
<dd><p>Stores values to be persisted and persists them in accordance with the flushing frequency set.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>probe</strong> (<a class="reference internal" href="#pram.data.Probe" title="pram.data.Probe"><em>Probe</em></a>) – The probe.</p></li>
<li><p><strong>vals</strong> (<em>Iterable</em><em>[</em><em>Any</em><em>]</em>) – An iterable with the values to be stored.</p></li>
<li><p><strong>iter</strong> (<em>int</em>) – Simulation iteration.</p></li>
<li><p><strong>t</strong> (<em>int</em>) – Simulation time.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pram.data.ProbePersistanceDB.plot">
<code class="sig-name descname">plot</code><span class="sig-paren">(</span><em class="sig-param">probe</em>, <em class="sig-param">series</em>, <em class="sig-param">figpath=None</em>, <em class="sig-param">figsize=(12</em>, <em class="sig-param">4)</em>, <em class="sig-param">legend_loc='upper right'</em>, <em class="sig-param">dpi=150</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.data.ProbePersistanceDB.plot" title="Permalink to this definition">¶</a></dt>
<dd><p>Plots data associated with a probe.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>probe</strong> (<a class="reference internal" href="#pram.data.Probe" title="pram.data.Probe"><em>Probe</em></a>) – The probe.</p></li>
<li><p><strong>series</strong> (<em>dict</em>) – Series specification (see examples below).</p></li>
<li><p><strong>figpath</strong> (<em>str</em><em>, </em><em>optional</em>) – Filepath to save the figure.</p></li>
<li><p><strong>figsize</strong> (<em>(</em><em>int</em><em>,</em><em>int</em><em>)</em>) – Figure size in (w,h) format.</p></li>
<li><p><strong>legend_loc</strong> (<em>str</em>) – Legend location (e.g., ‘upper right’).</p></li>
<li><p><strong>dpi</strong> (<em>int</em>) – Resolution.</p></li>
</ul>
</dd>
</dl>
<p>Examples:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">p</span> <span class="o">=</span> <span class="n">GroupSizeProbe</span><span class="o">.</span><span class="n">by_attr</span><span class="p">(</span><span class="s1">&#39;flu&#39;</span><span class="p">,</span> <span class="s1">&#39;flu&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;s&#39;</span><span class="p">,</span> <span class="s1">&#39;i&#39;</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">],</span> <span class="n">persistance</span><span class="o">=</span><span class="n">ProbePersistanceDB</span><span class="p">())</span>

<span class="c1"># define a simulation</span>

<span class="n">series</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">{</span> <span class="s1">&#39;var&#39;</span><span class="p">:</span> <span class="s1">&#39;p0&#39;</span><span class="p">,</span> <span class="s1">&#39;lw&#39;</span><span class="p">:</span> <span class="mf">0.75</span><span class="p">,</span> <span class="s1">&#39;linestyle&#39;</span><span class="p">:</span> <span class="s1">&#39;-&#39;</span><span class="p">,</span>  <span class="s1">&#39;marker&#39;</span><span class="p">:</span> <span class="s1">&#39;o&#39;</span><span class="p">,</span> <span class="s1">&#39;color&#39;</span><span class="p">:</span> <span class="s1">&#39;red&#39;</span><span class="p">,</span>   <span class="s1">&#39;markersize&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;lbl&#39;</span><span class="p">:</span> <span class="s1">&#39;S&#39;</span> <span class="p">},</span>
    <span class="p">{</span> <span class="s1">&#39;var&#39;</span><span class="p">:</span> <span class="s1">&#39;p1&#39;</span><span class="p">,</span> <span class="s1">&#39;lw&#39;</span><span class="p">:</span> <span class="mf">0.75</span><span class="p">,</span> <span class="s1">&#39;linestyle&#39;</span><span class="p">:</span> <span class="s1">&#39;--&#39;</span><span class="p">,</span> <span class="s1">&#39;marker&#39;</span><span class="p">:</span> <span class="s1">&#39;+&#39;</span><span class="p">,</span> <span class="s1">&#39;color&#39;</span><span class="p">:</span> <span class="s1">&#39;blue&#39;</span><span class="p">,</span>  <span class="s1">&#39;markersize&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;lbl&#39;</span><span class="p">:</span> <span class="s1">&#39;I&#39;</span> <span class="p">},</span>
    <span class="p">{</span> <span class="s1">&#39;var&#39;</span><span class="p">:</span> <span class="s1">&#39;p2&#39;</span><span class="p">,</span> <span class="s1">&#39;lw&#39;</span><span class="p">:</span> <span class="mf">0.75</span><span class="p">,</span> <span class="s1">&#39;linestyle&#39;</span><span class="p">:</span> <span class="s1">&#39;:&#39;</span><span class="p">,</span>  <span class="s1">&#39;marker&#39;</span><span class="p">:</span> <span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;color&#39;</span><span class="p">:</span> <span class="s1">&#39;green&#39;</span><span class="p">,</span> <span class="s1">&#39;markersize&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;lbl&#39;</span><span class="p">:</span> <span class="s1">&#39;R&#39;</span> <span class="p">}</span>
<span class="p">]</span>
<span class="n">p</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">series</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">16</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pram.data.ProbePersistanceDB.reg_probe">
<code class="sig-name descname">reg_probe</code><span class="sig-paren">(</span><em class="sig-param">probe</em>, <em class="sig-param">do_overwrite=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.data.ProbePersistanceDB.reg_probe" title="Permalink to this definition">¶</a></dt>
<dd><p>Registers a probe.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>probe</strong> (<a class="reference internal" href="#pram.data.Probe" title="pram.data.Probe"><em>Probe</em></a>) – The probe.</p></li>
<li><p><strong>do_overwrite</strong> (<em>bool</em>) – Flag: Should an already registered probe with the same name be overwriten?</p></li>
</ul>
</dd>
</dl>
<dl class="simple">
<dt>Throws:</dt><dd><p>ValueError</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pram.data.ProbePersistanceDBItem">
<em class="property">class </em><code class="sig-prename descclassname">pram.data.</code><code class="sig-name descname">ProbePersistanceDBItem</code><span class="sig-paren">(</span><em class="sig-param">name: str</em>, <em class="sig-param">ins_qry: str</em>, <em class="sig-param">sel_qry: str</em>, <em class="sig-param">ins_val=NOTHING</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.data.ProbePersistanceDBItem" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>A description of how a probe will interact with a database for the purpose of data persistence.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>name</strong> (<em>str</em>) – The item’s name.</p></li>
<li><p><strong>ins_qry</strong> (<em>str</em>) – The SQL INSERT query that is used for persisting data in the database.  This query should be
parameterized to expect the value to be persisted.</p></li>
<li><p><strong>sel_qry</strong> (<em>str</em>) – The SQL SELECT query that is used for retrieving data from the database (e.g., to generate
plots).</p></li>
<li><p><strong>ins_val</strong> (<em>list</em>) – The values to be inserted into the database using the INSERT query.</p></li>
</ul>
</dd>
</dl>
<dl class="attribute">
<dt id="pram.data.ProbePersistanceDBItem.ins_qry">
<code class="sig-name descname">ins_qry</code><a class="headerlink" href="#pram.data.ProbePersistanceDBItem.ins_qry" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pram.data.ProbePersistanceDBItem.ins_val">
<code class="sig-name descname">ins_val</code><a class="headerlink" href="#pram.data.ProbePersistanceDBItem.ins_val" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pram.data.ProbePersistanceDBItem.name">
<code class="sig-name descname">name</code><a class="headerlink" href="#pram.data.ProbePersistanceDBItem.name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pram.data.ProbePersistanceDBItem.sel_qry">
<code class="sig-name descname">sel_qry</code><a class="headerlink" href="#pram.data.ProbePersistanceDBItem.sel_qry" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pram.data.ProbePersistanceFS">
<em class="property">class </em><code class="sig-prename descclassname">pram.data.</code><code class="sig-name descname">ProbePersistanceFS</code><span class="sig-paren">(</span><em class="sig-param">fpath</em>, <em class="sig-param">mode=&lt;ProbePersistanceMode.APPEND: 1&gt;</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.data.ProbePersistanceFS" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pram.data.ProbePersistance" title="pram.data.ProbePersistance"><code class="xref py py-class docutils literal notranslate"><span class="pre">pram.data.ProbePersistance</span></code></a></p>
<p>Filesystem-based probe persistance.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>fpath</strong> (<em>str</em>) – Path to the file.</p></li>
<li><p><strong>mode</strong> (<em>int</em>) – Persistance mode (see <a class="reference internal" href="#pram.data.ProbePersistanceMode" title="pram.data.ProbePersistanceMode"><code class="xref py py-class docutils literal notranslate"><span class="pre">ProbePersistanceMode</span></code></a> enum).</p></li>
</ul>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class is a stub and will be fully implemented when it is needed.</p>
</div>
<dl class="method">
<dt id="pram.data.ProbePersistanceFS.persist">
<code class="sig-name descname">persist</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pram.data.ProbePersistanceFS.persist" title="Permalink to this definition">¶</a></dt>
<dd><p>Stores values to be persisted and persists them in accordance with the flushing frequency set.</p>
</dd></dl>

<dl class="method">
<dt id="pram.data.ProbePersistanceFS.reg_probe">
<code class="sig-name descname">reg_probe</code><span class="sig-paren">(</span><em class="sig-param">probe</em>, <em class="sig-param">do_overwrite=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.data.ProbePersistanceFS.reg_probe" title="Permalink to this definition">¶</a></dt>
<dd><p>Registers a probe.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>probe</strong> (<a class="reference internal" href="#pram.data.Probe" title="pram.data.Probe"><em>Probe</em></a>) – The probe.</p></li>
<li><p><strong>do_overwrite</strong> (<em>bool</em>) – Flag: Should an already registered probe with the same name be overwriten?</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pram.data.ProbePersistanceMem">
<em class="property">class </em><code class="sig-prename descclassname">pram.data.</code><code class="sig-name descname">ProbePersistanceMem</code><span class="sig-paren">(</span><em class="sig-param">mode=&lt;ProbePersistanceMode.APPEND: 1&gt;</em>, <em class="sig-param">flush_every=16</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.data.ProbePersistanceMem" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pram.data.ProbePersistanceDB" title="pram.data.ProbePersistanceDB"><code class="xref py py-class docutils literal notranslate"><span class="pre">pram.data.ProbePersistanceDB</span></code></a></p>
<p>Relational in-memory database based probe persistance.</p>
<p>This class is a very light and elegant specialization of the ProbePersistanceDB class.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mode</strong> (<em>int</em>) – Persistance mode (i.e., append or overwrite; use the ProbePersistanceMode enum type).</p></li>
<li><p><strong>flush_every</strong> (<em>int</em>) – Memory-to-database flush frequency.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="class">
<dt id="pram.data.ProbePersistanceMode">
<em class="property">class </em><code class="sig-prename descclassname">pram.data.</code><code class="sig-name descname">ProbePersistanceMode</code><a class="headerlink" href="#pram.data.ProbePersistanceMode" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">enum.IntEnum</span></code></p>
<p>Probe persistance mode enum.</p>
<p>A probe can either append new data or overwrite the existing data.</p>
<dl class="attribute">
<dt id="pram.data.ProbePersistanceMode.APPEND">
<code class="sig-name descname">APPEND</code><em class="property"> = 1</em><a class="headerlink" href="#pram.data.ProbePersistanceMode.APPEND" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pram.data.ProbePersistanceMode.OVERWRITE">
<code class="sig-name descname">OVERWRITE</code><em class="property"> = 2</em><a class="headerlink" href="#pram.data.ProbePersistanceMode.OVERWRITE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pram.data.Var">
<em class="property">class </em><code class="sig-prename descclassname">pram.data.</code><code class="sig-name descname">Var</code><a class="headerlink" href="#pram.data.Var" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pram.data.Var" title="pram.data.Var"><code class="xref py py-class docutils literal notranslate"><span class="pre">pram.data.Var</span></code></a></p>
<p>Probe’s variable.</p>
<p>A probe can be in charge of storing multiple variables that relate to the state of the simulation as it evolves.  This
class shows how such a variable can be defined.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>name</strong> (<em>str</em>) – The variable’s name.  If relational database persistance is used, this name will become the name of a
table column.  While PyPRAM escapes special characters, problematic names should be avoided (e.g., those
containing spaces or weird characters).</p></li>
<li><p><strong>type</strong> (<em>str</em>) – The variable’s type.  If relational database persistance is used, this needs to be a valid data types
of the RDBMS of choice.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-pram.entity">
<span id="pram-entity-module"></span><h2>pram.entity module<a class="headerlink" href="#module-pram.entity" title="Permalink to this headline">¶</a></h2>
<p>Contains PRAM entity code.</p>
<p>The three types of entities which can comprise a PRAM model are <em>groups</em>, <em>sites</em>, and <em>resources</em>.</p>
<dl class="class">
<dt id="pram.entity.Agent">
<em class="property">class </em><code class="sig-prename descclassname">pram.entity.</code><code class="sig-name descname">Agent</code><span class="sig-paren">(</span><em class="sig-param">name=None</em>, <em class="sig-param">sex=&lt;AttrSex.F: 1&gt;</em>, <em class="sig-param">age=40</em>, <em class="sig-param">school=None</em>, <em class="sig-param">work=None</em>, <em class="sig-param">location='home'</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.entity.Agent" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pram.entity.Entity" title="pram.entity.Entity"><code class="xref py py-class docutils literal notranslate"><span class="pre">pram.entity.Entity</span></code></a></p>
<p>A singular agent.</p>
<p>A legacy class pending non-immediate removal or a proper integration into PRAM framework.  As such, it makes no
sense to document it well at this point.</p>
<dl class="attribute">
<dt id="pram.entity.Agent.AGE_M">
<code class="sig-name descname">AGE_M</code><em class="property"> = 40</em><a class="headerlink" href="#pram.entity.Agent.AGE_M" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pram.entity.Agent.AGE_MAX">
<code class="sig-name descname">AGE_MAX</code><em class="property"> = 120</em><a class="headerlink" href="#pram.entity.Agent.AGE_MAX" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pram.entity.Agent.AGE_MIN">
<code class="sig-name descname">AGE_MIN</code><em class="property"> = 0</em><a class="headerlink" href="#pram.entity.Agent.AGE_MIN" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pram.entity.Agent.AGE_SD">
<code class="sig-name descname">AGE_SD</code><em class="property"> = 20</em><a class="headerlink" href="#pram.entity.Agent.AGE_SD" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pram.entity.Agent.P_STUDENT">
<code class="sig-name descname">P_STUDENT</code><em class="property"> = 0.25</em><a class="headerlink" href="#pram.entity.Agent.P_STUDENT" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pram.entity.Agent.P_WORKER">
<code class="sig-name descname">P_WORKER</code><em class="property"> = 0.6</em><a class="headerlink" href="#pram.entity.Agent.P_WORKER" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pram.entity.Agent.age">
<code class="sig-name descname">age</code><a class="headerlink" href="#pram.entity.Agent.age" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.entity.Agent.gen">
<em class="property">classmethod </em><code class="sig-name descname">gen</code><span class="sig-paren">(</span><em class="sig-param">name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.entity.Agent.gen" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates a singular agent.</p>
</dd></dl>

<dl class="method">
<dt id="pram.entity.Agent.gen_lst">
<em class="property">classmethod </em><code class="sig-name descname">gen_lst</code><span class="sig-paren">(</span><em class="sig-param">n</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.entity.Agent.gen_lst" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates a list of agents (with auto-incrementing names).</p>
</dd></dl>

<dl class="attribute">
<dt id="pram.entity.Agent.location">
<code class="sig-name descname">location</code><a class="headerlink" href="#pram.entity.Agent.location" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pram.entity.Agent.name">
<code class="sig-name descname">name</code><a class="headerlink" href="#pram.entity.Agent.name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.entity.Agent.random_age">
<em class="property">static </em><code class="sig-name descname">random_age</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pram.entity.Agent.random_age" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.entity.Agent.random_sex">
<em class="property">static </em><code class="sig-name descname">random_sex</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pram.entity.Agent.random_sex" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pram.entity.Agent.school">
<code class="sig-name descname">school</code><a class="headerlink" href="#pram.entity.Agent.school" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pram.entity.Agent.sex">
<code class="sig-name descname">sex</code><a class="headerlink" href="#pram.entity.Agent.sex" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pram.entity.Agent.work">
<code class="sig-name descname">work</code><a class="headerlink" href="#pram.entity.Agent.work" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pram.entity.AttrSex">
<em class="property">class </em><code class="sig-prename descclassname">pram.entity.</code><code class="sig-name descname">AttrSex</code><a class="headerlink" href="#pram.entity.AttrSex" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">enum.IntEnum</span></code></p>
<p>An enumeration.</p>
<dl class="attribute">
<dt id="pram.entity.AttrSex.F">
<code class="sig-name descname">F</code><em class="property"> = 1</em><a class="headerlink" href="#pram.entity.AttrSex.F" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pram.entity.AttrSex.M">
<code class="sig-name descname">M</code><em class="property"> = 2</em><a class="headerlink" href="#pram.entity.AttrSex.M" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pram.entity.DistributionAgeSchool">
<em class="property">class </em><code class="sig-prename descclassname">pram.entity.</code><code class="sig-name descname">DistributionAgeSchool</code><span class="sig-paren">(</span><em class="sig-param">momtype=1</em>, <em class="sig-param">a=None</em>, <em class="sig-param">b=None</em>, <em class="sig-param">xtol=1e-14</em>, <em class="sig-param">badvalue=None</em>, <em class="sig-param">name=None</em>, <em class="sig-param">longname=None</em>, <em class="sig-param">shapes=None</em>, <em class="sig-param">extradoc=None</em>, <em class="sig-param">seed=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.entity.DistributionAgeSchool" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">scipy.stats._distn_infrastructure.rv_continuous</span></code></p>
</dd></dl>

<dl class="class">
<dt id="pram.entity.DistributionAgeWork">
<em class="property">class </em><code class="sig-prename descclassname">pram.entity.</code><code class="sig-name descname">DistributionAgeWork</code><span class="sig-paren">(</span><em class="sig-param">momtype=1</em>, <em class="sig-param">a=None</em>, <em class="sig-param">b=None</em>, <em class="sig-param">xtol=1e-14</em>, <em class="sig-param">badvalue=None</em>, <em class="sig-param">name=None</em>, <em class="sig-param">longname=None</em>, <em class="sig-param">shapes=None</em>, <em class="sig-param">extradoc=None</em>, <em class="sig-param">seed=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.entity.DistributionAgeWork" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">scipy.stats._distn_infrastructure.rv_continuous</span></code></p>
</dd></dl>

<dl class="class">
<dt id="pram.entity.Entity">
<em class="property">class </em><code class="sig-prename descclassname">pram.entity.</code><code class="sig-name descname">Entity</code><span class="sig-paren">(</span><em class="sig-param">type</em>, <em class="sig-param">id</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.entity.Entity" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">abc.ABC</span></code></p>
<p>Entity base class.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>type</strong> (<em>int</em>) – Entity type (see <a class="reference internal" href="#pram.entity.EntityType" title="pram.entity.EntityType"><code class="xref py py-class docutils literal notranslate"><span class="pre">EntityType</span></code></a> enum).</p></li>
<li><p><strong>id</strong> (<em>str</em>) – Entity identifier string (currently not used and pending removal).</p></li>
</ul>
</dd>
</dl>
<div class="admonition-todo admonition" id="id2">
<p class="admonition-title">Todo</p>
<p>Remove the <code class="docutils literal notranslate"><span class="pre">id</span></code> argument</p>
</div>
<dl class="attribute">
<dt id="pram.entity.Entity.id">
<code class="sig-name descname">id</code><a class="headerlink" href="#pram.entity.Entity.id" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pram.entity.Entity.type">
<code class="sig-name descname">type</code><a class="headerlink" href="#pram.entity.Entity.type" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pram.entity.EntityType">
<em class="property">class </em><code class="sig-prename descclassname">pram.entity.</code><code class="sig-name descname">EntityType</code><a class="headerlink" href="#pram.entity.EntityType" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">enum.IntEnum</span></code></p>
<p>Entity type enum.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The <code class="docutils literal notranslate"><span class="pre">AGENT</span></code> type is not currently used and is included here or potential future extensions.</p>
</div>
<dl class="attribute">
<dt id="pram.entity.EntityType.AGENT">
<code class="sig-name descname">AGENT</code><em class="property"> = 1</em><a class="headerlink" href="#pram.entity.EntityType.AGENT" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pram.entity.EntityType.GROUP">
<code class="sig-name descname">GROUP</code><em class="property"> = 2</em><a class="headerlink" href="#pram.entity.EntityType.GROUP" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pram.entity.EntityType.RESOURCE">
<code class="sig-name descname">RESOURCE</code><em class="property"> = 4</em><a class="headerlink" href="#pram.entity.EntityType.RESOURCE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pram.entity.EntityType.SITE">
<code class="sig-name descname">SITE</code><em class="property"> = 3</em><a class="headerlink" href="#pram.entity.EntityType.SITE" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pram.entity.Group">
<em class="property">class </em><code class="sig-prename descclassname">pram.entity.</code><code class="sig-name descname">Group</code><span class="sig-paren">(</span><em class="sig-param">name=None</em>, <em class="sig-param">m=0.0</em>, <em class="sig-param">attr={}</em>, <em class="sig-param">rel={}</em>, <em class="sig-param">callee=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.entity.Group" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pram.entity.Entity" title="pram.entity.Entity"><code class="xref py py-class docutils literal notranslate"><span class="pre">pram.entity.Entity</span></code></a></p>
<p>A group of agents.</p>
<p>Grouping of functionally equivalent agents is at the heart of the idea behind PRAMs.  To that end, a group is the
primary type of entity in the framework.  Groups are considered identical if they have ideantical attributes and
relations (i.e., the keys and values of those dictrionaries must be identical).  Consequently, agents belonging to
identical groups are considered (by definition) functionally equivalent.  It is important to note that only one
group with a particular combination of attributes and relations can exist in PRAM.</p>
<p>Here is an example of creating and setting up a group in a chain of method calls:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">Simulation</span><span class="p">()</span><span class="o">.</span>
    <span class="n">add</span><span class="p">()</span><span class="o">.</span>
        <span class="n">rule</span><span class="p">(</span><span class="o">...</span><span class="p">)</span><span class="o">.</span>   <span class="c1"># add a rule that encodes the dynamics of the simulation</span>
        <span class="n">probe</span><span class="p">(</span><span class="o">...</span><span class="p">)</span><span class="o">.</span>  <span class="c1"># add a probe to monitor/save the results</span>
        <span class="n">done</span><span class="p">()</span><span class="o">.</span>
    <span class="n">new_group</span><span class="p">(</span><span class="mi">1000</span><span class="p">)</span><span class="o">.</span>                      <span class="c1"># a group of a 1000 agents</span>
        <span class="n">set_attr</span><span class="p">(</span><span class="s1">&#39;income&#39;</span><span class="p">,</span> <span class="s1">&#39;medium&#39;</span><span class="p">)</span><span class="o">.</span>     <span class="c1"># with medium income</span>
        <span class="n">set_rel</span><span class="p">(</span><span class="n">Site</span><span class="o">.</span><span class="n">AT</span><span class="p">,</span> <span class="n">Site</span><span class="p">(</span><span class="s1">&#39;home&#39;</span><span class="p">]))</span><span class="o">.</span>  <span class="c1"># who are all currently at a site called &#39;home&#39;</span>
        <span class="n">done</span><span class="p">()</span><span class="o">.</span>                           <span class="c1"># go back to the Simulation object</span>
    <span class="n">run</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span>
<span class="p">)</span>
</pre></div>
</div>
<p>Naturally, group can also be created in a regular fashion like so:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">Simulation</span><span class="p">()</span><span class="o">.</span>
    <span class="n">add</span><span class="p">([</span>
       <span class="o">...</span><span class="p">,</span>  <span class="c1"># a rule</span>
       <span class="o">...</span><span class="p">,</span>  <span class="c1"># a probe</span>
       <span class="n">Group</span><span class="p">(</span><span class="n">m</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">attr</span><span class="o">=</span><span class="p">{</span> <span class="s1">&#39;income&#39;</span><span class="p">:</span> <span class="s1">&#39;medium&#39;</span> <span class="p">},</span> <span class="n">rel</span><span class="o">=</span><span class="p">{</span> <span class="n">Site</span><span class="o">.</span><span class="n">AT</span><span class="p">:</span> <span class="n">Site</span><span class="p">(</span><span class="s1">&#39;home&#39;</span><span class="p">]</span> <span class="p">})</span>
    <span class="p">])</span><span class="o">.</span>
    <span class="n">run</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span>
<span class="p">)</span>
</pre></div>
</div>
<p>PyPRAM supports this sort of expressive plurarism because doing stuff in only one way doesn’t always yield the
cleanest and most readible code.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>name</strong> (<em>str</em><em>, </em><em>optional</em>) – The name of the group.  This argument is inconsequential to PyPRAM’s engine operation.</p></li>
<li><p><strong>m</strong> (<em>float</em>) – Agent population mass.  While it is not entirely logical to think about agent mass in terms of
fractional numbers, PRAM distributes population mass probabilistically and it doesn’t guarantee
intra-group movement of “entire” agents.  What it does guarantee, however, is that the total mass being
moved adds up to one.  In large populations, treating agents as continuous mass rather than individuals is
inconsequential.</p></li>
<li><p><strong>attr</strong> (<em>Mapping</em><em>[</em><em>str</em><em>, </em><em>Any</em><em>]</em>) – The group’s attributes.</p></li>
<li><p><strong>rel</strong> (<em>Mapping</em><em>[</em><em>str</em><em>, </em><a class="reference internal" href="#pram.entity.Site" title="pram.entity.Site"><em>Site</em></a><em>]</em>) – The group’s relations.</p></li>
<li><p><strong>callee</strong> (<em>object</em><em>, </em><em>optional</em>) – The object invoking the contructor.  This argument is used only throughout the
process of creating a group.  The reference to the invoking object can is returned by
<code class="xref py py-meth docutils literal notranslate"><span class="pre">Group.done()</span> <span class="pre">pram.entity.Group.done()</span></code>.  See usage examples above.</p></li>
</ul>
</dd>
</dl>
<dl class="method">
<dt id="pram.entity.Group.__eq__">
<code class="sig-name descname">__eq__</code><span class="sig-paren">(</span><em class="sig-param">other</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.entity.Group.__eq__" title="Permalink to this definition">¶</a></dt>
<dd><p>Compare this group to another.</p>
<p>When comparing groups, only attributes and relations matter; name and size are irrelevant.  Note that we need
to implement this method regardless, because the one inherited from the ‘object’ class works by object identity
only which is largely useless for us.</p>
</dd></dl>

<dl class="method">
<dt id="pram.entity.Group._has">
<em class="property">static </em><code class="sig-name descname">_has</code><span class="sig-paren">(</span><em class="sig-param">d</em>, <em class="sig-param">qry</em>, <em class="sig-param">used_set</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.entity.Group._has" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks if a dictionary has keys or key-value pairs specified.</p>
<p>This method compares the dictionary <code class="docutils literal notranslate"><span class="pre">d</span></code> against <code class="docutils literal notranslate"><span class="pre">qry</span></code> which can be a mapping, an iterable, and a string.
Depending on the type of <code class="docutils literal notranslate"><span class="pre">qry</span></code>, the method returns True only if (and False otherwise):</p>
<ul class="simple">
<li><p>string: <code class="docutils literal notranslate"><span class="pre">qry</span></code> must be a key in <code class="docutils literal notranslate"><span class="pre">d</span></code></p></li>
<li><p>iterable: all items in <code class="docutils literal notranslate"><span class="pre">qry</span></code> must be keys in <code class="docutils literal notranslate"><span class="pre">d</span></code></p></li>
<li><p>mapping: all items in <code class="docutils literal notranslate"><span class="pre">qry</span></code> must exist in <code class="docutils literal notranslate"><span class="pre">d</span></code></p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>d</strong> (<em>Mapping</em><em>[</em><em>str</em><em>, </em><em>Any</em><em>]</em>) – The original mapping.</p></li>
<li><p><strong>qry</strong> (<em>Union</em><em>[</em><em>str</em><em>, </em><em>Iterable</em><em>[</em><em>str</em><em>]</em><em>, </em><em>Mapping</em><em>[</em><em>str</em><em>, </em><em>Any</em><em>]</em><em>]</em>) – The required content that <code class="docutils literal notranslate"><span class="pre">d</span></code> will be queried
against.</p></li>
<li><p><strong>used_set</strong> (<em>Set</em><em>[</em><em>Any</em><em>]</em>) – A set of attributes or relations that stores the ones that have been conditioned upon
by the simulation rules.  This is used internally by PyPRAM.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><dl class="simple">
<dt>True if (False otherwise):</dt><dd><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">qry</span></code> is a string and is a key in <code class="docutils literal notranslate"><span class="pre">d</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">qry</span></code> is an iterable and all items in <code class="docutils literal notranslate"><span class="pre">qry</span></code> are keys in <code class="docutils literal notranslate"><span class="pre">d</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">qry</span></code> is a mapping and all items in <code class="docutils literal notranslate"><span class="pre">qry</span></code> exist in <code class="docutils literal notranslate"><span class="pre">d</span></code></p></li>
</ul>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pram.entity.Group._isinstance">
<code class="sig-name descname">_isinstance</code><span class="sig-paren">(</span><em class="sig-param">qry</em>, <em class="sig-param">type</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.entity.Group._isinstance" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks if items in the ‘qry’ are all of the specified ‘type’.  ‘qry’ can be a dictionary, an iterable, or a
string.</p>
</dd></dl>

<dl class="method">
<dt id="pram.entity.Group.apply_rules">
<code class="sig-name descname">apply_rules</code><span class="sig-paren">(</span><em class="sig-param">pop</em>, <em class="sig-param">rules</em>, <em class="sig-param">iter</em>, <em class="sig-param">t</em>, <em class="sig-param">is_rule_setup=False</em>, <em class="sig-param">is_rule_cleanup=False</em>, <em class="sig-param">is_sim_setup=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.entity.Group.apply_rules" title="Permalink to this definition">¶</a></dt>
<dd><p>Applies all the simulation rules to the group.</p>
<p>Applies the list of rules, each of which may split the group into (possibly already extant) subgroups.  A
sequential rule application scheme is (by the definition of sequentiality) bound to produce order effects which
are undesirable.  To mitigate that problem, a Cartesian product of all the rule outcomes (i.e., split
specifications; GroupSplitSpec class) is computed and the resulting cross-product spit specs are used to do the
actual splitting.</p>
<p>When creating the product of split specs created by the individual rules, the probabilities associated with
those individual split specs are multiplied because the rules are assumed to be independent.  Any dependencies
are assumed to have been handles inside the rules themselves.</p>
<p>The two special rule modes this method can be called in are: setup and cleanup.  Neither of these modes
checks for applicability; that should be performed inside the setup() and cleanup() method of a rule.  An
additional special mode is that of the simulation group setup (i.e., is_sim_setup = True).  In that mode,
the ‘rules’ argument is assumed to be a function to be called for the group (and not an iterable of Rule
classes as is usual in normal operation).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>pop</strong> (<a class="reference internal" href="#pram.pop.GroupPopulation" title="pram.pop.GroupPopulation"><em>GroupPopulation</em></a>) – The group population.</p></li>
<li><p><strong>rules</strong> (<em>Iterable</em><em>[</em><a class="reference internal" href="#pram.rule.Rule" title="pram.rule.Rule"><em>Rule</em></a><em>]</em>) – Rules to be applied.  Only rules compatible with the group will actually be applied
as determined by the <code class="xref py py-meth docutils literal notranslate"><span class="pre">is_applicable()</span></code> method.</p></li>
<li><p><strong>iter</strong> (<em>int</em>) – Simulation iterations.</p></li>
<li><p><strong>t</strong> (<em>int</em>) – Simulation time.</p></li>
<li><p><strong>is_rule_setup</strong> (<em>bool</em>) – Flag: Is this invocation of this method during rule setup stage of the simulation?</p></li>
<li><p><strong>is_rule_cleanup</strong> (<em>bool</em>) – Flag: Is this invocation of this method during rule cleanup stage of the
simulation?</p></li>
<li><p><strong>is_sim_setup</strong> (<em>bool</em>) – Flag: Is this invocation of this method during simulation setup stage?</p></li>
</ul>
</dd>
</dl>
<div class="admonition-todo admonition" id="id3">
<p class="admonition-title">Todo</p>
<p>Think if the dependencies between rules could (or perhaps even should) be read from some sort of a graph.
Perhaps then multiplying the probabilities would not be appropriate.</p>
</div>
<p>—-[ Possible future extension ]—-</p>
<p>Superposition principle (or superposition property), states that, for all linear systems, the net response
caused by two or more stimuli is the sum of the responses that would have been caused by each stimulus
individually. So that if input A produces response X and input B produces response Y then input (A + B)
produces response (X + Y).</p>
<p>A function F(x) that satisfies the superposition principle is called a linear function. Superposition can be
defined by two simpler properties, additivity and homogeneity:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">F</span><span class="p">(</span><span class="n">x1</span> <span class="o">+</span> <span class="n">x2</span><span class="p">)</span> <span class="o">=</span> <span class="n">F</span><span class="p">(</span><span class="n">x1</span><span class="p">)</span> <span class="o">+</span> <span class="n">F</span><span class="p">(</span><span class="n">x2</span><span class="p">)</span>   <span class="c1"># additivity</span>
<span class="n">F</span><span class="p">(</span><span class="n">ax</span><span class="p">)</span> <span class="o">=</span> <span class="n">aF</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>                <span class="c1"># homogeneity</span>
</pre></div>
</div>
<p>for scalar <code class="docutils literal notranslate"><span class="pre">a</span></code>.</p>
<p>(…)</p>
<p>The superposition principle applies to any linear system, including algebraic equations, linear differential
equations, and systems of equations of those forms. The stimuli and responses could be numbers, functions,
vectors, vector fields, time-varying signals, or any other object that satisfies certain axioms. Note that when
vectors or vector fields are involved, a superposition is interpreted as a vector sum.</p>
<p>SRC: <a class="reference external" href="https://en.wikipedia.org/wiki/Superposition_principle">https://en.wikipedia.org/wiki/Superposition_principle</a></p>
</dd></dl>

<dl class="attribute">
<dt id="pram.entity.Group.attr">
<code class="sig-name descname">attr</code><a class="headerlink" href="#pram.entity.Group.attr" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pram.entity.Group.attr_used">
<code class="sig-name descname">attr_used</code><em class="property"> = None</em><a class="headerlink" href="#pram.entity.Group.attr_used" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pram.entity.Group.callee">
<code class="sig-name descname">callee</code><a class="headerlink" href="#pram.entity.Group.callee" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.entity.Group.done">
<code class="sig-name descname">done</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pram.entity.Group.done" title="Permalink to this definition">¶</a></dt>
<dd><p>Ends creating the group by notifing the callee that has begun the group creation.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Reference to the object that initiated the group creation (can be None).</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>object</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pram.entity.Group.freeze">
<code class="sig-name descname">freeze</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pram.entity.Group.freeze" title="Permalink to this definition">¶</a></dt>
<dd><p>Freezes the group.</p>
<p>No direct changes to the group’s identity as seen from the point of view of PRAM’s engine operation can be made
to a frozen group.  A group’s identity is defined by the composition of its attributes and relations.  Groups
are automatically frozen when added to the GroupPopulation object to prevent the user from interfering with
PyPRAM’s operation.</p>
</dd></dl>

<dl class="method">
<dt id="pram.entity.Group.ga">
<code class="sig-name descname">ga</code><span class="sig-paren">(</span><em class="sig-param">name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.entity.Group.ga" title="Permalink to this definition">¶</a></dt>
<dd><p>See <a class="reference internal" href="#pram.entity.Group.get_attr" title="pram.entity.Group.get_attr"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_attr()</span></code></a> method.</p>
</dd></dl>

<dl class="method">
<dt id="pram.entity.Group.gen_dict">
<em class="property">static </em><code class="sig-name descname">gen_dict</code><span class="sig-paren">(</span><em class="sig-param">d_in</em>, <em class="sig-param">d_upd=None</em>, <em class="sig-param">k_del=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.entity.Group.gen_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates a dictionary.</p>
<p>This method is used to create new dictionaries based on existing ones and given changes to those existing ones.
Specifically, a new dictionary is based on the ‘d_in’ dictionary with values updated based on the ‘d_upd’
dictionary and keys deleted based on the ‘k_del’ iterable.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>d_in</strong> (<em>Mapping</em><em>[</em><em>str</em><em>, </em><em>Any</em><em>]</em>) – Original mapping.</p></li>
<li><p><strong>d_upd</strong> (<em>Mapping</em><em>[</em><em>str</em><em>, </em><em>Any</em><em>]</em><em>, </em><em>optional</em>) – Key-values to be set on the original mapping.</p></li>
<li><p><strong>k_del</strong> (<em>Iterable</em><em>[</em><em>str</em><em>]</em><em>, </em><em>optional</em>) – An iterable of keys to be removed from the original mapping.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A shallow copy of the updated original mapping.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>Mapping</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>A shallow copy of the dictionary is returned at this point.  That is to avoid creating unnecessary copies
of entities that might be stored as relations.  A more adaptive mechanism can be implemented later if
needed.</p>
<div class="admonition-todo admonition" id="id4">
<p class="admonition-title">Todo</p>
<p>Consider: <a class="reference external" href="https://stackoverflow.com/questions/38987/how-to-merge-two-dictionaries-in-a-single-expression">https://stackoverflow.com/questions/38987/how-to-merge-two-dictionaries-in-a-single-expression</a></p>
</div>
</dd></dl>

<dl class="method">
<dt id="pram.entity.Group.gen_from_db">
<em class="property">classmethod </em><code class="sig-name descname">gen_from_db</code><span class="sig-paren">(</span><em class="sig-param">db_fpath</em>, <em class="sig-param">tbl</em>, <em class="sig-param">attr_db=[]</em>, <em class="sig-param">rel_db=[]</em>, <em class="sig-param">attr_fix={}</em>, <em class="sig-param">rel_fix={}</em>, <em class="sig-param">rel_at=None</em>, <em class="sig-param">limit=0</em>, <em class="sig-param">fn_live_info=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.entity.Group.gen_from_db" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate groups from a relational database.</p>
<p>In this method, lists are sometimes converted to allow for set operations (e.g., union or difference) and the
results of those operations are converted back to lists for nice output printout (e.g., ‘[]’ is more succinct
than ‘set()’, which is what an empty set is printed out as).</p>
<p>This is a central method for generating complete group populations from relational databases in that it
automatically calls the <code class="xref py py-meth docutils literal notranslate"><span class="pre">Site.gen_from_db()</span> <span class="pre">~pram.entity.Site.gen_from_db()</span></code> when necessary.</p>
<p>For usage example see <code class="xref py py-meth docutils literal notranslate"><span class="pre">SimulationDBI.gen_groups()</span> <span class="pre">pram.sim.SimulationDBI.gen_groups()</span></code> and
<code class="xref py py-meth docutils literal notranslate"><span class="pre">Simulation.gen_groups_from_db()</span> <span class="pre">pram.sim.Simulation.gen_groups_from_db()</span></code> methods; both invoke the current
method internally.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>db_fpath</strong> (<em>str</em>) – Path to the database file (SQLite3).</p></li>
<li><p><strong>tbl</strong> (<em>str</em>) – Table name.</p></li>
<li><p><strong>attr_db</strong> (<em>Iterable</em><em>[</em><em>str</em><em>]</em>) – Group attributes to be retrieved from the database (if extant).</p></li>
<li><p><strong>rel_db</strong> (<em>Iterable</em><em>[</em><a class="reference internal" href="#pram.entity.GroupDBRelSpec" title="pram.entity.GroupDBRelSpec"><em>GroupDBRelSpec</em></a><em>]</em>) – Group relation to be retrieved from the database (if extant).</p></li>
<li><p><strong>attr_fix</strong> (<em>Mappint</em><em>[</em><em>str</em><em>, </em><em>Any</em><em>]</em>) – Group attributes to be fixed for every group.</p></li>
<li><p><strong>rel_fix</strong> (<em>Mapping</em><em>[</em><em>str</em><em>, </em><a class="reference internal" href="#pram.entity.Site" title="pram.entity.Site"><em>Site</em></a><em>]</em>) – Group relations to be fixed for every group.</p></li>
<li><p><strong>rel_at</strong> (<a class="reference internal" href="#pram.entity.Site" title="pram.entity.Site"><em>Site</em></a><em>, </em><em>optional</em>) – A site to be set as every group’s current location.</p></li>
<li><p><strong>limit</strong> (<em>int</em>) – The maximum number of groups to be generated.  Ordinarily, this is not changed from its
default value of zero.  It is however useful for testing, especially with very large databases.</p></li>
<li><p><strong>fn_live_info</strong> (<em>Callable</em>) – A callable expecting a single string argument for real-time printing.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A list of groups generated.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>list(<a class="reference internal" href="#pram.entity.Group" title="pram.entity.Group">Group</a>)</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pram.entity.Group.gen_from_db_tmp1">
<em class="property">classmethod </em><code class="sig-name descname">gen_from_db_tmp1</code><span class="sig-paren">(</span><em class="sig-param">sim</em>, <em class="sig-param">db_fpath</em>, <em class="sig-param">tbl</em>, <em class="sig-param">attr={}</em>, <em class="sig-param">rel={}</em>, <em class="sig-param">attr_db=[]</em>, <em class="sig-param">rel_db=[]</em>, <em class="sig-param">rel_at=None</em>, <em class="sig-param">limit=0</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.entity.Group.gen_from_db_tmp1" title="Permalink to this definition">¶</a></dt>
<dd><p>A legacy method pending non-immediate removal.</p>
<p>An unsuccessful attempt to internalize generation of sites from the DB.  As of 2019.04.24 this is no longer the
main development route as another has proved more fruitful.  Keeping this method here in case it comes useful
at some point.</p>
</dd></dl>

<dl class="method">
<dt id="pram.entity.Group.gen_from_db_tmp2">
<em class="property">classmethod </em><code class="sig-name descname">gen_from_db_tmp2</code><span class="sig-paren">(</span><em class="sig-param">db_fpath</em>, <em class="sig-param">tbl</em>, <em class="sig-param">attr_db=[]</em>, <em class="sig-param">rel_db=[]</em>, <em class="sig-param">attr_fix={}</em>, <em class="sig-param">rel_fix={}</em>, <em class="sig-param">rel_at=None</em>, <em class="sig-param">limit=0</em>, <em class="sig-param">fn_live_info=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.entity.Group.gen_from_db_tmp2" title="Permalink to this definition">¶</a></dt>
<dd><p>A legacy method pending non-immediate removal.</p>
<p>Before generating sites based on the DB schema.  Works.</p>
<p>In this method, lists are sometimes converted to allow for set operations (e.g., union or difference) and the
results of those operations are converted back to lists for nice output printout (e.g., ‘[]’ is more succinct
than ‘set()’, which is what an empty set is printed out as).</p>
</dd></dl>

<dl class="method">
<dt id="pram.entity.Group.gen_hash">
<em class="property">static </em><code class="sig-name descname">gen_hash</code><span class="sig-paren">(</span><em class="sig-param">attr</em>, <em class="sig-param">rel=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.entity.Group.gen_hash" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates the group’s hash.</p>
<p>Generates a hash for the attributes and relations dictionaries.  This sort of hash is desired because groups
are judged functionally equivalent based on the content of those two dictionaries alone (i.e., the name and the
size of a group does not affect its identity).</p>
<p>The following non-cryptographic hashing algorithms have been tested:</p>
<ul class="simple">
<li><p>hash()</p></li>
<li><p>hashlib.sha1()</p></li>
<li><p>xxhash.xxh32()</p></li>
<li><p>xxhash.xxh64()</p></li>
</ul>
<p>As is evident from the source code, each of the algorithms required a slightly different treatment of the
attribute and relation dictionaries.  All these options are legitimate and they don’t differ much in terms of
speed.  They do howeve differ in terms of reproducability.  Namely, the results of the built-in hash() function
cannot be compared between-runs while the other ones can.  This behavior of the hash() function is to prevent
attackers from reusing hashes and it can be disabled by setting ‘PYTHONHASHSEED=0’.</p>
<p>The user can uncomment the desired method to use it, but it is not recommended.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>attr</strong> (<em>Mapping</em><em>[</em><em>str</em><em>, </em><em>Any</em><em>]</em>) – Group’s attributes.</p></li>
<li><p><strong>rel</strong> (<em>Mapping</em><em>[</em><em>str</em><em>, </em><a class="reference internal" href="#pram.entity.Site" title="pram.entity.Site"><em>Site</em></a><em>]</em><em>, </em><em>optional</em>) – Group’s relations.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A hash of the attributes and relations specified.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>str</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pram.entity.Group.get_attr">
<code class="sig-name descname">get_attr</code><span class="sig-paren">(</span><em class="sig-param">name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.entity.Group.get_attr" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieves attribute’s value.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>name</strong> (<em>str</em>) – Attribute’s name.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Attribute’s value.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>Any</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pram.entity.Group.get_hash">
<code class="sig-name descname">get_hash</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pram.entity.Group.get_hash" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the group’s hash.</p>
<p>Groups are hashed on their attributes and relations, both being dictionaries.</p>
<p>Calling this method should be the only way to get the group’s hash.  Wanna do it otherwise?  Get ready for a
world of hurt.</p>
</dd></dl>

<dl class="method">
<dt id="pram.entity.Group.get_mass">
<code class="sig-name descname">get_mass</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pram.entity.Group.get_mass" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.entity.Group.get_mass_at">
<code class="sig-name descname">get_mass_at</code><span class="sig-paren">(</span><em class="sig-param">qry</em>, <em class="sig-param">site='&#64;'</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.entity.Group.get_mass_at" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the proportion of mass at a specific site.</p>
<p>For example, a proportion of infected agents at a particular school.  By default, the site is the groups
current location.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>qry</strong> (<a class="reference internal" href="#pram.entity.GroupQry" title="pram.entity.GroupQry"><em>GroupQry</em></a>) – Group selector.</p></li>
<li><p><strong>site</strong> (<a class="reference internal" href="#pram.entity.Site" title="pram.entity.Site"><em>Site</em></a>) – The site to measure population proportions at.  Defaults to the groups current location.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Proportion of the total agent population mass at the site.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pram.entity.Group.get_rel">
<code class="sig-name descname">get_rel</code><span class="sig-paren">(</span><em class="sig-param">name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.entity.Group.get_rel" title="Permalink to this definition">¶</a></dt>
<dd><p>Retrieves relation’s value.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>name</strong> (<em>str</em>) – Relation’s name.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Relation’s value.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>Any</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pram.entity.Group.gr">
<code class="sig-name descname">gr</code><span class="sig-paren">(</span><em class="sig-param">name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.entity.Group.gr" title="Permalink to this definition">¶</a></dt>
<dd><p>See <a class="reference internal" href="#pram.entity.Group.get_rel" title="pram.entity.Group.get_rel"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_rel()</span></code></a> method.</p>
</dd></dl>

<dl class="method">
<dt id="pram.entity.Group.ha">
<code class="sig-name descname">ha</code><span class="sig-paren">(</span><em class="sig-param">qry</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.entity.Group.ha" title="Permalink to this definition">¶</a></dt>
<dd><p>See <a class="reference internal" href="#pram.entity.Group.has_attr" title="pram.entity.Group.has_attr"><code class="xref py py-meth docutils literal notranslate"><span class="pre">has_attr()</span></code></a> method.</p>
</dd></dl>

<dl class="method">
<dt id="pram.entity.Group.has_attr">
<code class="sig-name descname">has_attr</code><span class="sig-paren">(</span><em class="sig-param">qry</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.entity.Group.has_attr" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks if the group has the specified attributes.</p>
<p>See <a class="reference internal" href="#pram.entity.Group._has" title="pram.entity.Group._has"><code class="xref py py-meth docutils literal notranslate"><span class="pre">_has()</span></code></a> method for details on what <code class="docutils literal notranslate"><span class="pre">qry</span></code> can be and the specifics of the check.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pram.entity.Group.has_rel">
<code class="sig-name descname">has_rel</code><span class="sig-paren">(</span><em class="sig-param">qry</em>, <em class="sig-param">are_sites=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.entity.Group.has_rel" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks if the group has the specified relations.</p>
<p>See <a class="reference internal" href="#pram.entity.Group._has" title="pram.entity.Group._has"><code class="xref py py-meth docutils literal notranslate"><span class="pre">_has()</span></code></a> method for details on what <code class="docutils literal notranslate"><span class="pre">qry</span></code> can be and the specifics of the check.</p>
<div class="admonition-todo admonition" id="id5">
<p class="admonition-title">Todo</p>
<p>Remove the <code class="docutils literal notranslate"><span class="pre">are_sites</span></code> argument?</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pram.entity.Group.has_sites">
<code class="sig-name descname">has_sites</code><span class="sig-paren">(</span><em class="sig-param">qry</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.entity.Group.has_sites" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks if the groups has the sites specified.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>qry</strong> (<em>Iterable</em><em>[</em><a class="reference internal" href="#pram.entity.Site" title="pram.entity.Site"><em>Site</em></a><em>]</em>) – Sites required.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="pram.entity.Group.hash">
<code class="sig-name descname">hash</code><a class="headerlink" href="#pram.entity.Group.hash" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.entity.Group.hr">
<code class="sig-name descname">hr</code><span class="sig-paren">(</span><em class="sig-param">qry</em>, <em class="sig-param">are_sites=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.entity.Group.hr" title="Permalink to this definition">¶</a></dt>
<dd><p>See <a class="reference internal" href="#pram.entity.Group.has_rel" title="pram.entity.Group.has_rel"><code class="xref py py-meth docutils literal notranslate"><span class="pre">has_rel()</span></code></a> method.</p>
</dd></dl>

<dl class="attribute">
<dt id="pram.entity.Group.is_frozen">
<code class="sig-name descname">is_frozen</code><a class="headerlink" href="#pram.entity.Group.is_frozen" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pram.entity.Group.m">
<code class="sig-name descname">m</code><a class="headerlink" href="#pram.entity.Group.m" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pram.entity.Group.name">
<code class="sig-name descname">name</code><a class="headerlink" href="#pram.entity.Group.name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pram.entity.Group.rel">
<code class="sig-name descname">rel</code><a class="headerlink" href="#pram.entity.Group.rel" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pram.entity.Group.rel_used">
<code class="sig-name descname">rel_used</code><em class="property"> = None</em><a class="headerlink" href="#pram.entity.Group.rel_used" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.entity.Group.set_attr">
<code class="sig-name descname">set_attr</code><span class="sig-paren">(</span><em class="sig-param">name</em>, <em class="sig-param">value</em>, <em class="sig-param">do_force=True</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.entity.Group.set_attr" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets a group’s attribute.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>name</strong> (<em>str</em>) – Attribute’s name.</p></li>
<li><p><strong>value</strong> (<em>Any</em>) – Attribute’s value.</p></li>
<li><p><strong>do_force</strong> (<em>bool</em>) – Flag: Force despite the group being frozen? Currently unused and pending possible removal.</p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><a class="reference internal" href="#pram.entity.GroupFrozenError" title="pram.entity.GroupFrozenError"><strong>GroupFrozenError</strong></a> – </p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>For method call chaining.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>self</p>
</dd>
</dl>
<div class="admonition-todo admonition" id="id6">
<p class="admonition-title">Todo</p>
<p>Remove the <code class="docutils literal notranslate"><span class="pre">do_force</span></code> argument?</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pram.entity.Group.set_attrs">
<code class="sig-name descname">set_attrs</code><span class="sig-paren">(</span><em class="sig-param">attr</em>, <em class="sig-param">do_force=True</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.entity.Group.set_attrs" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets multiple group’s attributes.</p>
<p>This method is not implemented yet.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>attr</strong> (<em>Mapping</em><em>[</em><em>str</em><em>, </em><em>Any</em><em>]</em>) – Attributes.</p></li>
<li><p><strong>do_force</strong> (<em>bool</em>) – Flag: Force despite the group being frozen? Currently unused and pending possible removal.</p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><a class="reference internal" href="#pram.entity.GroupFrozenError" title="pram.entity.GroupFrozenError"><strong>GroupFrozenError</strong></a> – </p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>For method call chaining.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>self</p>
</dd>
</dl>
<div class="admonition-todo admonition" id="id7">
<p class="admonition-title">Todo</p>
<ul class="simple">
<li><p>Implement method.</p></li>
<li><p>Remove the <code class="docutils literal notranslate"><span class="pre">do_force</span></code> argument?</p></li>
</ul>
</div>
</dd></dl>

<dl class="method">
<dt id="pram.entity.Group.set_rel">
<code class="sig-name descname">set_rel</code><span class="sig-paren">(</span><em class="sig-param">name</em>, <em class="sig-param">value</em>, <em class="sig-param">do_force=True</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.entity.Group.set_rel" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets a group’s relation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>name</strong> (<em>str</em>) – Relation’s name.</p></li>
<li><p><strong>value</strong> (<em>Any</em>) – Relation’s value.</p></li>
<li><p><strong>do_force</strong> (<em>bool</em>) – Flag: Force despite the group being frozen? Currently unused and pending possible removal.</p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><a class="reference internal" href="#pram.entity.GroupFrozenError" title="pram.entity.GroupFrozenError"><strong>GroupFrozenError</strong></a> – </p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>For method call chaining.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>self</p>
</dd>
</dl>
<div class="admonition-todo admonition" id="id8">
<p class="admonition-title">Todo</p>
<p>Remove the <code class="docutils literal notranslate"><span class="pre">do_force</span></code> argument?</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pram.entity.Group.set_rels">
<code class="sig-name descname">set_rels</code><span class="sig-paren">(</span><em class="sig-param">rel</em>, <em class="sig-param">do_force=True</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.entity.Group.set_rels" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets multiple group’s relation.</p>
<p>This method is not implemented yet.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>rel</strong> (<em>Mapping</em><em>[</em><em>str</em><em>, </em><a class="reference internal" href="#pram.entity.Site" title="pram.entity.Site"><em>Site</em></a><em>]</em>) – Relations.</p></li>
<li><p><strong>do_force</strong> (<em>bool</em>) – Flag: Force despite the group being frozen? Currently unused and pending possible removal.</p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><a class="reference internal" href="#pram.entity.GroupFrozenError" title="pram.entity.GroupFrozenError"><strong>GroupFrozenError</strong></a> – </p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>For method call chaining.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>self</p>
</dd>
</dl>
<div class="admonition-todo admonition" id="id9">
<p class="admonition-title">Todo</p>
<ul class="simple">
<li><p>Implement method.</p></li>
<li><p>Remove the <code class="docutils literal notranslate"><span class="pre">do_force</span></code> argument?</p></li>
</ul>
</div>
</dd></dl>

<dl class="method">
<dt id="pram.entity.Group.split">
<code class="sig-name descname">split</code><span class="sig-paren">(</span><em class="sig-param">specs</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.entity.Group.split" title="Permalink to this definition">¶</a></dt>
<dd><p>Splits the group into new groups according to the split specs.</p>
<p>The probabilities defining the population mass distribution among the new groups need to add up to 1.
Complementing of the last one of those probabilities is done automatically (i.e., it does not need to be
provided and is in fact outright ignored).</p>
<p>A note on performance.  The biggest performance hit is likley going to be generating a hash which happens as
part of instantiating a new Group object.  While this may seem like a good reason to avoid crearing new groups,
that line of reasoning is deceptive in that a group’s hash is needed regardless.  Other than that, a group
object is light so its impact on performance should be negligeable.  Furthermore, this also grants access to
full functionality of the Group class to any function that uses the result of the present method.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>specs</strong> (<em>Iterable</em><em>[</em><a class="reference internal" href="#pram.entity.GroupSplitSpec" title="pram.entity.GroupSplitSpec"><em>GroupSplitSpec</em></a><em>]</em>) – Group split specs.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pram.entity.Group.unfreeze">
<code class="sig-name descname">unfreeze</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pram.entity.Group.unfreeze" title="Permalink to this definition">¶</a></dt>
<dd><p>Makes the group ammenable to changes via its API.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Unless you’re doing something low level, you do not want to call this method.</p>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pram.entity.GroupDBRelSpec">
<em class="property">class </em><code class="sig-prename descclassname">pram.entity.</code><code class="sig-name descname">GroupDBRelSpec</code><span class="sig-paren">(</span><em class="sig-param">name: str</em>, <em class="sig-param">col: str</em>, <em class="sig-param">sites: dict = None</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.entity.GroupDBRelSpec" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Specification for group relation to be retrieved from a relational database.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>name</strong> (<em>str</em>) – Table name.</p></li>
<li><p><strong>col</strong> (<em>str</em>) – Column name.</p></li>
<li><p><strong>sites</strong> (<em>Mapping</em><em>[</em><em>str</em><em>, </em><a class="reference internal" href="#pram.entity.Site" title="pram.entity.Site"><em>Site</em></a><em>]</em>) – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="exception">
<dt id="pram.entity.GroupFrozenError">
<em class="property">exception </em><code class="sig-prename descclassname">pram.entity.</code><code class="sig-name descname">GroupFrozenError</code><a class="headerlink" href="#pram.entity.GroupFrozenError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">Exception</span></code></p>
<p>Raised when an attempt at modifying a frozen group is made.</p>
<p>Once instantiated, PRAM groups can only be subject to arbitraty modifications when they are not part of a PRAM
simulation.  That is to prevent the user from inadvertantly interfering with the group splitting mechanics of PRAM.
That mechanics dictates that group masses, attributes, and relations (i.e., the very definition of PRAM groups) are
never changed; instead, a group at iteration <em>n</em> is split into multiple groups and all new groups that result from
all group splittings are combined to form new groups at iteration <em>n+1</em>.</p>
</dd></dl>

<dl class="class">
<dt id="pram.entity.GroupQry">
<em class="property">class </em><code class="sig-prename descclassname">pram.entity.</code><code class="sig-name descname">GroupQry</code><span class="sig-paren">(</span><em class="sig-param">attr=NOTHING</em>, <em class="sig-param">rel=NOTHING</em>, <em class="sig-param">cond=NOTHING</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.entity.GroupQry" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>A group query.</p>
<p>Objects of this class are used to select groups from a group population using attribute- and relation-based search
criteria.</p>
<p>Typical usage example for selecting groups of agents that meet certain criteria:</p>
<blockquote>
<div><p>GroupQry(attr={ ‘flu’: ‘s’ })                 # susceptible to the flu
GroupQry(rel={ Site.AT: Site(‘school-83’) })  # currently located at site ‘school-83’</p>
<p>GroupQry(cond=[lambda g: g.attr[‘x’] &gt; 100]))                                # with attribute ‘x’ &gt; 100
GroupQry(cond=[lambda g: g.attr[‘x’] &gt; 100, lambda g: g.attr[‘y’] == 200]))  # with attribute ‘x’ &gt; 100 and ‘y’ == 200
GroupQry(cond=[lambda g: g.attr[‘x’] &gt; 100 and g.attr[‘y’] ==  200]))        # explicit AND condition between attributes
GroupQry(cond=[lambda g: g.attr[‘x’] &gt; 100 or  g.attr[‘y’] == -200]))        # explicit OR  condition between attributes</p>
</div></blockquote>
<p>It would make sense to declare this class frozen (i.e., ‘frozen=True’), but as is revealed by the following two
measurements, performance suffers slightly when slotted classes get frozen.</p>
<p>python -m timeit -s “import attr; C = attr.make_class(‘C’, [‘x’, ‘y’, ‘z’], slots=True)”             “C(1,2,3)”
python -m timeit -s “import attr; C = attr.make_class(‘C’, [‘x’, ‘y’, ‘z’], slots=True,frozen=True)” “C(1,2,3)”</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>attr</strong> (<em>Mapping</em><em>[</em><em>str</em><em>, </em><em>Any</em><em>]</em><em>, </em><em>optional</em>) – Group’s attributes.</p></li>
<li><p><strong>rel</strong> (<em>Mapping</em><em>[</em><em>str</em><em>, </em><em>Any</em><em>]</em><em>, </em><em>optional</em>) – Group’s relations.</p></li>
<li><p><strong>cond</strong> (<em>list</em><em>(</em><em>Callable</em><em>)</em><em>, </em><em>optional</em>) – Conditions on group’s attributes and relations.  These conditions are given as
callables which take one argument, the group.  Assuming the group argument is <code class="docutils literal notranslate"><span class="pre">g</span></code>, the callables can then
access the group’s attributes and relations respectively as <code class="docutils literal notranslate"><span class="pre">g.attr</span></code> and <code class="docutils literal notranslate"><span class="pre">g.rel</span></code>.  See the typical
usage examples above.</p></li>
</ul>
</dd>
</dl>
<dl class="attribute">
<dt id="pram.entity.GroupQry.attr">
<code class="sig-name descname">attr</code><a class="headerlink" href="#pram.entity.GroupQry.attr" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pram.entity.GroupQry.cond">
<code class="sig-name descname">cond</code><a class="headerlink" href="#pram.entity.GroupQry.cond" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pram.entity.GroupQry.rel">
<code class="sig-name descname">rel</code><a class="headerlink" href="#pram.entity.GroupQry.rel" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pram.entity.GroupSplitSpec">
<em class="property">class </em><code class="sig-prename descclassname">pram.entity.</code><code class="sig-name descname">GroupSplitSpec</code><span class="sig-paren">(</span><em class="sig-param">*</em>, <em class="sig-param">p=0.0</em>, <em class="sig-param">attr_set=NOTHING</em>, <em class="sig-param">attr_del=NOTHING</em>, <em class="sig-param">rel_set=NOTHING</em>, <em class="sig-param">rel_del=NOTHING</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.entity.GroupSplitSpec" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>A single group-split specification.</p>
<p>These specifications are oridinarily provided in a list to indicate new groups that one other group is being split
into at the end of a rule’s application.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>p</strong> (<em>float</em>) – The probability of the agents mass being trasnferred to the new group.</p></li>
<li><p><strong>attr_set</strong> (<em>Mapping</em><em>[</em><em>str</em><em>, </em><em>Any</em><em>]</em>) – Attributes to be set in the new group.</p></li>
<li><p><strong>attr_del</strong> (<em>Iterable</em><em>(</em><em>str</em><em>)</em>) – Attributes to be removed from the new group (with respect to the current group).</p></li>
<li><p><strong>rel_set</strong> (<em>Mapping</em><em>[</em><em>str</em><em>, </em><em>Any</em><em>]</em>) – Relations to be set in the new group.</p></li>
<li><p><strong>rel_del</strong> (<em>Iterable</em><em>(</em><em>str</em><em>)</em>) – Relations to be removed from the new group (with respect to the current group).</p></li>
</ul>
</dd>
</dl>
<div class="admonition-todo admonition" id="id10">
<p class="admonition-title">Todo</p>
<p>At this point, attributes and relations to be removed are assumed to be identified by their names only and not
not their values (i.e., we use a set to hold the keys that should be removed from the dictionaries for
attributes and relations).  Perhaps this is not the way to go and we should instead be using both names and
values.</p>
</div>
<dl class="attribute">
<dt id="pram.entity.GroupSplitSpec.attr_del">
<code class="sig-name descname">attr_del</code><a class="headerlink" href="#pram.entity.GroupSplitSpec.attr_del" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pram.entity.GroupSplitSpec.attr_set">
<code class="sig-name descname">attr_set</code><a class="headerlink" href="#pram.entity.GroupSplitSpec.attr_set" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.entity.GroupSplitSpec.is_prob">
<code class="sig-name descname">is_prob</code><span class="sig-paren">(</span><em class="sig-param">attribute</em>, <em class="sig-param">value</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.entity.GroupSplitSpec.is_prob" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pram.entity.GroupSplitSpec.p">
<code class="sig-name descname">p</code><a class="headerlink" href="#pram.entity.GroupSplitSpec.p" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pram.entity.GroupSplitSpec.rel_del">
<code class="sig-name descname">rel_del</code><a class="headerlink" href="#pram.entity.GroupSplitSpec.rel_del" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pram.entity.GroupSplitSpec.rel_set">
<code class="sig-name descname">rel_set</code><a class="headerlink" href="#pram.entity.GroupSplitSpec.rel_set" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pram.entity.Resource">
<em class="property">class </em><code class="sig-prename descclassname">pram.entity.</code><code class="sig-name descname">Resource</code><span class="sig-paren">(</span><em class="sig-param">name</em>, <em class="sig-param">capacity_max=1</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.entity.Resource" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pram.entity.Entity" title="pram.entity.Entity"><code class="xref py py-class docutils literal notranslate"><span class="pre">pram.entity.Entity</span></code></a></p>
<p>A resource entity.</p>
<p>A resource is shared by multiple agents (e.g., a public bus).</p>
<p>This is a basic implementation of a shared resource and can safely be used only within a single simulation.  A more
elaborate implementation based on synchronization mechanisms will be provided later and will accommodate multiple
concurrent simulations of different and interacting systems with the agent population moving seamlessly between
them.</p>
<p>The terminology used in the API of this class is consistent with that of concurent computing.  For example, a
resource is said to <em>accommodate</em> agents and is <em>released</em> after an agent (or agents) are done using it.  A
resource’s capacity dicates how many agents can be accommodated at the same time.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>name</strong> (<em>str</em>) – A resource’s name.</p></li>
<li><p><strong>capacity_max</strong> (<em>int</em>) – The maximum number of agents that can be using the resouce concurrently.</p></li>
</ul>
</dd>
</dl>
<dl class="method">
<dt id="pram.entity.Resource.__eq__">
<code class="sig-name descname">__eq__</code><span class="sig-paren">(</span><em class="sig-param">other</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.entity.Resource.__eq__" title="Permalink to this definition">¶</a></dt>
<dd><p>We will make two resources identical if their keys are equal (i.e., object identity is not necessary).  This
will let us recognize resources even if they are instantiated multiple times.</p>
</dd></dl>

<dl class="method">
<dt id="pram.entity.Resource.allocate">
<code class="sig-name descname">allocate</code><span class="sig-paren">(</span><em class="sig-param">n</em>, <em class="sig-param">do_all=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.entity.Resource.allocate" title="Permalink to this definition">¶</a></dt>
<dd><p>Allocate the resource to <code class="docutils literal notranslate"><span class="pre">n</span></code> agents.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n</strong> (<em>int</em>) – The number of agents.</p></li>
<li><p><strong>do_all</strong> (<em>bool</em>) – Flag: Accomodate all-or-nothing or any that the resourcs can accomodate.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Number of not accomodated agents (i.e., those over the resource’s max capacity).</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pram.entity.Resource.allocate_all">
<code class="sig-name descname">allocate_all</code><span class="sig-paren">(</span><em class="sig-param">n</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.entity.Resource.allocate_all" title="Permalink to this definition">¶</a></dt>
<dd><p>Attempts to allocate all <code class="docutils literal notranslate"><span class="pre">n</span></code> agents.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>n</strong> (<em>int</em>) – The number of agents.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>True if all agents can be accommodated and False otherwise.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pram.entity.Resource.allocate_any">
<code class="sig-name descname">allocate_any</code><span class="sig-paren">(</span><em class="sig-param">n</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.entity.Resource.allocate_any" title="Permalink to this definition">¶</a></dt>
<dd><p>Allocates as many out of <code class="docutils literal notranslate"><span class="pre">n</span></code> agents as possible.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>n</strong> (<em>int</em>) – The number of agents.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Number of not accommodated agents (i.e., those over the resource’s max capacity).</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pram.entity.Resource.can_accommodate_all">
<code class="sig-name descname">can_accommodate_all</code><span class="sig-paren">(</span><em class="sig-param">n</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.entity.Resource.can_accommodate_all" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks if all <code class="docutils literal notranslate"><span class="pre">n</span></code> agents be accomodated.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>n</strong> (<em>int</em>) – The number of agents.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>True if all <code class="docutils literal notranslate"><span class="pre">n</span></code> agents can be accomodated and False otherwise.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pram.entity.Resource.can_accommodate_any">
<code class="sig-name descname">can_accommodate_any</code><span class="sig-paren">(</span><em class="sig-param">n</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.entity.Resource.can_accommodate_any" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks if at least one agent can be accomodated.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>n</strong> (<em>int</em>) – The number of agents.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>True if at least one agent can be accomodated and False otherwise.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pram.entity.Resource.can_accommodate_one">
<code class="sig-name descname">can_accommodate_one</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pram.entity.Resource.can_accommodate_one" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks if at least one agent can be accomodated.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>True if at least one agent can be accomodated and False otherwise.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="pram.entity.Resource.capacity">
<code class="sig-name descname">capacity</code><a class="headerlink" href="#pram.entity.Resource.capacity" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pram.entity.Resource.capacity_max">
<code class="sig-name descname">capacity_max</code><a class="headerlink" href="#pram.entity.Resource.capacity_max" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.entity.Resource.get_capacity">
<code class="sig-name descname">get_capacity</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pram.entity.Resource.get_capacity" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.entity.Resource.get_capacity_left">
<code class="sig-name descname">get_capacity_left</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pram.entity.Resource.get_capacity_left" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.entity.Resource.get_capacity_max">
<code class="sig-name descname">get_capacity_max</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pram.entity.Resource.get_capacity_max" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.entity.Resource.get_hash">
<code class="sig-name descname">get_hash</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pram.entity.Resource.get_hash" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pram.entity.Resource.name">
<code class="sig-name descname">name</code><a class="headerlink" href="#pram.entity.Resource.name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.entity.Resource.release">
<code class="sig-name descname">release</code><span class="sig-paren">(</span><em class="sig-param">n</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.entity.Resource.release" title="Permalink to this definition">¶</a></dt>
<dd><p>Releases <code class="docutils literal notranslate"><span class="pre">n</span></code> agent spots.</p>
<p>Because releasing is always allowed, no return value needs to be checked.  Naturally, a resource cannot release
more spots than it’s max capacity.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>n</strong> (<em>int</em>) – The number of agents.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pram.entity.Site">
<em class="property">class </em><code class="sig-prename descclassname">pram.entity.</code><code class="sig-name descname">Site</code><span class="sig-paren">(</span><em class="sig-param">name</em>, <em class="sig-param">attr=None</em>, <em class="sig-param">rel_name='&#64;'</em>, <em class="sig-param">pop=None</em>, <em class="sig-param">capacity_max=1</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.entity.Site" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pram.entity.Resource" title="pram.entity.Resource"><code class="xref py py-class docutils literal notranslate"><span class="pre">pram.entity.Resource</span></code></a></p>
<p>A physical site (e.g., a school or a store) agents can reside at.</p>
<p>A site has a sensible interface which makes it useful.  For example, it makes sense to ask about the size and
composition of population (e.g., groups) that are at that location.  However, because this information (and other,
similar pieces of information) may be desired at arbitrary times, it makes most sense to compute it lazily and
memoize it.  For that reason, a site stores a link to the population it is associated with; it queries that
population to compute quantities of interested when they are needed.  An added benefit of this design is fostering
proper composition; that is, updating the state of a site should be done by a site, not the population.</p>
<p>A Site is a Resource which means a Site may choose to utilize the capacity property with all its related methods.
A good example of when this would be useful is a hospital with a limited patient capacity that may be reached
during an epidemic outbreak.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>name</strong> (<em>str</em>) – Name of the site.</p></li>
<li><p><strong>attr</strong> (<em>Mapping</em><em>[</em><em>]</em><em>, </em><em>optinoal</em>) – Attributes describing the site.</p></li>
<li><p><strong>rel_name</strong> (<em>str</em>) – The name of the relation that should be used when associating a group of agents with this site.</p></li>
<li><p><strong>pop</strong> (<a class="reference internal" href="#pram.pop.GroupPopulation" title="pram.pop.GroupPopulation"><em>GroupPopulation</em></a><em>, </em><em>optional</em>) – The GroupPopulation object.</p></li>
<li><p><strong>capacity_max</strong> (<em>int</em>) – The maximum capacity of the Site when considered a Resource.</p></li>
</ul>
</dd>
</dl>
<dl class="attribute">
<dt id="pram.entity.Site.AT">
<code class="sig-name descname">AT</code><em class="property"> = '&#64;'</em><a class="headerlink" href="#pram.entity.Site.AT" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.entity.Site.__eq__">
<code class="sig-name descname">__eq__</code><span class="sig-paren">(</span><em class="sig-param">other</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.entity.Site.__eq__" title="Permalink to this definition">¶</a></dt>
<dd><p>We will make two sites identical if their keys are equal (i.e., object identity is not necessary).  This will
let us recognize sites even if they are instantiated multiple times.</p>
</dd></dl>

<dl class="attribute">
<dt id="pram.entity.Site.attr">
<code class="sig-name descname">attr</code><a class="headerlink" href="#pram.entity.Site.attr" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.entity.Site.freeze">
<code class="sig-name descname">freeze</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pram.entity.Site.freeze" title="Permalink to this definition">¶</a></dt>
<dd><p>Freezes the site thus disallowing any direct changes to it.</p>
</dd></dl>

<dl class="method">
<dt id="pram.entity.Site.gen_from_db">
<em class="property">classmethod </em><code class="sig-name descname">gen_from_db</code><span class="sig-paren">(</span><em class="sig-param">db_fpath</em>, <em class="sig-param">tbl</em>, <em class="sig-param">name_col</em>, <em class="sig-param">rel_name='&#64;'</em>, <em class="sig-param">attr=[]</em>, <em class="sig-param">limit=0</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.entity.Site.gen_from_db" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates sites from a relational database.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>db_fpath</strong> (<em>str</em>) – Path to the database file (SQLite3).</p></li>
<li><p><strong>tbl</strong> (<em>str</em>) – Table name.</p></li>
<li><p><strong>name_col</strong> (<em>str</em>) – Table column storing names of sites.</p></li>
<li><p><strong>rel_name</strong> (<em>str</em>) – Name of the relation to be associated with each of the sites generated.  For example, if
hospital sites are being generated, the <code class="docutils literal notranslate"><span class="pre">rel_name</span></code> could be set to <code class="docutils literal notranslate"><span class="pre">hospital</span></code>.</p></li>
<li><p><strong>attr</strong> (<em>Iterable</em><em>[</em><em>str</em><em>]</em>) – Names of table columns storing attributes to be internalized by the site objects
being generated.</p></li>
<li><p><strong>limit</strong> (<em>int</em>) – The maximum number of sites to be generated.  Ordinarily, this is not changed from its default
value of zero.  It is however useful for testing, especially with very large databases.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A dictonary of sites with the Site object’s hash as keys.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>dict(str, <a class="reference internal" href="#pram.entity.Site" title="pram.entity.Site">Site</a>)</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pram.entity.Site.gen_from_db_tmp1">
<em class="property">classmethod </em><code class="sig-name descname">gen_from_db_tmp1</code><span class="sig-paren">(</span><em class="sig-param">sim</em>, <em class="sig-param">db_fpath</em>, <em class="sig-param">tbl</em>, <em class="sig-param">name_col</em>, <em class="sig-param">rel_name='&#64;'</em>, <em class="sig-param">attr=[]</em>, <em class="sig-param">limit=0</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.entity.Site.gen_from_db_tmp1" title="Permalink to this definition">¶</a></dt>
<dd><p>A legacy method pending non-immediate removal.</p>
<p>Goes together with Group.gen_from_db_tmp1().  See the comment <code class="xref py py-meth docutils literal notranslate"><span class="pre">therein</span> <span class="pre">pram.entity.Group.gen_from_db_tmp1()</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="pram.entity.Site.get_groups_here">
<code class="sig-name descname">get_groups_here</code><span class="sig-paren">(</span><em class="sig-param">qry=None</em>, <em class="sig-param">non_empty_only=True</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.entity.Site.get_groups_here" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns groups which currently are at this site.</p>
<p>The word “currently” is key here because as a PRAM simulation evolved, agents move between groups and different
compositions of groups will in general reside at any given site.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>qry</strong> (<a class="reference internal" href="#pram.entity.GroupQry" title="pram.entity.GroupQry"><em>GroupQry</em></a><em>, </em><em>optional</em>) – Further restrictions imposed on attributes and relations of groups currently at
this site.  For example, the user may be interested in retrieving only groups of agents infected with
the flu (which is a restriction on the group’s attribute) or only groups of agents who attend a
specific school (which is a restriction on the group’s relation).</p></li>
<li><p><strong>non_empty_only</strong> (<em>bool</em>) – Flag: Return only groups with non-zero agent population mass?</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>List of groups currently at this site.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>list[<a class="reference internal" href="#pram.entity.Group" title="pram.entity.Group">Group</a>]</p>
</dd>
</dl>
<div class="admonition-todo admonition" id="id11">
<p class="admonition-title">Todo</p>
<p>Implement memoization (probably of only all the groups, i.e., without accounting for the <code class="docutils literal notranslate"><span class="pre">qry</span></code>).</p>
</div>
</dd></dl>

<dl class="method">
<dt id="pram.entity.Site.get_hash">
<code class="sig-name descname">get_hash</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pram.entity.Site.get_hash" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.entity.Site.get_pop_size">
<code class="sig-name descname">get_pop_size</code><span class="sig-paren">(</span><em class="sig-param">qry=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.entity.Site.get_pop_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the total size of the agent population mass currently at this side.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>qry</strong> (<a class="reference internal" href="#pram.entity.GroupQry" title="pram.entity.GroupQry"><em>GroupQry</em></a><em>, </em><em>optional</em>) – Further restrictions imposed on attributes and relations of groups currently at
this site.  For example, the user may be interested in retrieving only groups of agents infected with
the flu (which is a restriction on the group’s attribute) or only groups of agents who attend a
specific school (which is a restriction on the group’s relation).</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The population size.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
<div class="admonition-todo admonition" id="id12">
<p class="admonition-title">Todo</p>
<p>Rename to <code class="docutils literal notranslate"><span class="pre">get_pop_mass()</span></code>?</p>
</div>
</dd></dl>

<dl class="attribute">
<dt id="pram.entity.Site.groups">
<code class="sig-name descname">groups</code><a class="headerlink" href="#pram.entity.Site.groups" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pram.entity.Site.pop">
<code class="sig-name descname">pop</code><a class="headerlink" href="#pram.entity.Site.pop" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pram.entity.Site.rel_name">
<code class="sig-name descname">rel_name</code><a class="headerlink" href="#pram.entity.Site.rel_name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.entity.Site.set_pop">
<code class="sig-name descname">set_pop</code><span class="sig-paren">(</span><em class="sig-param">pop</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.entity.Site.set_pop" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the group population.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>pop</strong> (<a class="reference internal" href="#pram.pop.GroupPopulation" title="pram.pop.GroupPopulation"><em>GroupPopulation</em></a>) – The group population.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pram.entity.SiteJSONEncoder">
<em class="property">class </em><code class="sig-prename descclassname">pram.entity.</code><code class="sig-name descname">SiteJSONEncoder</code><span class="sig-paren">(</span><em class="sig-param">*</em>, <em class="sig-param">skipkeys=False</em>, <em class="sig-param">ensure_ascii=True</em>, <em class="sig-param">check_circular=True</em>, <em class="sig-param">allow_nan=True</em>, <em class="sig-param">sort_keys=False</em>, <em class="sig-param">indent=None</em>, <em class="sig-param">separators=None</em>, <em class="sig-param">default=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.entity.SiteJSONEncoder" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">json.encoder.JSONEncoder</span></code></p>
<p>JSON encoder used by the <a class="reference internal" href="#pram.entity.Group.gen_hash" title="pram.entity.Group.gen_hash"><code class="xref py py-meth docutils literal notranslate"><span class="pre">gen_hash()</span></code></a> method.</p>
<p>JSON encoding is used when hashing <code class="xref py py-class docutils literal notranslate"><span class="pre">Group</span></code> objects.  Because those objects may hold references
to <code class="xref py py-class docutils literal notranslate"><span class="pre">Site</span></code> and <code class="xref py py-class docutils literal notranslate"><span class="pre">Resource</span></code> objects, we must accomodate for them here.</p>
<dl class="method">
<dt id="pram.entity.SiteJSONEncoder.default">
<code class="sig-name descname">default</code><span class="sig-paren">(</span><em class="sig-param">o</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.entity.SiteJSONEncoder.default" title="Permalink to this definition">¶</a></dt>
<dd><p>The method to be implemented when extending json.JSONEncoder.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>o</strong> (<em>object</em>) – The object to be encoded.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The JSON-encoded representation of the object.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pram.event">
<span id="pram-event-module"></span><h2>pram.event module<a class="headerlink" href="#module-pram.event" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="pram.event.GroupMassTrigger">
<em class="property">class </em><code class="sig-prename descclassname">pram.event.</code><code class="sig-name descname">GroupMassTrigger</code><span class="sig-paren">(</span><em class="sig-param">group</em>, <em class="sig-param">fn_cond</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.event.GroupMassTrigger" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pram.event.Trigger" title="pram.event.Trigger"><code class="xref py py-class docutils literal notranslate"><span class="pre">pram.event.Trigger</span></code></a></p>
<p>fn_cond: a function expecting a single argument which is a group’s mass</p>
</dd></dl>

<dl class="class">
<dt id="pram.event.Trigger">
<em class="property">class </em><code class="sig-prename descclassname">pram.event.</code><code class="sig-name descname">Trigger</code><span class="sig-paren">(</span><em class="sig-param">obj</em>, <em class="sig-param">fn_cond</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.event.Trigger" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">abc.ABC</span></code></p>
<p>Useful for implementing first-hitting-time models.</p>
<p>obj     : the object the state of which may fire the trigger
fn_cond : a function expecting a single argument, that object</p>
<dl class="method">
<dt id="pram.event.Trigger.eval">
<code class="sig-name descname">eval</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pram.event.Trigger.eval" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.event.Trigger.has_fired">
<code class="sig-name descname">has_fired</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pram.event.Trigger.has_fired" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.event.Trigger.reset">
<code class="sig-name descname">reset</code><span class="sig-paren">(</span><em class="sig-param">fn_cond</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.event.Trigger.reset" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.event.Trigger.set">
<code class="sig-name descname">set</code><span class="sig-paren">(</span><em class="sig-param">obj=None</em>, <em class="sig-param">fn_cond=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.event.Trigger.set" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pram.graph">
<span id="pram-graph-module"></span><h2>pram.graph module<a class="headerlink" href="#module-pram.graph" title="Permalink to this headline">¶</a></h2>
<p>Contains graph related code.</p>
<dl class="class">
<dt id="pram.graph.MassGraph">
<em class="property">class </em><code class="sig-prename descclassname">pram.graph.</code><code class="sig-name descname">MassGraph</code><a class="headerlink" href="#pram.graph.MassGraph" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>A graph of locus and flow of mass.</p>
<p>This class holds the entire time-evolution of the group space and the associated mass flow.</p>
<p>This class uses graph-tool library.  I’ve also considered using the Python-native NetworkX, but graph-tool is
faster, more featurefull, and performance-transparent (i.e., all operations are annotated with the big O notation).
The only problem with graph-tool is that it is more difficult to install, which is going to be signifiant for
users, especially the casual ones who just want to get feel for the software.  This makes a conteinerized version
desirable.</p>
<dl class="method">
<dt id="pram.graph.MassGraph.add_group">
<code class="sig-name descname">add_group</code><span class="sig-paren">(</span><em class="sig-param">iter</em>, <em class="sig-param">hash</em>, <em class="sig-param">m</em>, <em class="sig-param">m_p</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.graph.MassGraph.add_group" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.graph.MassGraph.add_mass_flow">
<code class="sig-name descname">add_mass_flow</code><span class="sig-paren">(</span><em class="sig-param">iter</em>, <em class="sig-param">src_hash</em>, <em class="sig-param">dst_hash</em>, <em class="sig-param">m</em>, <em class="sig-param">m_p</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.graph.MassGraph.add_mass_flow" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.graph.MassGraph.plot_mass_flow_time_series">
<code class="sig-name descname">plot_mass_flow_time_series</code><span class="sig-paren">(</span><em class="sig-param">scale=(1.0</em>, <em class="sig-param">1.0)</em>, <em class="sig-param">filepath=None</em>, <em class="sig-param">iter_range=(-1</em>, <em class="sig-param">-1)</em>, <em class="sig-param">v_prop=False</em>, <em class="sig-param">e_prop=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.graph.MassGraph.plot_mass_flow_time_series" title="Permalink to this definition">¶</a></dt>
<dd><p>Because this method plots a time series which can be of arbitrary length, there is no figure size argument.
Instead, scale factor for the width and height of the figure is expected and defaults to no scaling.  The
method decided on the figure size automatically, based on the iteration range given and the maximum number of
groups in any iteration from that range.</p>
</dd></dl>

<dl class="method">
<dt id="pram.graph.MassGraph.set_group_names">
<code class="sig-name descname">set_group_names</code><span class="sig-paren">(</span><em class="sig-param">names</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.graph.MassGraph.set_group_names" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.graph.MassGraph.set_pos">
<code class="sig-name descname">set_pos</code><span class="sig-paren">(</span><em class="sig-param">iter_range</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.graph.MassGraph.set_pos" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the position of every vertex.  That position is used for plotting the graph.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pram.pop">
<span id="pram-pop-module"></span><h2>pram.pop module<a class="headerlink" href="#module-pram.pop" title="Permalink to this headline">¶</a></h2>
<p>Contains PRAM group and agent populations code.</p>
<dl class="class">
<dt id="pram.pop.AgentPopulation">
<em class="property">class </em><code class="sig-prename descclassname">pram.pop.</code><code class="sig-name descname">AgentPopulation</code><a class="headerlink" href="#pram.pop.AgentPopulation" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Population of individual agents.</p>
<p>While PRAM extends agent-based models and therefore it seems logical to invoke the concept of agent population (i.e.,
a population of individual agents, not groups thereof), that isn’t how PRAM works.  Consequently, this class is a
stub at this point but may rise to prominence at some later point.</p>
<dl class="method">
<dt id="pram.pop.AgentPopulation.gen_group_pop">
<code class="sig-name descname">gen_group_pop</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pram.pop.AgentPopulation.gen_group_pop" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates a population of groups based on the current agents population.</p>
<p>This method provides a general interface between popular agent-based modeling packages (e.g., NetLogo) and
PyPRAM.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pram.pop.GroupPopulation">
<em class="property">class </em><code class="sig-prename descclassname">pram.pop.</code><code class="sig-name descname">GroupPopulation</code><span class="sig-paren">(</span><em class="sig-param">sim</em>, <em class="sig-param">do_keep_mass_flow_specs=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.pop.GroupPopulation" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Population of groups of agents.</p>
<p>PRAM models functionally equivalent agents jointly as groups.  The formalism does not invoke any “hard” notion of a
group population.  However, the PyPRAM package does use that concept to elegantly compartmentalize groups along
with operations on them.</p>
<p>Because groups can be associated with sites via group relations, those sites are also stored inside of this
class’ instance.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sim</strong> (<a class="reference internal" href="#pram.sim.Simulation" title="pram.sim.Simulation"><em>Simulation</em></a>) – The simulation.</p></li>
<li><p><strong>do_keep_mass_flow_specs</strong> (<em>bool</em>) – Flag: Store the last iteration mass flow specs?  This is False by default for
memory usage sake.  If set to True, <code class="docutils literal notranslate"><span class="pre">self.last_iter.mass_flow_specs</span></code> will hold the specs until they are
overwriten at the next iteration of the simulation.</p></li>
</ul>
</dd>
</dl>
<dl class="method">
<dt id="pram.pop.GroupPopulation.add_group">
<code class="sig-name descname">add_group</code><span class="sig-paren">(</span><em class="sig-param">group</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.pop.GroupPopulation.add_group" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds a group to the population.</p>
<p>If the groups doesn’t exist in the population, it will be added.  Otherwise, the group’s size will be added to
the already existing group’s size.  This behavior ensures the group population only contains exactly one
instance of a group.  As a reminder, groups are identical if their attributes and relations are equal.</p>
<p>This method also adds all Site objects from the group’s relations so there is no need for the user to do this
manually.</p>
<p>All groups added to the population become frozen to prevent the user from changing their attribute and
relations via their API; modifying groups via group splitting mechamism is the only proper way.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>group</strong> (<a class="reference internal" href="#pram.entity.Group" title="pram.entity.Group"><em>Group</em></a>) – The group being added.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>For method call chaining.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>self</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pram.pop.GroupPopulation.add_groups">
<code class="sig-name descname">add_groups</code><span class="sig-paren">(</span><em class="sig-param">groups</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.pop.GroupPopulation.add_groups" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds multiple groups to the population.</p>
<p>See <a class="reference internal" href="#pram.pop.GroupPopulation.add_group" title="pram.pop.GroupPopulation.add_group"><code class="xref py py-meth docutils literal notranslate"><span class="pre">add_group()</span></code></a> method for details.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>groups</strong> (<em>Iterable</em><em>[</em><a class="reference internal" href="#pram.entity.Group" title="pram.entity.Group"><em>Group</em></a><em>]</em>) – Groups to be added.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>For method call chaining.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>self</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pram.pop.GroupPopulation.add_resource">
<code class="sig-name descname">add_resource</code><span class="sig-paren">(</span><em class="sig-param">resource</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.pop.GroupPopulation.add_resource" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds a resource to the population.</p>
<p>Only adds if the resource doesn’t exist yet.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>resource</strong> (<a class="reference internal" href="#pram.entity.Resource" title="pram.entity.Resource"><em>Resource</em></a>) – The resource to be added.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>For method call chaining.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>self</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pram.pop.GroupPopulation.add_resources">
<code class="sig-name descname">add_resources</code><span class="sig-paren">(</span><em class="sig-param">resources</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.pop.GroupPopulation.add_resources" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds multiple resources to the population.</p>
<p>See <a class="reference internal" href="#pram.pop.GroupPopulation.add_resource" title="pram.pop.GroupPopulation.add_resource"><code class="xref py py-meth docutils literal notranslate"><span class="pre">add_resource()</span></code></a> method for details.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>resource</strong> (<a class="reference internal" href="#pram.entity.Resource" title="pram.entity.Resource"><em>Resource</em></a>) – The resource to be added.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>For method call chaining.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>self</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pram.pop.GroupPopulation.add_site">
<code class="sig-name descname">add_site</code><span class="sig-paren">(</span><em class="sig-param">site</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.pop.GroupPopulation.add_site" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds a site to the population.</p>
<p>Only adds if the site doesn’t exist yet.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>site</strong> (<a class="reference internal" href="#pram.entity.Site" title="pram.entity.Site"><em>Site</em></a>) – The site to be added.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>For method call chaining.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>self</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pram.pop.GroupPopulation.add_sites">
<code class="sig-name descname">add_sites</code><span class="sig-paren">(</span><em class="sig-param">sites</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.pop.GroupPopulation.add_sites" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds multiple sites to the population.</p>
<p>See <a class="reference internal" href="#pram.pop.GroupPopulation.add_site" title="pram.pop.GroupPopulation.add_site"><code class="xref py py-meth docutils literal notranslate"><span class="pre">add_site()</span></code></a> method for details.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>sites</strong> (<a class="reference internal" href="#pram.entity.Site" title="pram.entity.Site"><em>Site</em></a>) – The sites to be added.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>For method call chaining.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>self</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pram.pop.GroupPopulation.apply_rules">
<code class="sig-name descname">apply_rules</code><span class="sig-paren">(</span><em class="sig-param">rules</em>, <em class="sig-param">iter</em>, <em class="sig-param">t</em>, <em class="sig-param">is_rule_setup=False</em>, <em class="sig-param">is_rule_cleanup=False</em>, <em class="sig-param">is_sim_setup=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.pop.GroupPopulation.apply_rules" title="Permalink to this definition">¶</a></dt>
<dd><p>Applies all rules in the simulation to all groups in the population.</p>
<p>This method iterates through groups and for each applies all rules (that step is handled by the Group class
itself in the <a class="reference internal" href="#pram.entity.Group.apply_rules" title="pram.entity.Group.apply_rules"><code class="xref py py-meth docutils literal notranslate"><span class="pre">apply_rules()</span></code></a> method).  The result of those rules applications is a list
of new groups the original group should be split into.  When all the groups have been processed in this way,
and consequently all resulting groups have been defined, those resulting groups are used for mass transfer
(which updates existing groups and creates new ones).  Note that “resulting” is different from “new” because a
group might have been split into resulting groups of which one or more already exists in the group population.
In other words, not all resulting groups (local scope) need to be new (global scope).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>rules</strong> (<em>Iterable</em><em>[</em><a class="reference internal" href="#pram.rule.Rule" title="pram.rule.Rule"><em>Rule</em></a><em>]</em>) – The rules.</p></li>
<li><p><strong>iter</strong> (<em>int</em>) – Simulation interation.</p></li>
<li><p><strong>t</strong> (<em>int</em>) – Simulation time.</p></li>
<li><p><strong>is_rule_setup</strong> (<em>bool</em>) – Flag: Is this invocation of this method during rule setup stage of the simulation?</p></li>
<li><p><strong>is_rule_cleanup</strong> (<em>bool</em>) – Flag: Is this invocation of this method during rule cleanup stage of the
simulation?</p></li>
<li><p><strong>is_sim_setup</strong> (<em>bool</em>) – Flag: Is this invocation of this method during simulation setup stage?</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>For method call chaining.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>self</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pram.pop.GroupPopulation.compact">
<code class="sig-name descname">compact</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pram.pop.GroupPopulation.compact" title="Permalink to this definition">¶</a></dt>
<dd><p>Compacts the population by removing empty groups.</p>
<p>Whether this is what the user needs is up to them.  However, for large simulations with a high new group
turnover compacting the group population will make the simulation run faster.  Autocompacting can be turned on
on the simulation level via the <a class="reference internal" href="#pram.sim.Simulation.set_pragma_autocompact" title="pram.sim.Simulation.set_pragma_autocompact"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_pragma_autocompact()</span></code></a> method.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>For method call chaining.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>self</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pram.pop.GroupPopulation.freeze">
<code class="sig-name descname">freeze</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pram.pop.GroupPopulation.freeze" title="Permalink to this definition">¶</a></dt>
<dd><p>Freeze the population.</p>
<p>The <a class="reference internal" href="#pram.sim.Simulation" title="pram.sim.Simulation"><code class="xref py py-class docutils literal notranslate"><span class="pre">Simulation</span></code></a> object freezes the population on first run.  Freezing a population is used
only used to determine the total population size.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>For method call chaining.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>self</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pram.pop.GroupPopulation.gen_agent_pop">
<code class="sig-name descname">gen_agent_pop</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pram.pop.GroupPopulation.gen_agent_pop" title="Permalink to this definition">¶</a></dt>
<dd><p>Args:</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>For method call chaining.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>self</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pram.pop.GroupPopulation.get_group">
<code class="sig-name descname">get_group</code><span class="sig-paren">(</span><em class="sig-param">qry=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.pop.GroupPopulation.get_group" title="Permalink to this definition">¶</a></dt>
<dd><p>Args:</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>For method call chaining.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>self</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pram.pop.GroupPopulation.get_group_cnt">
<code class="sig-name descname">get_group_cnt</code><span class="sig-paren">(</span><em class="sig-param">only_non_empty=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.pop.GroupPopulation.get_group_cnt" title="Permalink to this definition">¶</a></dt>
<dd><p>Args:</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>For method call chaining.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>self</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pram.pop.GroupPopulation.get_groups">
<code class="sig-name descname">get_groups</code><span class="sig-paren">(</span><em class="sig-param">qry=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.pop.GroupPopulation.get_groups" title="Permalink to this definition">¶</a></dt>
<dd><p>Args:</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>For method call chaining.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>self</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pram.pop.GroupPopulation.get_mass">
<code class="sig-name descname">get_mass</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pram.pop.GroupPopulation.get_mass" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.pop.GroupPopulation.get_next_group_name">
<code class="sig-name descname">get_next_group_name</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pram.pop.GroupPopulation.get_next_group_name" title="Permalink to this definition">¶</a></dt>
<dd><p>Args:</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>For method call chaining.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>self</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pram.pop.GroupPopulation.get_site_cnt">
<code class="sig-name descname">get_site_cnt</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pram.pop.GroupPopulation.get_site_cnt" title="Permalink to this definition">¶</a></dt>
<dd><p>Args:</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>For method call chaining.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>self</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pram.pop.GroupPopulation.transfer_mass">
<code class="sig-name descname">transfer_mass</code><span class="sig-paren">(</span><em class="sig-param">src_group_hashes</em>, <em class="sig-param">mass_flow_specs</em>, <em class="sig-param">iter</em>, <em class="sig-param">t</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.pop.GroupPopulation.transfer_mass" title="Permalink to this definition">¶</a></dt>
<dd><p>Args:</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>For method call chaining.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>self</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pram.pop.MassFlowSpec">
<em class="property">class </em><code class="sig-prename descclassname">pram.pop.</code><code class="sig-name descname">MassFlowSpec</code><span class="sig-paren">(</span><em class="sig-param">m_pop</em>, <em class="sig-param">src: pram.entity.Group</em>, <em class="sig-param">dst: list = NOTHING</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.pop.MassFlowSpec" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>A specification of agent population mass flow.</p>
<p>A list of objects of this class for one simulation iteration encodes the full picture of agent population mass flow
in the model.  This class encodes mass flow from one source group to one or more destination groups.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>m_pop</strong> (<em>float</em>) – Total population mass at the time of mass flow.</p></li>
<li><p><strong>src</strong> (<a class="reference internal" href="#pram.entity.Group" title="pram.entity.Group"><em>Group</em></a>) – The source group (i.e., the mass donor).</p></li>
<li><p><strong>dst</strong> (<em>Iterable</em><em>[</em><a class="reference internal" href="#pram.entity.Group" title="pram.entity.Group"><em>Group</em></a><em>]</em>) – Destination groups (i.e., mass acceptors).</p></li>
</ul>
</dd>
</dl>
<dl class="attribute">
<dt id="pram.pop.MassFlowSpec.dst">
<code class="sig-name descname">dst</code><a class="headerlink" href="#pram.pop.MassFlowSpec.dst" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pram.pop.MassFlowSpec.m_pop">
<code class="sig-name descname">m_pop</code><a class="headerlink" href="#pram.pop.MassFlowSpec.m_pop" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pram.pop.MassFlowSpec.src">
<code class="sig-name descname">src</code><a class="headerlink" href="#pram.pop.MassFlowSpec.src" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pram.pop.Population">
<em class="property">class </em><code class="sig-prename descclassname">pram.pop.</code><code class="sig-name descname">Population</code><a class="headerlink" href="#pram.pop.Population" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>A population of both groups and agents.</p>
<p>This class is outward looking and as much is not currently implemented.</p>
</dd></dl>

</div>
<div class="section" id="module-pram.rule">
<span id="pram-rule-module"></span><h2>pram.rule module<a class="headerlink" href="#module-pram.rule" title="Permalink to this headline">¶</a></h2>
<dl class="simple">
<dt>Nomenclature disambiguation</dt><dd><dl class="simple">
<dt>Markov Process, Markov Chain</dt><dd><p><a class="reference external" href="https://math.stackexchange.com/questions/2071285/markov-process-markov-chain">https://math.stackexchange.com/questions/2071285/markov-process-markov-chain</a></p>
</dd>
</dl>
</dd>
</dl>
<dl class="class">
<dt id="pram.rule.Action">
<em class="property">class </em><code class="sig-prename descclassname">pram.rule.</code><code class="sig-name descname">Action</code><span class="sig-paren">(</span><em class="sig-param">name='rule'</em>, <em class="sig-param">t=TimeAlways()</em>, <em class="sig-param">i=IterAlways()</em>, <em class="sig-param">name_human=None</em>, <em class="sig-param">memo=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.rule.Action" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pram.rule.Rule" title="pram.rule.Rule"><code class="xref py py-class docutils literal notranslate"><span class="pre">pram.rule.Rule</span></code></a>, <code class="xref py py-class docutils literal notranslate"><span class="pre">abc.ABC</span></code></p>
<p>In physics, action is an attribute of the dynamics of a physical system from which the equations of motion of the
system can be derived. It is a mathematical functional which takes the trajectory, also called path or history, of
the system as its argument and has a real number as its result. Generally, the action takes different values for
different paths.[1]</p>
<p>Source: <a class="reference external" href="https://en.wikipedia.org/wiki/Action_(physics">https://en.wikipedia.org/wiki/Action_(physics</a>)</p>
</dd></dl>

<dl class="class">
<dt id="pram.rule.BernoulliProcess">
<em class="property">class </em><code class="sig-prename descclassname">pram.rule.</code><code class="sig-name descname">BernoulliProcess</code><span class="sig-paren">(</span><em class="sig-param">p=0.5</em>, <em class="sig-param">attr='state'</em>, <em class="sig-param">vals=(0</em>, <em class="sig-param">1)</em>, <em class="sig-param">name='bernoulli-process'</em>, <em class="sig-param">t=TimeAlways()</em>, <em class="sig-param">i=IterAlways()</em>, <em class="sig-param">memo=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.rule.BernoulliProcess" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pram.rule.BernoulliScheme" title="pram.rule.BernoulliScheme"><code class="xref py py-class docutils literal notranslate"><span class="pre">pram.rule.BernoulliScheme</span></code></a></p>
<p>A Bernoulli process is a sequence of independent trials in which each trial results in a success or failure with
respective probabilities $p$ and $q=1−p$.</p>
<p>A Bernoulli scheme with only two possible states is known as a Bernoulli process.</p>
<p>Binomial Markov Chain.</p>
</dd></dl>

<dl class="class">
<dt id="pram.rule.BernoulliScheme">
<em class="property">class </em><code class="sig-prename descclassname">pram.rule.</code><code class="sig-name descname">BernoulliScheme</code><span class="sig-paren">(</span><em class="sig-param">attr='state'</em>, <em class="sig-param">vals=(0</em>, <em class="sig-param">1)</em>, <em class="sig-param">name='bernoulli-process'</em>, <em class="sig-param">t=TimeAlways()</em>, <em class="sig-param">i=IterAlways()</em>, <em class="sig-param">memo=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.rule.BernoulliScheme" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pram.rule.DiscreteInvMarkovChain" title="pram.rule.DiscreteInvMarkovChain"><code class="xref py py-class docutils literal notranslate"><span class="pre">pram.rule.DiscreteInvMarkovChain</span></code></a></p>
<p>Bernoulli scheme or Bernoulli shift is a generalization of the Bernoulli process to more than two possible
outcomes.</p>
<p>A Bernoulli scheme is a special case of a Markov chain where the transition probability matrix has identical rows,
which means that the next state is even independent of the current state (in addition to being independent of the
past states).</p>
</dd></dl>

<dl class="class">
<dt id="pram.rule.BirthDeathProcess">
<em class="property">class </em><code class="sig-prename descclassname">pram.rule.</code><code class="sig-name descname">BirthDeathProcess</code><span class="sig-paren">(</span><em class="sig-param">ig</em>, <em class="sig-param">name='birth-death-process'</em>, <em class="sig-param">t=TimeAlways()</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.rule.BirthDeathProcess" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pram.rule.MarkovProcess" title="pram.rule.MarkovProcess"><code class="xref py py-class docutils literal notranslate"><span class="pre">pram.rule.MarkovProcess</span></code></a></p>
<p>A special case of continuous-time Markov process where the state transitions are of only two types: “births”, which
increase the state variable by one and “deaths”, which decrease the state by one.</p>
<p>A homogeneous Poisson process is a pure birth process.</p>
<p>The following infinitesimal generator of the process (lambda are birth rates and mu are death rates):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">|</span> <span class="o">-</span><span class="n">l_0</span>           <span class="n">l_0</span>             <span class="mi">0</span>             <span class="mi">0</span>    <span class="mi">0</span>  <span class="o">...</span> <span class="o">|</span>
<span class="o">|</span>  <span class="n">m_1</span>  <span class="o">-</span><span class="p">(</span><span class="n">l_1</span> <span class="o">+</span> <span class="n">m_1</span><span class="p">)</span>           <span class="n">l_1</span>             <span class="mi">0</span>    <span class="mi">0</span>  <span class="o">...</span> <span class="o">|</span>
<span class="o">|</span>    <span class="mi">0</span>           <span class="n">m_2</span>  <span class="o">-</span><span class="p">(</span><span class="n">l_2</span> <span class="o">+</span> <span class="n">m_2</span><span class="p">)</span>           <span class="n">l_2</span>    <span class="mi">0</span>  <span class="o">...</span> <span class="o">|</span>
<span class="o">|</span>    <span class="mi">0</span>             <span class="mi">0</span>           <span class="n">m_3</span>  <span class="o">-</span><span class="p">(</span><span class="n">l_3</span> <span class="o">+</span> <span class="n">m_3</span><span class="p">)</span>  <span class="n">l_3</span>  <span class="o">...</span> <span class="o">|</span>
<span class="o">|</span>    <span class="o">.</span>             <span class="o">.</span>             <span class="o">.</span>             <span class="o">.</span>    <span class="o">.</span>  <span class="o">...</span> <span class="o">|</span>
<span class="o">|</span>    <span class="o">.</span>             <span class="o">.</span>             <span class="o">.</span>             <span class="o">.</span>    <span class="o">.</span>  <span class="o">...</span> <span class="o">|</span>
</pre></div>
</div>
<p>should be provided as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">l_0</span><span class="p">,</span> <span class="p">[</span><span class="n">l_1</span><span class="p">,</span> <span class="n">m_1</span><span class="p">],</span> <span class="p">[</span><span class="n">l_2</span><span class="p">,</span> <span class="n">m_2</span><span class="p">],</span> <span class="p">[</span><span class="n">l_3</span><span class="p">,</span> <span class="n">m_3</span><span class="p">],</span> <span class="o">...</span><span class="p">,</span> <span class="n">m_n</span><span class="p">]</span>
</pre></div>
</div>
<p>Sojourn times have exponential p.d.f. <span class="math notranslate nohighlight">\(\lambda e^{-\lambda t}\)</span>.</p>
<dl class="method">
<dt id="pram.rule.BirthDeathProcess.apply">
<code class="sig-name descname">apply</code><span class="sig-paren">(</span><em class="sig-param">pop</em>, <em class="sig-param">group</em>, <em class="sig-param">iter</em>, <em class="sig-param">t</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.rule.BirthDeathProcess.apply" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pram.rule.CellularAutomaton">
<em class="property">class </em><code class="sig-prename descclassname">pram.rule.</code><code class="sig-name descname">CellularAutomaton</code><span class="sig-paren">(</span><em class="sig-param">name='rule'</em>, <em class="sig-param">t=TimeAlways()</em>, <em class="sig-param">i=IterAlways()</em>, <em class="sig-param">name_human=None</em>, <em class="sig-param">memo=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.rule.CellularAutomaton" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pram.rule.StochasticProcess" title="pram.rule.StochasticProcess"><code class="xref py py-class docutils literal notranslate"><span class="pre">pram.rule.StochasticProcess</span></code></a></p>
<p>Cellular automata are a discrete-time dynamical system of interacting entities, whose state is discrete.</p>
</dd></dl>

<dl class="class">
<dt id="pram.rule.ChaoticMap">
<em class="property">class </em><code class="sig-prename descclassname">pram.rule.</code><code class="sig-name descname">ChaoticMap</code><span class="sig-paren">(</span><em class="sig-param">name='rule'</em>, <em class="sig-param">t=TimeAlways()</em>, <em class="sig-param">i=IterAlways()</em>, <em class="sig-param">name_human=None</em>, <em class="sig-param">memo=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.rule.ChaoticMap" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pram.rule.Rule" title="pram.rule.Rule"><code class="xref py py-class docutils literal notranslate"><span class="pre">pram.rule.Rule</span></code></a>, <code class="xref py py-class docutils literal notranslate"><span class="pre">abc.ABC</span></code></p>
<p>The simplest dynamical system that has relevant features of chaotic Hamiltonian systems.</p>
<dl class="simple">
<dt>List of chaotic maps</dt><dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/List_of_chaotic_maps">https://en.wikipedia.org/wiki/List_of_chaotic_maps</a></p>
</dd>
</dl>
</dd></dl>

<dl class="class">
<dt id="pram.rule.CompoundInterstSeq">
<em class="property">class </em><code class="sig-prename descclassname">pram.rule.</code><code class="sig-name descname">CompoundInterstSeq</code><span class="sig-paren">(</span><em class="sig-param">attr</em>, <em class="sig-param">r</em>, <em class="sig-param">n</em>, <em class="sig-param">name='compund-interst-seq'</em>, <em class="sig-param">t=TimeAlways()</em>, <em class="sig-param">i=IterAlways()</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.rule.CompoundInterstSeq" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pram.rule.Sequence" title="pram.rule.Sequence"><code class="xref py py-class docutils literal notranslate"><span class="pre">pram.rule.Sequence</span></code></a>, <a class="reference internal" href="#pram.rule.DifferenceEquation" title="pram.rule.DifferenceEquation"><code class="xref py py-class docutils literal notranslate"><span class="pre">pram.rule.DifferenceEquation</span></code></a></p>
<p>Applies the comound interest formula to the designated attribute.</p>
<dl class="simple">
<dt>In:</dt><dd><p>r - nominal annual interest rate
n - compund frequency [months]</p>
</dd>
</dl>
<dl class="method">
<dt id="pram.rule.CompoundInterstSeq.apply">
<code class="sig-name descname">apply</code><span class="sig-paren">(</span><em class="sig-param">pop</em>, <em class="sig-param">group</em>, <em class="sig-param">iter</em>, <em class="sig-param">t</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.rule.CompoundInterstSeq.apply" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pram.rule.ContinuousSpaceDiscreteTimeStochasticProcess">
<em class="property">class </em><code class="sig-prename descclassname">pram.rule.</code><code class="sig-name descname">ContinuousSpaceDiscreteTimeStochasticProcess</code><span class="sig-paren">(</span><em class="sig-param">name='rule'</em>, <em class="sig-param">t=TimeAlways()</em>, <em class="sig-param">i=IterAlways()</em>, <em class="sig-param">name_human=None</em>, <em class="sig-param">memo=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.rule.ContinuousSpaceDiscreteTimeStochasticProcess" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pram.rule.StochasticProcess" title="pram.rule.StochasticProcess"><code class="xref py py-class docutils literal notranslate"><span class="pre">pram.rule.StochasticProcess</span></code></a>, <code class="xref py py-class docutils literal notranslate"><span class="pre">abc.ABC</span></code></p>
</dd></dl>

<dl class="class">
<dt id="pram.rule.ContinuousSpacetimeStochasticProcess">
<em class="property">class </em><code class="sig-prename descclassname">pram.rule.</code><code class="sig-name descname">ContinuousSpacetimeStochasticProcess</code><span class="sig-paren">(</span><em class="sig-param">name='rule'</em>, <em class="sig-param">t=TimeAlways()</em>, <em class="sig-param">i=IterAlways()</em>, <em class="sig-param">name_human=None</em>, <em class="sig-param">memo=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.rule.ContinuousSpacetimeStochasticProcess" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pram.rule.StochasticProcess" title="pram.rule.StochasticProcess"><code class="xref py py-class docutils literal notranslate"><span class="pre">pram.rule.StochasticProcess</span></code></a>, <code class="xref py py-class docutils literal notranslate"><span class="pre">abc.ABC</span></code></p>
</dd></dl>

<dl class="class">
<dt id="pram.rule.Control">
<em class="property">class </em><code class="sig-prename descclassname">pram.rule.</code><code class="sig-name descname">Control</code><span class="sig-paren">(</span><em class="sig-param">name='rule'</em>, <em class="sig-param">t=TimeAlways()</em>, <em class="sig-param">i=IterAlways()</em>, <em class="sig-param">name_human=None</em>, <em class="sig-param">memo=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.rule.Control" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pram.rule.Rule" title="pram.rule.Rule"><code class="xref py py-class docutils literal notranslate"><span class="pre">pram.rule.Rule</span></code></a>, <code class="xref py py-class docutils literal notranslate"><span class="pre">abc.ABC</span></code></p>
</dd></dl>

<dl class="class">
<dt id="pram.rule.CotinuousMarkovChain">
<em class="property">class </em><code class="sig-prename descclassname">pram.rule.</code><code class="sig-name descname">CotinuousMarkovChain</code><span class="sig-paren">(</span><em class="sig-param">name='rule'</em>, <em class="sig-param">t=TimeAlways()</em>, <em class="sig-param">i=IterAlways()</em>, <em class="sig-param">name_human=None</em>, <em class="sig-param">memo=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.rule.CotinuousMarkovChain" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pram.rule.MarkovChain" title="pram.rule.MarkovChain"><code class="xref py py-class docutils literal notranslate"><span class="pre">pram.rule.MarkovChain</span></code></a>, <a class="reference internal" href="#pram.rule.DiscreteSpaceContinuousTimeStochasticProcess" title="pram.rule.DiscreteSpaceContinuousTimeStochasticProcess"><code class="xref py py-class docutils literal notranslate"><span class="pre">pram.rule.DiscreteSpaceContinuousTimeStochasticProcess</span></code></a></p>
<p>Continuous-time Markov chain with finite state space.</p>
</dd></dl>

<dl class="class">
<dt id="pram.rule.CoxProcess">
<em class="property">class </em><code class="sig-prename descclassname">pram.rule.</code><code class="sig-name descname">CoxProcess</code><span class="sig-paren">(</span><em class="sig-param">name='rule'</em>, <em class="sig-param">t=TimeAlways()</em>, <em class="sig-param">i=IterAlways()</em>, <em class="sig-param">name_human=None</em>, <em class="sig-param">memo=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.rule.CoxProcess" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pram.rule.PoissonProcess" title="pram.rule.PoissonProcess"><code class="xref py py-class docutils literal notranslate"><span class="pre">pram.rule.PoissonProcess</span></code></a></p>
<p>A point process which is a generalization of a Poisson process where the time-dependent intensity is itself a
stochastic process.</p>
<p>Also known as a doubly stochastic Poisson process.</p>
</dd></dl>

<dl class="class">
<dt id="pram.rule.DifferenceEquation">
<em class="property">class </em><code class="sig-prename descclassname">pram.rule.</code><code class="sig-name descname">DifferenceEquation</code><span class="sig-paren">(</span><em class="sig-param">name='rule'</em>, <em class="sig-param">t=TimeAlways()</em>, <em class="sig-param">i=IterAlways()</em>, <em class="sig-param">name_human=None</em>, <em class="sig-param">memo=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.rule.DifferenceEquation" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pram.rule.Equation" title="pram.rule.Equation"><code class="xref py py-class docutils literal notranslate"><span class="pre">pram.rule.Equation</span></code></a>, <code class="xref py py-class docutils literal notranslate"><span class="pre">abc.ABC</span></code></p>
</dd></dl>

<dl class="class">
<dt id="pram.rule.DiffusionProcess">
<em class="property">class </em><code class="sig-prename descclassname">pram.rule.</code><code class="sig-name descname">DiffusionProcess</code><span class="sig-paren">(</span><em class="sig-param">name='rule'</em>, <em class="sig-param">t=TimeAlways()</em>, <em class="sig-param">i=IterAlways()</em>, <em class="sig-param">name_human=None</em>, <em class="sig-param">memo=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.rule.DiffusionProcess" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pram.rule.MarkovProcess" title="pram.rule.MarkovProcess"><code class="xref py py-class docutils literal notranslate"><span class="pre">pram.rule.MarkovProcess</span></code></a></p>
<p>A continuous-time Markov process with almost surely continuous sample paths.</p>
<p>A solution to a stochastic differential equation (in short form),</p>
<blockquote>
<div><p>d X_t = mu(X_t, t)dt + sigma X_t(X_t, t)dB_t,</p>
</div></blockquote>
<p>where $B$ is a standard Brownian motion.</p>
</dd></dl>

<dl class="class">
<dt id="pram.rule.Directive">
<em class="property">class </em><code class="sig-prename descclassname">pram.rule.</code><code class="sig-name descname">Directive</code><a class="headerlink" href="#pram.rule.Directive" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">abc.ABC</span></code></p>
</dd></dl>

<dl class="class">
<dt id="pram.rule.DiscreteInvMarkovChain">
<em class="property">class </em><code class="sig-prename descclassname">pram.rule.</code><code class="sig-name descname">DiscreteInvMarkovChain</code><span class="sig-paren">(</span><em class="sig-param">var</em>, <em class="sig-param">tm</em>, <em class="sig-param">name='markov-chain'</em>, <em class="sig-param">t=TimeAlways()</em>, <em class="sig-param">i=IterAlways()</em>, <em class="sig-param">memo=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.rule.DiscreteInvMarkovChain" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pram.rule.MarkovChain" title="pram.rule.MarkovChain"><code class="xref py py-class docutils literal notranslate"><span class="pre">pram.rule.MarkovChain</span></code></a>, <a class="reference internal" href="#pram.rule.DiscreteSpacetimeStochasticProcess" title="pram.rule.DiscreteSpacetimeStochasticProcess"><code class="xref py py-class docutils literal notranslate"><span class="pre">pram.rule.DiscreteSpacetimeStochasticProcess</span></code></a>, <a class="reference internal" href="#pram.rule.StationaryProcess" title="pram.rule.StationaryProcess"><code class="xref py py-class docutils literal notranslate"><span class="pre">pram.rule.StationaryProcess</span></code></a></p>
<p>Discrete-time time-homogenous Markov chain with finite state space.</p>
<p>The following sample transition model for the variables named X:</p>
<blockquote>
<div><blockquote>
<div><p>x_1^t   x_2^t</p>
</div></blockquote>
<p>x_1^{t+1}    0.1     0.3
x_2^{t+1}    0.9     0.7</p>
</div></blockquote>
<p>Should be specified as the following list of stochastic vectors:</p>
<blockquote>
<div><p>{ ‘x1’: [0.1, 0.9], ‘x2’: [0.3, 0.7] }</p>
</div></blockquote>
<p>—-[ Definition ]————————————————————————————————–</p>
<p>A stochastic process $X = {X_n:n geq 0}$ on a countable set $S$ is a Markov Chain if, for any $i,j in S$ and
$n geq 0$,</p>
<p>P(X_{n+1} = j | X_0, ldots, X_n) = P(X_{n+1} = j | X_n)
P(X_{n+1} = j | X_n = i) = p_{ij}</p>
<p>The $p_{ij} is the probability that the Markov chain jumps from state $i$ to state $j$.  These transition
probabilities satisfy $sum_{j in S} p_{ij} = 1, i in S$, and the matrix $P=(pij)$ is the transition matrix of
the chain.</p>
<p>—-[ Notation A ]—-</p>
<dl>
<dt>code:</dt><dd><p>DiscreteInvMarkovChain(‘flu’, { ‘s’: [0.95, 0.05, 0.00], ‘i’: [0.00, 0.80, 0.10], ‘r’: [0.10, 0.00, 0.90] })</p>
</dd>
<dt>init:</dt><dd><dl class="simple">
<dt>tm = {</dt><dd><p>s: [0.95, 0.05, 0.00],
i: [0.00, 0.80, 0.20],
r: [0.10, 0.00, 0.90]</p>
</dd>
</dl>
<p>}  # right stochastic matrix</p>
</dd>
<dt>is-applicable:</dt><dd><p>has-attr: flu</p>
</dd>
<dt>apply:</dt><dd><p>curr_state = group.attr.flu
new_state_sv = tm[]  # stochastic vector
move-mass:</p>
<blockquote>
<div><p>new_state_sv[0] -&gt; A:flu = ‘s’
new_state_sv[1] -&gt; A:flu = ‘i’
new_state_sv[2] -&gt; A:flu = ‘r’</p>
</div></blockquote>
</dd>
</dl>
<p>—-[ Notation B ]—-</p>
<p>tm_i = tm[group.attr.flu]
tm_i[0] -&gt; A:flu = ‘s’
tm_i[1] -&gt; A:flu = ‘i’
tm_i[2] -&gt; A:flu = ‘r’</p>
<dl class="method">
<dt id="pram.rule.DiscreteInvMarkovChain.apply">
<code class="sig-name descname">apply</code><span class="sig-paren">(</span><em class="sig-param">pop</em>, <em class="sig-param">group</em>, <em class="sig-param">iter</em>, <em class="sig-param">t</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.rule.DiscreteInvMarkovChain.apply" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.rule.DiscreteInvMarkovChain.is_applicable">
<code class="sig-name descname">is_applicable</code><span class="sig-paren">(</span><em class="sig-param">group</em>, <em class="sig-param">iter</em>, <em class="sig-param">t</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.rule.DiscreteInvMarkovChain.is_applicable" title="Permalink to this definition">¶</a></dt>
<dd><p>Verifies if the rule is applicable to the group at the current iteration and current time.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pram.rule.DiscreteSpaceContinuousTimeStochasticProcess">
<em class="property">class </em><code class="sig-prename descclassname">pram.rule.</code><code class="sig-name descname">DiscreteSpaceContinuousTimeStochasticProcess</code><span class="sig-paren">(</span><em class="sig-param">name='rule'</em>, <em class="sig-param">t=TimeAlways()</em>, <em class="sig-param">i=IterAlways()</em>, <em class="sig-param">name_human=None</em>, <em class="sig-param">memo=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.rule.DiscreteSpaceContinuousTimeStochasticProcess" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pram.rule.StochasticProcess" title="pram.rule.StochasticProcess"><code class="xref py py-class docutils literal notranslate"><span class="pre">pram.rule.StochasticProcess</span></code></a>, <code class="xref py py-class docutils literal notranslate"><span class="pre">abc.ABC</span></code></p>
</dd></dl>

<dl class="class">
<dt id="pram.rule.DiscreteSpacetimeStochasticProcess">
<em class="property">class </em><code class="sig-prename descclassname">pram.rule.</code><code class="sig-name descname">DiscreteSpacetimeStochasticProcess</code><span class="sig-paren">(</span><em class="sig-param">name='rule'</em>, <em class="sig-param">t=TimeAlways()</em>, <em class="sig-param">i=IterAlways()</em>, <em class="sig-param">name_human=None</em>, <em class="sig-param">memo=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.rule.DiscreteSpacetimeStochasticProcess" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pram.rule.StochasticProcess" title="pram.rule.StochasticProcess"><code class="xref py py-class docutils literal notranslate"><span class="pre">pram.rule.StochasticProcess</span></code></a>, <code class="xref py py-class docutils literal notranslate"><span class="pre">abc.ABC</span></code></p>
</dd></dl>

<dl class="class">
<dt id="pram.rule.DiscreteVarMarkovChain">
<em class="property">class </em><code class="sig-prename descclassname">pram.rule.</code><code class="sig-name descname">DiscreteVarMarkovChain</code><span class="sig-paren">(</span><em class="sig-param">var</em>, <em class="sig-param">tm</em>, <em class="sig-param">name='markov-chain'</em>, <em class="sig-param">t=TimeAlways()</em>, <em class="sig-param">memo=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.rule.DiscreteVarMarkovChain" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pram.rule.MarkovChain" title="pram.rule.MarkovChain"><code class="xref py py-class docutils literal notranslate"><span class="pre">pram.rule.MarkovChain</span></code></a>, <a class="reference internal" href="#pram.rule.DiscreteSpacetimeStochasticProcess" title="pram.rule.DiscreteSpacetimeStochasticProcess"><code class="xref py py-class docutils literal notranslate"><span class="pre">pram.rule.DiscreteSpacetimeStochasticProcess</span></code></a></p>
<p>Discrete-time non-time-homogenous Markov chain with finite state space.</p>
<p>—-[ Notation A ]—-</p>
<dl>
<dt>code:</dt><dd><dl class="simple">
<dt>fn_flu_s_sv:</dt><dd><p>p_inf = <a class="reference external" href="mailto:n&#37;&#52;&#48;_{attr&#46;flu">n<span>&#64;</span>_{attr<span>&#46;</span>flu</a> = ‘i’} / n&#64;
return [1 - p_inf, p_inf, 0.00]</p>
</dd>
</dl>
<p>TimeVarMarkovChain(‘flu’, { ‘s’: fn_flu_s_sv, ‘i’: [0.00, 0.80, 0.20], ‘r’: [0.10, 0.00, 0.90] })</p>
</dd>
<dt>ext:</dt><dd><p>p_inf</p>
</dd>
<dt>init:</dt><dd><dl class="simple">
<dt>tm = {</dt><dd><p>s: [1 - p_inf, p_inf, 0.00],
i: [0.00, 0.80, 0.20],
r: [0.10, 0.00, 0.90]</p>
</dd>
</dl>
<p>}  # right stochastic matrix</p>
</dd>
<dt>is-applicable:</dt><dd><p>has-attr: flu</p>
</dd>
<dt>apply:</dt><dd><p>tm_i = tm[group.attr.flu]
move-mass:</p>
<blockquote>
<div><p>tm_i[0] -&gt; A: flu = s
tm_i[1] -&gt; A: flu = i
tm_i[2] -&gt; A: flu = r</p>
</div></blockquote>
</dd>
</dl>
<p>—-[ Notation B ]—-</p>
<p>tm_i = tm[group.attr.flu]
tm_i[0] -&gt; A:flu = ‘s’
tm_i[1] -&gt; A:flu = ‘i’
tm_i[2] -&gt; A:flu = ‘r’</p>
<dl class="method">
<dt id="pram.rule.DiscreteVarMarkovChain.apply">
<code class="sig-name descname">apply</code><span class="sig-paren">(</span><em class="sig-param">pop</em>, <em class="sig-param">group</em>, <em class="sig-param">iter</em>, <em class="sig-param">t</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.rule.DiscreteVarMarkovChain.apply" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.rule.DiscreteVarMarkovChain.is_applicable">
<code class="sig-name descname">is_applicable</code><span class="sig-paren">(</span><em class="sig-param">group</em>, <em class="sig-param">iter</em>, <em class="sig-param">t</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.rule.DiscreteVarMarkovChain.is_applicable" title="Permalink to this definition">¶</a></dt>
<dd><p>Verifies if the rule is applicable to the group at the current iteration and current time.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pram.rule.DistributionProcess">
<em class="property">class </em><code class="sig-prename descclassname">pram.rule.</code><code class="sig-name descname">DistributionProcess</code><span class="sig-paren">(</span><em class="sig-param">name='distrib-proc'</em>, <em class="sig-param">t=TimeAlways()</em>, <em class="sig-param">i=IterAlways()</em>, <em class="sig-param">p_max=None</em>, <em class="sig-param">memo=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.rule.DistributionProcess" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pram.rule.Process" title="pram.rule.Process"><code class="xref py py-class docutils literal notranslate"><span class="pre">pram.rule.Process</span></code></a>, <code class="xref py py-class docutils literal notranslate"><span class="pre">abc.ABC</span></code></p>
<p>A maximum of ‘p_max’ proportion of mass should be converted (i.e., at the mode of the distribution).  The
distribution that describes mass conversion is internally scaled to match that argument.  If ‘None’, no scaling is
performed</p>
<dl class="method">
<dt id="pram.rule.DistributionProcess.get_p">
<code class="sig-name descname">get_p</code><span class="sig-paren">(</span><em class="sig-param">iter</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.rule.DistributionProcess.get_p" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.rule.DistributionProcess.plot">
<code class="sig-name descname">plot</code><span class="sig-paren">(</span><em class="sig-param">figsize=(10</em>, <em class="sig-param">2)</em>, <em class="sig-param">fmt='g-'</em>, <em class="sig-param">lw=1</em>, <em class="sig-param">label=None</em>, <em class="sig-param">dpi=150</em>, <em class="sig-param">do_legend=True</em>, <em class="sig-param">do_show=True</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.rule.DistributionProcess.plot" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.rule.DistributionProcess.set_dist">
<code class="sig-name descname">set_dist</code><span class="sig-paren">(</span><em class="sig-param">dist</em>, <em class="sig-param">mode</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.rule.DistributionProcess.set_dist" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pram.rule.Disturbance">
<em class="property">class </em><code class="sig-prename descclassname">pram.rule.</code><code class="sig-name descname">Disturbance</code><span class="sig-paren">(</span><em class="sig-param">name='rule'</em>, <em class="sig-param">t=TimeAlways()</em>, <em class="sig-param">i=IterAlways()</em>, <em class="sig-param">name_human=None</em>, <em class="sig-param">memo=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.rule.Disturbance" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pram.rule.Rule" title="pram.rule.Rule"><code class="xref py py-class docutils literal notranslate"><span class="pre">pram.rule.Rule</span></code></a>, <code class="xref py py-class docutils literal notranslate"><span class="pre">abc.ABC</span></code></p>
</dd></dl>

<dl class="class">
<dt id="pram.rule.Equation">
<em class="property">class </em><code class="sig-prename descclassname">pram.rule.</code><code class="sig-name descname">Equation</code><span class="sig-paren">(</span><em class="sig-param">name='rule'</em>, <em class="sig-param">t=TimeAlways()</em>, <em class="sig-param">i=IterAlways()</em>, <em class="sig-param">name_human=None</em>, <em class="sig-param">memo=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.rule.Equation" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pram.rule.Rule" title="pram.rule.Rule"><code class="xref py py-class docutils literal notranslate"><span class="pre">pram.rule.Rule</span></code></a>, <code class="xref py py-class docutils literal notranslate"><span class="pre">abc.ABC</span></code></p>
</dd></dl>

<dl class="class">
<dt id="pram.rule.Event">
<em class="property">class </em><code class="sig-prename descclassname">pram.rule.</code><code class="sig-name descname">Event</code><span class="sig-paren">(</span><em class="sig-param">name='rule'</em>, <em class="sig-param">t=TimeAlways()</em>, <em class="sig-param">i=IterAlways()</em>, <em class="sig-param">name_human=None</em>, <em class="sig-param">memo=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.rule.Event" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pram.rule.Rule" title="pram.rule.Rule"><code class="xref py py-class docutils literal notranslate"><span class="pre">pram.rule.Rule</span></code></a>, <code class="xref py py-class docutils literal notranslate"><span class="pre">abc.ABC</span></code></p>
</dd></dl>

<dl class="class">
<dt id="pram.rule.FibonacciSeq">
<em class="property">class </em><code class="sig-prename descclassname">pram.rule.</code><code class="sig-name descname">FibonacciSeq</code><span class="sig-paren">(</span><em class="sig-param">attr='fib'</em>, <em class="sig-param">name='fibonacci-seq'</em>, <em class="sig-param">t=TimeAlways()</em>, <em class="sig-param">i=IterAlways()</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.rule.FibonacciSeq" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pram.rule.Sequence" title="pram.rule.Sequence"><code class="xref py py-class docutils literal notranslate"><span class="pre">pram.rule.Sequence</span></code></a>, <a class="reference internal" href="#pram.rule.DifferenceEquation" title="pram.rule.DifferenceEquation"><code class="xref py py-class docutils literal notranslate"><span class="pre">pram.rule.DifferenceEquation</span></code></a></p>
<p>The Fibonacci numbers sequence.</p>
<p>F0-F20: 0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 6765</p>
<dl class="method">
<dt id="pram.rule.FibonacciSeq.apply">
<code class="sig-name descname">apply</code><span class="sig-paren">(</span><em class="sig-param">pop</em>, <em class="sig-param">group</em>, <em class="sig-param">iter</em>, <em class="sig-param">t</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.rule.FibonacciSeq.apply" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.rule.FibonacciSeq.is_applicable">
<code class="sig-name descname">is_applicable</code><span class="sig-paren">(</span><em class="sig-param">group</em>, <em class="sig-param">iter</em>, <em class="sig-param">t</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.rule.FibonacciSeq.is_applicable" title="Permalink to this definition">¶</a></dt>
<dd><p>Verifies if the rule is applicable to the group at the current iteration and current time.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pram.rule.Forcing">
<em class="property">class </em><code class="sig-prename descclassname">pram.rule.</code><code class="sig-name descname">Forcing</code><span class="sig-paren">(</span><em class="sig-param">name='rule'</em>, <em class="sig-param">t=TimeAlways()</em>, <em class="sig-param">i=IterAlways()</em>, <em class="sig-param">name_human=None</em>, <em class="sig-param">memo=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.rule.Forcing" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pram.rule.Rule" title="pram.rule.Rule"><code class="xref py py-class docutils literal notranslate"><span class="pre">pram.rule.Rule</span></code></a>, <code class="xref py py-class docutils literal notranslate"><span class="pre">abc.ABC</span></code></p>
</dd></dl>

<dl class="class">
<dt id="pram.rule.ForkDirective">
<em class="property">class </em><code class="sig-prename descclassname">pram.rule.</code><code class="sig-name descname">ForkDirective</code><a class="headerlink" href="#pram.rule.ForkDirective" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pram.rule.Directive" title="pram.rule.Directive"><code class="xref py py-class docutils literal notranslate"><span class="pre">pram.rule.Directive</span></code></a></p>
</dd></dl>

<dl class="class">
<dt id="pram.rule.GammaDistributionProcess">
<em class="property">class </em><code class="sig-prename descclassname">pram.rule.</code><code class="sig-name descname">GammaDistributionProcess</code><span class="sig-paren">(</span><em class="sig-param">name='gamma-distrib-proc'</em>, <em class="sig-param">t=TimeAlways()</em>, <em class="sig-param">i=IterAlways()</em>, <em class="sig-param">p_max=None</em>, <em class="sig-param">a=1.0</em>, <em class="sig-param">loc=0.0</em>, <em class="sig-param">scale=1.0</em>, <em class="sig-param">label=None</em>, <em class="sig-param">memo=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.rule.GammaDistributionProcess" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pram.rule.DistributionProcess" title="pram.rule.DistributionProcess"><code class="xref py py-class docutils literal notranslate"><span class="pre">pram.rule.DistributionProcess</span></code></a>, <code class="xref py py-class docutils literal notranslate"><span class="pre">abc.ABC</span></code></p>
</dd></dl>

<dl class="class">
<dt id="pram.rule.GoToAndBackTimeAtRule">
<em class="property">class </em><code class="sig-prename descclassname">pram.rule.</code><code class="sig-name descname">GoToAndBackTimeAtRule</code><span class="sig-paren">(</span><em class="sig-param">t=[8, 16], i=None, to='school', back='home', time_pdf_to=None, time_pdf_back=None, t_at_attr='t&#64;', do_force_back=True, name_human=None, memo=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.rule.GoToAndBackTimeAtRule" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pram.rule.Rule" title="pram.rule.Rule"><code class="xref py py-class docutils literal notranslate"><span class="pre">pram.rule.Rule</span></code></a></p>
<p>Compels agents to go to the designated site and back; agents stay at the destination for a specificed amount of
time.</p>
<p>Both ‘to’ and ‘back’ sites need to be specified.  Moreover, the proportion of agents moving to the destination can
be speficied as a probability distribution function (PDF) as can the time agents should spend at the destination.
As a consequence of the latter, this rule tracks the time agents spend at the destination via a group attribute
‘t_at_attr’.  Furthermore, agents can be forced to the original location at the end of the rule’s time interval.
For example, students can be made go back home at the time schools close, irrespective of how long they have been
at school.</p>
<p>This rule is only applicable to groups with both to and from sites and only those that are currently located at the
latter.</p>
<dl class="attribute">
<dt id="pram.rule.GoToAndBackTimeAtRule.NAME">
<code class="sig-name descname">NAME</code><em class="property"> = 'Goto and back'</em><a class="headerlink" href="#pram.rule.GoToAndBackTimeAtRule.NAME" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pram.rule.GoToAndBackTimeAtRule.TIME_PDF_BACK_DEF">
<code class="sig-name descname">TIME_PDF_BACK_DEF</code><em class="property"> = {1: 0.05, 3: 0.2, 4: 0.25, 5: 0.2, 6: 0.1, 7: 0.1, 8: 0.1}</em><a class="headerlink" href="#pram.rule.GoToAndBackTimeAtRule.TIME_PDF_BACK_DEF" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pram.rule.GoToAndBackTimeAtRule.TIME_PDF_TO_DEF">
<code class="sig-name descname">TIME_PDF_TO_DEF</code><em class="property"> = {8: 0.5, 12: 0.5}</em><a class="headerlink" href="#pram.rule.GoToAndBackTimeAtRule.TIME_PDF_TO_DEF" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.rule.GoToAndBackTimeAtRule.apply">
<code class="sig-name descname">apply</code><span class="sig-paren">(</span><em class="sig-param">pop</em>, <em class="sig-param">group</em>, <em class="sig-param">iter</em>, <em class="sig-param">t</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.rule.GoToAndBackTimeAtRule.apply" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.rule.GoToAndBackTimeAtRule.apply_back">
<code class="sig-name descname">apply_back</code><span class="sig-paren">(</span><em class="sig-param">group</em>, <em class="sig-param">iter</em>, <em class="sig-param">t</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.rule.GoToAndBackTimeAtRule.apply_back" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.rule.GoToAndBackTimeAtRule.apply_to">
<code class="sig-name descname">apply_to</code><span class="sig-paren">(</span><em class="sig-param">group</em>, <em class="sig-param">iter</em>, <em class="sig-param">t</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.rule.GoToAndBackTimeAtRule.apply_to" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.rule.GoToAndBackTimeAtRule.is_applicable">
<code class="sig-name descname">is_applicable</code><span class="sig-paren">(</span><em class="sig-param">group</em>, <em class="sig-param">iter</em>, <em class="sig-param">t</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.rule.GoToAndBackTimeAtRule.is_applicable" title="Permalink to this definition">¶</a></dt>
<dd><p>Verifies if the rule is applicable to the group at the current iteration and current time.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pram.rule.GoToRule">
<em class="property">class </em><code class="sig-prename descclassname">pram.rule.</code><code class="sig-name descname">GoToRule</code><span class="sig-paren">(</span><em class="sig-param">t</em>, <em class="sig-param">i</em>, <em class="sig-param">p</em>, <em class="sig-param">rel_from</em>, <em class="sig-param">rel_to</em>, <em class="sig-param">name_human=None</em>, <em class="sig-param">memo=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.rule.GoToRule" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pram.rule.Rule" title="pram.rule.Rule"><code class="xref py py-class docutils literal notranslate"><span class="pre">pram.rule.Rule</span></code></a></p>
<p>Changes the location of a group from the designated site to the designated site.  Both of the sites are
specificed by relation name (e.g., ‘store’).  The rule will only apply to a group that (a) is currently located at
the “from” relation and has the “to” relation.  If the “from” argument is None, all groups will qualify as long as
they have the “to” relation.  The values of the relations need to be of type Site.</p>
<p>Only one ‘from’ and ‘to’ location is handled by this rule (i.e., lists of locations are not supported).</p>
<p>The group’s current location is defined by the ‘Site.AT’ relation name and that’s the relation that this rule
updates.</p>
<dl class="simple">
<dt>Example uses:</dt><dd><ul class="simple">
<li><p>Compel a portion of agents that are at ‘home’ go to ‘work’ or vice versa</p></li>
</ul>
</dd>
</dl>
<dl class="attribute">
<dt id="pram.rule.GoToRule.NAME">
<code class="sig-name descname">NAME</code><em class="property"> = 'Goto'</em><a class="headerlink" href="#pram.rule.GoToRule.NAME" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.rule.GoToRule.apply">
<code class="sig-name descname">apply</code><span class="sig-paren">(</span><em class="sig-param">pop</em>, <em class="sig-param">group</em>, <em class="sig-param">iter</em>, <em class="sig-param">t</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.rule.GoToRule.apply" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.rule.GoToRule.is_applicable">
<code class="sig-name descname">is_applicable</code><span class="sig-paren">(</span><em class="sig-param">group</em>, <em class="sig-param">iter</em>, <em class="sig-param">t</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.rule.GoToRule.is_applicable" title="Permalink to this definition">¶</a></dt>
<dd><p>Verifies if the rule is applicable to the group at the current iteration and current time.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pram.rule.Input">
<em class="property">class </em><code class="sig-prename descclassname">pram.rule.</code><code class="sig-name descname">Input</code><span class="sig-paren">(</span><em class="sig-param">name='rule'</em>, <em class="sig-param">t=TimeAlways()</em>, <em class="sig-param">i=IterAlways()</em>, <em class="sig-param">name_human=None</em>, <em class="sig-param">memo=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.rule.Input" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pram.rule.Rule" title="pram.rule.Rule"><code class="xref py py-class docutils literal notranslate"><span class="pre">pram.rule.Rule</span></code></a>, <code class="xref py py-class docutils literal notranslate"><span class="pre">abc.ABC</span></code></p>
</dd></dl>

<dl class="class">
<dt id="pram.rule.InteractingParticleSystem">
<em class="property">class </em><code class="sig-prename descclassname">pram.rule.</code><code class="sig-name descname">InteractingParticleSystem</code><span class="sig-paren">(</span><em class="sig-param">name='rule'</em>, <em class="sig-param">t=TimeAlways()</em>, <em class="sig-param">i=IterAlways()</em>, <em class="sig-param">name_human=None</em>, <em class="sig-param">memo=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.rule.InteractingParticleSystem" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pram.rule.StochasticProcess" title="pram.rule.StochasticProcess"><code class="xref py py-class docutils literal notranslate"><span class="pre">pram.rule.StochasticProcess</span></code></a></p>
<p>Continuous-time Markov jump processes describing the collective behavior of stochastically interacting components.
IPS are the continuous-time analogue of stochastic cellular automata.</p>
</dd></dl>

<dl class="class">
<dt id="pram.rule.Intervention">
<em class="property">class </em><code class="sig-prename descclassname">pram.rule.</code><code class="sig-name descname">Intervention</code><span class="sig-paren">(</span><em class="sig-param">name='rule'</em>, <em class="sig-param">t=TimeAlways()</em>, <em class="sig-param">i=IterAlways()</em>, <em class="sig-param">name_human=None</em>, <em class="sig-param">memo=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.rule.Intervention" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pram.rule.Rule" title="pram.rule.Rule"><code class="xref py py-class docutils literal notranslate"><span class="pre">pram.rule.Rule</span></code></a>, <code class="xref py py-class docutils literal notranslate"><span class="pre">abc.ABC</span></code></p>
</dd></dl>

<dl class="class">
<dt id="pram.rule.Iter">
<em class="property">class </em><code class="sig-prename descclassname">pram.rule.</code><code class="sig-name descname">Iter</code><a class="headerlink" href="#pram.rule.Iter" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">abc.ABC</span></code></p>
</dd></dl>

<dl class="class">
<dt id="pram.rule.IterAlways">
<em class="property">class </em><code class="sig-prename descclassname">pram.rule.</code><code class="sig-name descname">IterAlways</code><a class="headerlink" href="#pram.rule.IterAlways" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pram.rule.Iter" title="pram.rule.Iter"><code class="xref py py-class docutils literal notranslate"><span class="pre">pram.rule.Iter</span></code></a></p>
</dd></dl>

<dl class="class">
<dt id="pram.rule.IterInt">
<em class="property">class </em><code class="sig-prename descclassname">pram.rule.</code><code class="sig-name descname">IterInt</code><span class="sig-paren">(</span><em class="sig-param">i0=0</em>, <em class="sig-param">i1=100</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.rule.IterInt" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pram.rule.Iter" title="pram.rule.Iter"><code class="xref py py-class docutils literal notranslate"><span class="pre">pram.rule.Iter</span></code></a></p>
<dl class="attribute">
<dt id="pram.rule.IterInt.i0">
<code class="sig-name descname">i0</code><a class="headerlink" href="#pram.rule.IterInt.i0" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pram.rule.IterInt.i1">
<code class="sig-name descname">i1</code><a class="headerlink" href="#pram.rule.IterInt.i1" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pram.rule.IterPoint">
<em class="property">class </em><code class="sig-prename descclassname">pram.rule.</code><code class="sig-name descname">IterPoint</code><span class="sig-paren">(</span><em class="sig-param">i=0</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.rule.IterPoint" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pram.rule.Iter" title="pram.rule.Iter"><code class="xref py py-class docutils literal notranslate"><span class="pre">pram.rule.Iter</span></code></a></p>
<dl class="attribute">
<dt id="pram.rule.IterPoint.i">
<code class="sig-name descname">i</code><a class="headerlink" href="#pram.rule.IterPoint.i" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pram.rule.JumpProcess">
<em class="property">class </em><code class="sig-prename descclassname">pram.rule.</code><code class="sig-name descname">JumpProcess</code><span class="sig-paren">(</span><em class="sig-param">name='rule'</em>, <em class="sig-param">t=TimeAlways()</em>, <em class="sig-param">i=IterAlways()</em>, <em class="sig-param">name_human=None</em>, <em class="sig-param">memo=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.rule.JumpProcess" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pram.rule.PoissonProcess" title="pram.rule.PoissonProcess"><code class="xref py py-class docutils literal notranslate"><span class="pre">pram.rule.PoissonProcess</span></code></a></p>
<p>A jump process is a type of stochastic process that has discrete movements, called jumps, with random arrival
times, rather than continuous movement, typically modelled as a simple or compound Poisson process.</p>
</dd></dl>

<dl class="class">
<dt id="pram.rule.LevyProcess">
<em class="property">class </em><code class="sig-prename descclassname">pram.rule.</code><code class="sig-name descname">LevyProcess</code><span class="sig-paren">(</span><em class="sig-param">name='rule'</em>, <em class="sig-param">t=TimeAlways()</em>, <em class="sig-param">i=IterAlways()</em>, <em class="sig-param">name_human=None</em>, <em class="sig-param">memo=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.rule.LevyProcess" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pram.rule.MarkovProcess" title="pram.rule.MarkovProcess"><code class="xref py py-class docutils literal notranslate"><span class="pre">pram.rule.MarkovProcess</span></code></a></p>
<p>The continuous-time analog of a random walk.</p>
</dd></dl>

<dl class="class">
<dt id="pram.rule.LogisticMap">
<em class="property">class </em><code class="sig-prename descclassname">pram.rule.</code><code class="sig-name descname">LogisticMap</code><span class="sig-paren">(</span><em class="sig-param">name='rule'</em>, <em class="sig-param">t=TimeAlways()</em>, <em class="sig-param">i=IterAlways()</em>, <em class="sig-param">name_human=None</em>, <em class="sig-param">memo=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.rule.LogisticMap" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pram.rule.Sequence" title="pram.rule.Sequence"><code class="xref py py-class docutils literal notranslate"><span class="pre">pram.rule.Sequence</span></code></a>, <a class="reference internal" href="#pram.rule.ChaoticMap" title="pram.rule.ChaoticMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">pram.rule.ChaoticMap</span></code></a></p>
<blockquote>
<div><p>x_{n+1} = r x_n (1 - x_n),</p>
<p>where $r</p>
</div></blockquote>
<p>[2,4]$ and $x in [0,1]$.</p>
<blockquote>
<div><p>Time domain                : Discrete
Space domain               : Real
Number of space dimensions : 1
Number of parameters       : 1</p>
</div></blockquote>
</dd></dl>

<dl class="class">
<dt id="pram.rule.LorenzSystem">
<em class="property">class </em><code class="sig-prename descclassname">pram.rule.</code><code class="sig-name descname">LorenzSystem</code><span class="sig-paren">(</span><em class="sig-param">fn_deriv</em>, <em class="sig-param">y0</em>, <em class="sig-param">name='ode-system'</em>, <em class="sig-param">t=TimeAlways()</em>, <em class="sig-param">i=IterAlways()</em>, <em class="sig-param">dt=1.0</em>, <em class="sig-param">ni_name='zvode'</em>, <em class="sig-param">f_params=None</em>, <em class="sig-param">jac_params=None</em>, <em class="sig-param">memo=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.rule.LorenzSystem" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pram.rule.ChaoticMap" title="pram.rule.ChaoticMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">pram.rule.ChaoticMap</span></code></a>, <a class="reference internal" href="#pram.rule.ODESystem" title="pram.rule.ODESystem"><code class="xref py py-class docutils literal notranslate"><span class="pre">pram.rule.ODESystem</span></code></a></p>
<p>Atmospheric convection model.</p>
<p>A simplified mathematical model for atmospheric convection specified by the Lorenz equations:</p>
<blockquote>
<div><p>dx/dt = sigma * (y - x)
dy/dt = x * (rho - z) - y
dz/dt = xy - beta * z</p>
</div></blockquote>
<p>The equations relate the properties of a two-dimensional fluid layer uniformly warmed from below and cooled from above.
In particular, the equations describe the rate of change of three quantities with respect to time: x is proportional to
the rate of convection, y to the horizontal temperature variation, and z to the vertical temperature variation. The
constants sigma, rho, and beta are system parameters proportional to the Prandtl number, Rayleigh number, and certain
physical dimensions of the layer itself.</p>
<p>From a technical standpoint, the Lorenz system is nonlinear, non-periodic, three-dimensional and deterministic.</p>
<p>SRC: <a class="reference external" href="https://en.wikipedia.org/wiki/Lorenz_system">https://en.wikipedia.org/wiki/Lorenz_system</a></p>
<p>Time domain                : Continuous
Space domain               : Real
Number of space dimensions : 3
Number of parameters       : 3</p>
</dd></dl>

<dl class="class">
<dt id="pram.rule.LotkaVolterraSystem">
<em class="property">class </em><code class="sig-prename descclassname">pram.rule.</code><code class="sig-name descname">LotkaVolterraSystem</code><span class="sig-paren">(</span><em class="sig-param">fn_deriv</em>, <em class="sig-param">y0</em>, <em class="sig-param">name='ode-system'</em>, <em class="sig-param">t=TimeAlways()</em>, <em class="sig-param">i=IterAlways()</em>, <em class="sig-param">dt=1.0</em>, <em class="sig-param">ni_name='zvode'</em>, <em class="sig-param">f_params=None</em>, <em class="sig-param">jac_params=None</em>, <em class="sig-param">memo=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.rule.LotkaVolterraSystem" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pram.rule.ChaoticMap" title="pram.rule.ChaoticMap"><code class="xref py py-class docutils literal notranslate"><span class="pre">pram.rule.ChaoticMap</span></code></a>, <a class="reference internal" href="#pram.rule.ODESystem" title="pram.rule.ODESystem"><code class="xref py py-class docutils literal notranslate"><span class="pre">pram.rule.ODESystem</span></code></a></p>
<p>Population dynamics model.</p>
<p>a is the natural growth rate of rabbits in the absence of predation,
c is the natural death rate of foxes in the absence of food (rabbits),
b is the death rate per encounter of rabbits due to predation,
e is the efficiency of turning predated rabbits into foxes.</p>
<p>Time domain                : Continuous
Space domain               : Real
Number of space dimensions : 3
Number of parameters       : 4</p>
</dd></dl>

<dl class="class">
<dt id="pram.rule.MarkovChain">
<em class="property">class </em><code class="sig-prename descclassname">pram.rule.</code><code class="sig-name descname">MarkovChain</code><span class="sig-paren">(</span><em class="sig-param">name='rule'</em>, <em class="sig-param">t=TimeAlways()</em>, <em class="sig-param">i=IterAlways()</em>, <em class="sig-param">name_human=None</em>, <em class="sig-param">memo=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.rule.MarkovChain" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pram.rule.MarkovProcess" title="pram.rule.MarkovProcess"><code class="xref py py-class docutils literal notranslate"><span class="pre">pram.rule.MarkovProcess</span></code></a>, <a class="reference internal" href="#pram.rule.ProbabilisticAutomaton" title="pram.rule.ProbabilisticAutomaton"><code class="xref py py-class docutils literal notranslate"><span class="pre">pram.rule.ProbabilisticAutomaton</span></code></a>, <code class="xref py py-class docutils literal notranslate"><span class="pre">abc.ABC</span></code></p>
<p>Markov process with a discrete state space.</p>
</dd></dl>

<dl class="class">
<dt id="pram.rule.MarkovProcess">
<em class="property">class </em><code class="sig-prename descclassname">pram.rule.</code><code class="sig-name descname">MarkovProcess</code><span class="sig-paren">(</span><em class="sig-param">name='rule'</em>, <em class="sig-param">t=TimeAlways()</em>, <em class="sig-param">i=IterAlways()</em>, <em class="sig-param">name_human=None</em>, <em class="sig-param">memo=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.rule.MarkovProcess" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pram.rule.StochasticProcess" title="pram.rule.StochasticProcess"><code class="xref py py-class docutils literal notranslate"><span class="pre">pram.rule.StochasticProcess</span></code></a>, <code class="xref py py-class docutils literal notranslate"><span class="pre">abc.ABC</span></code></p>
<p>A stochastic process that satisfies the Markov property.</p>
</dd></dl>

<dl class="class">
<dt id="pram.rule.Model">
<em class="property">class </em><code class="sig-prename descclassname">pram.rule.</code><code class="sig-name descname">Model</code><span class="sig-paren">(</span><em class="sig-param">name='rule'</em>, <em class="sig-param">t=TimeAlways()</em>, <em class="sig-param">i=IterAlways()</em>, <em class="sig-param">name_human=None</em>, <em class="sig-param">memo=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.rule.Model" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pram.rule.Rule" title="pram.rule.Rule"><code class="xref py py-class docutils literal notranslate"><span class="pre">pram.rule.Rule</span></code></a>, <code class="xref py py-class docutils literal notranslate"><span class="pre">abc.ABC</span></code></p>
</dd></dl>

<dl class="class">
<dt id="pram.rule.Noop">
<em class="property">class </em><code class="sig-prename descclassname">pram.rule.</code><code class="sig-name descname">Noop</code><span class="sig-paren">(</span><em class="sig-param">name='noop'</em>, <em class="sig-param">t=TimeAlways()</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.rule.Noop" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pram.rule.Rule" title="pram.rule.Rule"><code class="xref py py-class docutils literal notranslate"><span class="pre">pram.rule.Rule</span></code></a></p>
<p>NO-OP, i.e., a rule that does not do anything.</p>
<p>Useful for testing simulations that require no rules because at least one rule need to be present in a simulation
in order for groups to be added.</p>
<dl class="method">
<dt id="pram.rule.Noop.apply">
<code class="sig-name descname">apply</code><span class="sig-paren">(</span><em class="sig-param">pop</em>, <em class="sig-param">group</em>, <em class="sig-param">iter</em>, <em class="sig-param">t</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.rule.Noop.apply" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pram.rule.NormalDistributionProcess">
<em class="property">class </em><code class="sig-prename descclassname">pram.rule.</code><code class="sig-name descname">NormalDistributionProcess</code><span class="sig-paren">(</span><em class="sig-param">name='norm-distrib-proc'</em>, <em class="sig-param">t=TimeAlways()</em>, <em class="sig-param">i=IterAlways()</em>, <em class="sig-param">p_max=None</em>, <em class="sig-param">loc=0.0</em>, <em class="sig-param">scale=1.0</em>, <em class="sig-param">label=None</em>, <em class="sig-param">memo=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.rule.NormalDistributionProcess" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pram.rule.DistributionProcess" title="pram.rule.DistributionProcess"><code class="xref py py-class docutils literal notranslate"><span class="pre">pram.rule.DistributionProcess</span></code></a>, <code class="xref py py-class docutils literal notranslate"><span class="pre">abc.ABC</span></code></p>
</dd></dl>

<dl class="class">
<dt id="pram.rule.ODEDerivatives">
<em class="property">class </em><code class="sig-prename descclassname">pram.rule.</code><code class="sig-name descname">ODEDerivatives</code><a class="headerlink" href="#pram.rule.ODEDerivatives" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">abc.ABC</span></code></p>
<dl class="method">
<dt id="pram.rule.ODEDerivatives.get_fn">
<em class="property">abstract </em><code class="sig-name descname">get_fn</code><span class="sig-paren">(</span><em class="sig-param">state</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.rule.ODEDerivatives.get_fn" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.rule.ODEDerivatives.set_params">
<code class="sig-name descname">set_params</code><span class="sig-paren">(</span><em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.rule.ODEDerivatives.set_params" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pram.rule.ODESystem">
<em class="property">class </em><code class="sig-prename descclassname">pram.rule.</code><code class="sig-name descname">ODESystem</code><span class="sig-paren">(</span><em class="sig-param">fn_deriv</em>, <em class="sig-param">y0</em>, <em class="sig-param">name='ode-system'</em>, <em class="sig-param">t=TimeAlways()</em>, <em class="sig-param">i=IterAlways()</em>, <em class="sig-param">dt=1.0</em>, <em class="sig-param">ni_name='zvode'</em>, <em class="sig-param">f_params=None</em>, <em class="sig-param">jac_params=None</em>, <em class="sig-param">memo=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.rule.ODESystem" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pram.rule.Rule" title="pram.rule.Rule"><code class="xref py py-class docutils literal notranslate"><span class="pre">pram.rule.Rule</span></code></a></p>
<p>Wraps a numeric integrator to solve a system of ordinary differential equations (ODEs) that do not interact with
anything else in the simulation.</p>
<p>The non-interactivity stems from the derivatives being kept internally to the integrator only.  This is useful when
computations need to happen on a step-by-step basis, consistent with the rest of the simulation, but the results do
not pollute the group attribute space.</p>
<p>One consequnce of this operationalization is that the rule need to fire only once per iteration.  Because PRAM
fires each rule for every compatible group, the implementation of the present rule ensures that the computation
will only happen exactly once; anything more than that would be computing the same thing again (i.e., an utter
waste of perfectly good CPU time).</p>
<p>Currently uses scipy’s numerical integrators, but could switch to assimulo in the future.</p>
<dl class="simple">
<dt>In</dt><dd><p>f  - derivative-computing function
y0 - initial condition (i.e., a list of values)</p>
</dd>
</dl>
<p>Finite-dimensional linear systems can always be modeled using a set of differential (or difference) equations as
follows:</p>
<blockquote>
<div><dl class="simple">
<dt>d/dt x(t) = A(t) x(t) + B(t) u(t)</dt><dd><p>y(t) = C(t) x(t) + D(t) u(t)</p>
</dd>
</dl>
</div></blockquote>
<p>in continuous time, or the following equivalent equations in discreet time:</p>
<blockquote>
<div><dl class="simple">
<dt>x[k+1] = A[k] x[k] + B[k] u[k]</dt><dd><p>y[k] = C[k] x[k] + D[k] u[k]</p>
</dd>
</dl>
</div></blockquote>
<p>The above equations are called linearized equations or equations of first variation.</p>
<dl class="method">
<dt id="pram.rule.ODESystem.apply">
<code class="sig-name descname">apply</code><span class="sig-paren">(</span><em class="sig-param">pop</em>, <em class="sig-param">group</em>, <em class="sig-param">iter</em>, <em class="sig-param">t</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.rule.ODESystem.apply" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.rule.ODESystem.get_hist">
<code class="sig-name descname">get_hist</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pram.rule.ODESystem.get_hist" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the history of times and derivatives computed at those times.</p>
</dd></dl>

<dl class="method">
<dt id="pram.rule.ODESystem.set_params">
<code class="sig-name descname">set_params</code><span class="sig-paren">(</span><em class="sig-param">fn_deriv</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.rule.ODESystem.set_params" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pram.rule.ODESystemAttr">
<em class="property">class </em><code class="sig-prename descclassname">pram.rule.</code><code class="sig-name descname">ODESystemAttr</code><span class="sig-paren">(</span><em class="sig-param">fn_deriv</em>, <em class="sig-param">y0</em>, <em class="sig-param">name='ode-system'</em>, <em class="sig-param">t=TimeAlways()</em>, <em class="sig-param">i=IterAlways()</em>, <em class="sig-param">dt=1.0</em>, <em class="sig-param">ni_name='zvode'</em>, <em class="sig-param">f_params=None</em>, <em class="sig-param">jac_params=None</em>, <em class="sig-param">memo=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.rule.ODESystemAttr" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pram.rule.Rule" title="pram.rule.Rule"><code class="xref py py-class docutils literal notranslate"><span class="pre">pram.rule.Rule</span></code></a></p>
<p>Wraps a numeric integrator to solve a system of ordinary differential equations (ODEs) and store its state in the
group attribute space.</p>
<p>Currently uses scipy’s numerical integrators, but could switch to assimulo in the future.</p>
<dl class="simple">
<dt>In</dt><dd><p>f  - derivative-computing function
y0 - initial condition attributes (i.e., a list of group attribute names)</p>
</dd>
</dl>
<dl class="method">
<dt id="pram.rule.ODESystemAttr.apply">
<code class="sig-name descname">apply</code><span class="sig-paren">(</span><em class="sig-param">pop</em>, <em class="sig-param">group</em>, <em class="sig-param">iter</em>, <em class="sig-param">t</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.rule.ODESystemAttr.apply" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.rule.ODESystemAttr.get_hist">
<code class="sig-name descname">get_hist</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pram.rule.ODESystemAttr.get_hist" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the history of times and derivatives computed at those times.</p>
</dd></dl>

<dl class="method">
<dt id="pram.rule.ODESystemAttr.is_applicable">
<code class="sig-name descname">is_applicable</code><span class="sig-paren">(</span><em class="sig-param">group</em>, <em class="sig-param">iter</em>, <em class="sig-param">t</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.rule.ODESystemAttr.is_applicable" title="Permalink to this definition">¶</a></dt>
<dd><p>Verifies if the rule is applicable to the group at the current iteration and current time.</p>
</dd></dl>

<dl class="method">
<dt id="pram.rule.ODESystemAttr.set_params">
<code class="sig-name descname">set_params</code><span class="sig-paren">(</span><em class="sig-param">fn_deriv</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.rule.ODESystemAttr.set_params" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pram.rule.ODESystemMass">
<em class="property">class </em><code class="sig-prename descclassname">pram.rule.</code><code class="sig-name descname">ODESystemMass</code><span class="sig-paren">(</span><em class="sig-param">derivatives</em>, <em class="sig-param">queries</em>, <em class="sig-param">name='ode-system-mass'</em>, <em class="sig-param">t=TimeAlways()</em>, <em class="sig-param">i=IterAlways()</em>, <em class="sig-param">dt=1.0</em>, <em class="sig-param">ni_name='zvode'</em>, <em class="sig-param">f_params=None</em>, <em class="sig-param">jac_params=None</em>, <em class="sig-param">memo=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.rule.ODESystemMass" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pram.rule.Rule" title="pram.rule.Rule"><code class="xref py py-class docutils literal notranslate"><span class="pre">pram.rule.Rule</span></code></a></p>
<p>Wraps a numeric integrator to solve a system of ordinary differential equations (ODEs) that drive mass shifts.</p>
<p>The initial state is deterimed by the group landscape.</p>
<p>The rule splits the congruent group (i.e., the one meeting the search criteria) into the number of parts that
corresponds to the number of ODEs.  Even though it might seem like different groups should be split differently,
this solution is correct and stems from the fact that the new group sizes are calculated for the iteration step
(i.e., for all groups) and not for individual group.</p>
<p>Currently uses scipy’s numerical integrators, but could switch to assimulo in the future.</p>
<dl class="simple">
<dt>In</dt><dd><p>f  - derivative-computing function
y0 - initial condition (i.e., a list of group attribute names)</p>
</dd>
</dl>
<dl class="method">
<dt id="pram.rule.ODESystemMass.apply">
<code class="sig-name descname">apply</code><span class="sig-paren">(</span><em class="sig-param">pop</em>, <em class="sig-param">group</em>, <em class="sig-param">iter</em>, <em class="sig-param">t</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.rule.ODESystemMass.apply" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.rule.ODESystemMass.get_hist">
<code class="sig-name descname">get_hist</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pram.rule.ODESystemMass.get_hist" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the history of times and derivatives computed at those times.</p>
</dd></dl>

<dl class="method">
<dt id="pram.rule.ODESystemMass.set_params">
<code class="sig-name descname">set_params</code><span class="sig-paren">(</span><em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.rule.ODESystemMass.set_params" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pram.rule.ODeltaESystem">
<em class="property">class </em><code class="sig-prename descclassname">pram.rule.</code><code class="sig-name descname">ODeltaESystem</code><span class="sig-paren">(</span><em class="sig-param">name='rule'</em>, <em class="sig-param">t=TimeAlways()</em>, <em class="sig-param">i=IterAlways()</em>, <em class="sig-param">name_human=None</em>, <em class="sig-param">memo=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.rule.ODeltaESystem" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pram.rule.Rule" title="pram.rule.Rule"><code class="xref py py-class docutils literal notranslate"><span class="pre">pram.rule.Rule</span></code></a></p>
</dd></dl>

<dl class="class">
<dt id="pram.rule.OneDecayProcess">
<em class="property">class </em><code class="sig-prename descclassname">pram.rule.</code><code class="sig-name descname">OneDecayProcess</code><span class="sig-paren">(</span><em class="sig-param">name='rule'</em>, <em class="sig-param">t=TimeAlways()</em>, <em class="sig-param">i=IterAlways()</em>, <em class="sig-param">name_human=None</em>, <em class="sig-param">memo=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.rule.OneDecayProcess" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pram.rule.Rule" title="pram.rule.Rule"><code class="xref py py-class docutils literal notranslate"><span class="pre">pram.rule.Rule</span></code></a></p>
<p>Radioactive one-decay process.</p>
<p>N(t) = N_0 e^{-lambda t}</p>
</dd></dl>

<dl class="class">
<dt id="pram.rule.OrnsteinUhlenbeckProcess">
<em class="property">class </em><code class="sig-prename descclassname">pram.rule.</code><code class="sig-name descname">OrnsteinUhlenbeckProcess</code><span class="sig-paren">(</span><em class="sig-param">name='rule'</em>, <em class="sig-param">t=TimeAlways()</em>, <em class="sig-param">i=IterAlways()</em>, <em class="sig-param">name_human=None</em>, <em class="sig-param">memo=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.rule.OrnsteinUhlenbeckProcess" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pram.rule.LevyProcess" title="pram.rule.LevyProcess"><code class="xref py py-class docutils literal notranslate"><span class="pre">pram.rule.LevyProcess</span></code></a>, <a class="reference internal" href="#pram.rule.DiffusionProcess" title="pram.rule.DiffusionProcess"><code class="xref py py-class docutils literal notranslate"><span class="pre">pram.rule.DiffusionProcess</span></code></a></p>
<p>A stationary Gauss–Markov mean-reverting process.</p>
</dd></dl>

<dl class="class">
<dt id="pram.rule.Perturbation">
<em class="property">class </em><code class="sig-prename descclassname">pram.rule.</code><code class="sig-name descname">Perturbation</code><span class="sig-paren">(</span><em class="sig-param">name='rule'</em>, <em class="sig-param">t=TimeAlways()</em>, <em class="sig-param">i=IterAlways()</em>, <em class="sig-param">name_human=None</em>, <em class="sig-param">memo=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.rule.Perturbation" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pram.rule.Rule" title="pram.rule.Rule"><code class="xref py py-class docutils literal notranslate"><span class="pre">pram.rule.Rule</span></code></a>, <code class="xref py py-class docutils literal notranslate"><span class="pre">abc.ABC</span></code></p>
</dd></dl>

<dl class="class">
<dt id="pram.rule.PoissonIncidenceProcess">
<em class="property">class </em><code class="sig-prename descclassname">pram.rule.</code><code class="sig-name descname">PoissonIncidenceProcess</code><span class="sig-paren">(</span><em class="sig-param">attr</em>, <em class="sig-param">age_0</em>, <em class="sig-param">rate_0</em>, <em class="sig-param">delta</em>, <em class="sig-param">delta_t</em>, <em class="sig-param">rate_delta_mode=&lt;RateDeltaMode.NC: 1&gt;</em>, <em class="sig-param">fn_calc_lambda=None</em>, <em class="sig-param">is_smooth=True</em>, <em class="sig-param">name='change-incidence'</em>, <em class="sig-param">t=TimeAlways()</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.rule.PoissonIncidenceProcess" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pram.rule.PoissonProcess" title="pram.rule.PoissonProcess"><code class="xref py py-class docutils literal notranslate"><span class="pre">pram.rule.PoissonProcess</span></code></a></p>
<p>Homogenous and inhomogenous Poisson point process for disease incidence.</p>
<p>The non-homogeneity of the Poisson process is handled by allowing the user to specify how the rate (i.e., the
$lambda$ parameter) of the process changes over time.  The change to that rate is given as the combination of a
delta on it and the number of iterations for that delta to take place.  The rate parameter is allowed to change
gradually (i.e., at every step of the simulation) or in strict increments (e.g., only every 10 iterations) and is
controlled by the ‘inc_smooth’ parameter.</p>
<p>The rate can change in the following ways (as determined by the ‘rate_delta_mode’ parameter which takes values of
the ‘RateDeltaMode’ enumeration):</p>
<ul class="simple">
<li><p>NC   No change (i.e., the Poisson process is stationary)</p></li>
<li><p>ADD  Additive</p></li>
<li><p>MUL  Multiplicative</p></li>
<li><p>EXP  Exponential</p></li>
<li><p>FN   User-provided lambda function called at every iteration</p></li>
</ul>
<p>A Cox process, also known as a doubly stochastic Poisson process is a point process which is a generalization of a
Poisson process where the time-dependent intensity is itself a stochastic process.  The Cox process can be
implemented by passing as an argument a function which will be called at every iteration to determine the current
Poisson rate.  ‘rate_delta_mode=RateDeltaMode.FN’ must be used in that case.</p>
<p>An example model given as “AD incidence doubles every five years after 65 yo” can be instantiated by using the
delta of two and the number of iterations of five.</p>
<p>Epidemiology of Alzheimer’s disease and other forms of dementia in China, 1990-2010: a systematic review and analysis.
<a class="reference external" href="https://www.thelancet.com/action/showPdf?pii=S0140-6736%2813%2960221-4">https://www.thelancet.com/action/showPdf?pii=S0140-6736%2813%2960221-4</a></p>
<p>SRC: <a class="reference external" href="https://en.wikipedia.org/wiki/Incidence_(epidemiology">https://en.wikipedia.org/wiki/Incidence_(epidemiology</a>); retrieved on 2019.06.05</p>
<p>Incidence in epidemiology is a measure of the probability of occurrence of a given medical condition in a
population within a specified period of time. Although sometimes loosely expressed simply as the number of new
cases during some time period, it is better expressed as a proportion or a rate[1] with a denominator.</p>
<p>Incidence proportion (also known as cumulative incidence) is the number of new cases within a specified time period
divided by the size of the population initially at risk. For example, if a population initially contains 1,000
non-diseased persons and 28 develop a condition over two years of observation, the incidence proportion is 28 cases
per 1,000 persons per two years, i.e. 2.8% per two years.</p>
<p>(…)</p>
<p>Incidence should not be confused with prevalence, which is the proportion of cases in the population at a given
time rather than rate of occurrence of new cases. Thus, incidence conveys information about the risk of contracting
the disease, whereas prevalence indicates how widespread the disease is. Prevalence is the proportion of the total
number of cases to the total population and is more a measure of the burden of the disease on society with no
regard to time at risk or when subjects may have been exposed to a possible risk factor. Prevalence can also be
measured with respect to a specific subgroup of a population (see: denominator data). Incidence is usually more
useful than prevalence in understanding the disease etiology: for example, if the incidence rate of a disease in a
population increases, then there is a risk factor that promotes the incidence.</p>
<p>For example, consider a disease that takes a long time to cure and was widespread in 2002 but dissipated in 2003.
This disease will have both high incidence and high prevalence in 2002, but in 2003 it will have a low incidence
yet will continue to have a high prevalence (because it takes a long time to cure, so the fraction of individuals
that are affected remains high). In contrast, a disease that has a short duration may have a low prevalence and a
high incidence. When the incidence is approximately constant for the duration of the disease, prevalence is
approximately the product of disease incidence and average disease duration, so prevalence = incidence × duration.
The importance of this equation is in the relation between prevalence and incidence; for example, when the
incidence increases, then the prevalence must also increase. Note that this relation does not hold for age-specific
prevalence and incidence, where the relation becomes more complicated.[6]</p>
<p>(…)</p>
<p>—-[ Notation A ]—-</p>
<dl>
<dt>code:</dt><dd><p>PoissonIncidenceProcess(‘ad’, 65, 0.01, 2, 5, rate_delta_mode=PoissonIncidenceProcess.RateDeltaMode.EXP))</p>
</dd>
<dt>init:</dt><dd><p>age_0=65, l_0=0.01, c=2, t_c=5</p>
</dd>
<dt>is-applicable:</dt><dd><p>has-attr: age, ad</p>
</dd>
<dt>apply:</dt><dd><dl>
<dt>if (group.attr.age &gt;= age_0):</dt><dd><p>l = double_rate(l)        # l0 * c^{(group.attr.age - age_0) / t_c}
p_0 = PoissonPMF(l,0)  # …
move-mass:</p>
<blockquote>
<div><blockquote>
<div><p>p_0 -&gt; A:age = group.attr.age + 1</p>
</div></blockquote>
<p>1 - p_0 -&gt; A:age = group.attr.age + 1, A:ad = True</p>
</div></blockquote>
</dd>
</dl>
</dd>
</dl>
<p>—-[ Notation B ]—-</p>
<dl class="simple">
<dt>(group.attr.age &gt;= age_0)</dt><dd><p>l = double_rate(l)        # l0 * c^{(group.attr.age - age_0) / t_c}
p_0 = PoissonPMF(l,0)
p_0     -&gt; A:age = group.attr.age + 1
1 - p_0 -&gt; A:age = group.attr.age + 1, A:ad = True</p>
</dd>
</dl>
<p>—-[ Scratchpad ]—-</p>
<p>mu = e^(lambda * x)
log(mu) = lambda * x</p>
<p>log(mu/t) = lambda * x
log(mu/t) = lambda * x
log(mu) - log(t) = lambda * x
log(mu) = lambda * x + log(t)</p>
<p>log(incidence) = lambda * x + log(age - age_0)</p>
<dl class="class">
<dt id="pram.rule.PoissonIncidenceProcess.RateDeltaMode">
<em class="property">class </em><code class="sig-name descname">RateDeltaMode</code><a class="headerlink" href="#pram.rule.PoissonIncidenceProcess.RateDeltaMode" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">enum.IntEnum</span></code></p>
<p>An enumeration.</p>
<dl class="attribute">
<dt id="pram.rule.PoissonIncidenceProcess.RateDeltaMode.ADD">
<code class="sig-name descname">ADD</code><em class="property"> = 2</em><a class="headerlink" href="#pram.rule.PoissonIncidenceProcess.RateDeltaMode.ADD" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pram.rule.PoissonIncidenceProcess.RateDeltaMode.EXP">
<code class="sig-name descname">EXP</code><em class="property"> = 4</em><a class="headerlink" href="#pram.rule.PoissonIncidenceProcess.RateDeltaMode.EXP" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pram.rule.PoissonIncidenceProcess.RateDeltaMode.FN">
<code class="sig-name descname">FN</code><em class="property"> = 5</em><a class="headerlink" href="#pram.rule.PoissonIncidenceProcess.RateDeltaMode.FN" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pram.rule.PoissonIncidenceProcess.RateDeltaMode.MUL">
<code class="sig-name descname">MUL</code><em class="property"> = 3</em><a class="headerlink" href="#pram.rule.PoissonIncidenceProcess.RateDeltaMode.MUL" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pram.rule.PoissonIncidenceProcess.RateDeltaMode.NC">
<code class="sig-name descname">NC</code><em class="property"> = 1</em><a class="headerlink" href="#pram.rule.PoissonIncidenceProcess.RateDeltaMode.NC" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="method">
<dt id="pram.rule.PoissonIncidenceProcess.apply">
<code class="sig-name descname">apply</code><span class="sig-paren">(</span><em class="sig-param">pop</em>, <em class="sig-param">group</em>, <em class="sig-param">iter</em>, <em class="sig-param">t</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.rule.PoissonIncidenceProcess.apply" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.rule.PoissonIncidenceProcess.calc_lambda_add">
<code class="sig-name descname">calc_lambda_add</code><span class="sig-paren">(</span><em class="sig-param">age</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.rule.PoissonIncidenceProcess.calc_lambda_add" title="Permalink to this definition">¶</a></dt>
<dd><p>Additive rate change.</p>
</dd></dl>

<dl class="method">
<dt id="pram.rule.PoissonIncidenceProcess.calc_lambda_exp">
<code class="sig-name descname">calc_lambda_exp</code><span class="sig-paren">(</span><em class="sig-param">age</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.rule.PoissonIncidenceProcess.calc_lambda_exp" title="Permalink to this definition">¶</a></dt>
<dd><p>Exponential rate change.</p>
</dd></dl>

<dl class="method">
<dt id="pram.rule.PoissonIncidenceProcess.calc_lambda_hmm">
<code class="sig-name descname">calc_lambda_hmm</code><span class="sig-paren">(</span><em class="sig-param">age</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.rule.PoissonIncidenceProcess.calc_lambda_hmm" title="Permalink to this definition">¶</a></dt>
<dd><p>Poisson hidden Markov models (PHMM) are special cases of hidden Markov models where a Poisson process has a
rate which varies in association with changes between the different states of a Markov model.</p>
</dd></dl>

<dl class="method">
<dt id="pram.rule.PoissonIncidenceProcess.calc_lambda_mul">
<code class="sig-name descname">calc_lambda_mul</code><span class="sig-paren">(</span><em class="sig-param">age</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.rule.PoissonIncidenceProcess.calc_lambda_mul" title="Permalink to this definition">¶</a></dt>
<dd><p>Multiplicative rate change.</p>
</dd></dl>

<dl class="method">
<dt id="pram.rule.PoissonIncidenceProcess.calc_lambda_nc">
<code class="sig-name descname">calc_lambda_nc</code><span class="sig-paren">(</span><em class="sig-param">age</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.rule.PoissonIncidenceProcess.calc_lambda_nc" title="Permalink to this definition">¶</a></dt>
<dd><p>No rate change (i.e., a stationary Poisson point process).</p>
</dd></dl>

<dl class="method">
<dt id="pram.rule.PoissonIncidenceProcess.get_split_specs">
<code class="sig-name descname">get_split_specs</code><span class="sig-paren">(</span><em class="sig-param">group</em>, <em class="sig-param">age_inc=1</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.rule.PoissonIncidenceProcess.get_split_specs" title="Permalink to this definition">¶</a></dt>
<dd><p>age_inc - how much to increment the ‘age’ attribute</p>
</dd></dl>

<dl class="method">
<dt id="pram.rule.PoissonIncidenceProcess.is_applicable">
<code class="sig-name descname">is_applicable</code><span class="sig-paren">(</span><em class="sig-param">group</em>, <em class="sig-param">iter</em>, <em class="sig-param">t</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.rule.PoissonIncidenceProcess.is_applicable" title="Permalink to this definition">¶</a></dt>
<dd><p>Verifies if the rule is applicable to the group at the current iteration and current time.</p>
</dd></dl>

<dl class="method">
<dt id="pram.rule.PoissonIncidenceProcess.setup">
<code class="sig-name descname">setup</code><span class="sig-paren">(</span><em class="sig-param">pop</em>, <em class="sig-param">group</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.rule.PoissonIncidenceProcess.setup" title="Permalink to this definition">¶</a></dt>
<dd><p>A rule’s setup place.  If the rule relies on groups having a certain set of attributes and relations, this is
where they should be set.  For example, a rule might set an attribute of all the groups like so:</p>
<blockquote>
<div><p>return [GroupSplitSpec(p=1.0, attr_set={ ‘did-attend-school-today’: False })]</p>
</div></blockquote>
<p>This reuses the group splitting mechanism; here, each group will be split into a (possibly non-extant) new
group and the entirety of the group’s mass will be moved into that new group.</p>
<p>This is also where a rule should do any other population initialization required.  For example, a rule that may
introduce a new Site object to the simulation, should make the population object aware of that site like so:</p>
<blockquote>
<div><p>pop.add_site(Site(‘new-site’))</p>
</div></blockquote>
<p>Every rule’s setup() method is called only once by Simulation.run() method before a simulation run commences.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pram.rule.PoissonProcess">
<em class="property">class </em><code class="sig-prename descclassname">pram.rule.</code><code class="sig-name descname">PoissonProcess</code><span class="sig-paren">(</span><em class="sig-param">name='rule'</em>, <em class="sig-param">t=TimeAlways()</em>, <em class="sig-param">i=IterAlways()</em>, <em class="sig-param">name_human=None</em>, <em class="sig-param">memo=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.rule.PoissonProcess" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pram.rule.LevyProcess" title="pram.rule.LevyProcess"><code class="xref py py-class docutils literal notranslate"><span class="pre">pram.rule.LevyProcess</span></code></a></p>
<p>Poisson point process.</p>
<p>Markov processes in continuous time.</p>
<p>On the real line, the Poisson process is a type of continuous-time Markov process known as a birth-death process
(with just births and zero deaths) and is called a pure [67] or simple birth process.[68] More complicated
processes with the Markov property, such as Markov arrival processes, have been defined where the Poisson process
is a special case.[54]
[<a class="reference external" href="https://en.wikipedia.org/wiki/Poisson_point_process">https://en.wikipedia.org/wiki/Poisson_point_process</a>]</p>
</dd></dl>

<dl class="class">
<dt id="pram.rule.ProbabilisticAutomaton">
<em class="property">class </em><code class="sig-prename descclassname">pram.rule.</code><code class="sig-name descname">ProbabilisticAutomaton</code><span class="sig-paren">(</span><em class="sig-param">name='rule'</em>, <em class="sig-param">t=TimeAlways()</em>, <em class="sig-param">i=IterAlways()</em>, <em class="sig-param">name_human=None</em>, <em class="sig-param">memo=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.rule.ProbabilisticAutomaton" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pram.rule.Rule" title="pram.rule.Rule"><code class="xref py py-class docutils literal notranslate"><span class="pre">pram.rule.Rule</span></code></a>, <code class="xref py py-class docutils literal notranslate"><span class="pre">abc.ABC</span></code></p>
<p>Probabilistic automaton.</p>
</dd></dl>

<dl class="class">
<dt id="pram.rule.ProbabilisticEquation">
<em class="property">class </em><code class="sig-prename descclassname">pram.rule.</code><code class="sig-name descname">ProbabilisticEquation</code><span class="sig-paren">(</span><em class="sig-param">name='rule'</em>, <em class="sig-param">t=TimeAlways()</em>, <em class="sig-param">i=IterAlways()</em>, <em class="sig-param">name_human=None</em>, <em class="sig-param">memo=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.rule.ProbabilisticEquation" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pram.rule.Equation" title="pram.rule.Equation"><code class="xref py py-class docutils literal notranslate"><span class="pre">pram.rule.Equation</span></code></a></p>
<p>An algebraic equation p(t), where $p(t) in [0,1]$ (i.e., it yields a probability).</p>
</dd></dl>

<dl class="class">
<dt id="pram.rule.Process">
<em class="property">class </em><code class="sig-prename descclassname">pram.rule.</code><code class="sig-name descname">Process</code><span class="sig-paren">(</span><em class="sig-param">name='rule'</em>, <em class="sig-param">t=TimeAlways()</em>, <em class="sig-param">i=IterAlways()</em>, <em class="sig-param">name_human=None</em>, <em class="sig-param">memo=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.rule.Process" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pram.rule.Rule" title="pram.rule.Rule"><code class="xref py py-class docutils literal notranslate"><span class="pre">pram.rule.Rule</span></code></a>, <code class="xref py py-class docutils literal notranslate"><span class="pre">abc.ABC</span></code></p>
</dd></dl>

<dl class="class">
<dt id="pram.rule.RandomWalk">
<em class="property">class </em><code class="sig-prename descclassname">pram.rule.</code><code class="sig-name descname">RandomWalk</code><span class="sig-paren">(</span><em class="sig-param">var</em>, <em class="sig-param">tm</em>, <em class="sig-param">name='markov-chain'</em>, <em class="sig-param">t=TimeAlways()</em>, <em class="sig-param">i=IterAlways()</em>, <em class="sig-param">memo=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.rule.RandomWalk" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pram.rule.DiscreteInvMarkovChain" title="pram.rule.DiscreteInvMarkovChain"><code class="xref py py-class docutils literal notranslate"><span class="pre">pram.rule.DiscreteInvMarkovChain</span></code></a></p>
<p>Markov processes in discreet time.</p>
<p>The results of discretizing both time and space of a diffusion equation.</p>
</dd></dl>

<dl class="class">
<dt id="pram.rule.ResetRule">
<em class="property">class </em><code class="sig-prename descclassname">pram.rule.</code><code class="sig-name descname">ResetRule</code><span class="sig-paren">(</span><em class="sig-param">t=5</em>, <em class="sig-param">i=None</em>, <em class="sig-param">attr_del=None</em>, <em class="sig-param">attr_set=None</em>, <em class="sig-param">rel_del=None</em>, <em class="sig-param">rel_set=None</em>, <em class="sig-param">name_human=None</em>, <em class="sig-param">memo=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.rule.ResetRule" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pram.rule.Rule" title="pram.rule.Rule"><code class="xref py py-class docutils literal notranslate"><span class="pre">pram.rule.Rule</span></code></a></p>
<dl class="attribute">
<dt id="pram.rule.ResetRule.NAME">
<code class="sig-name descname">NAME</code><em class="property"> = 'Reset'</em><a class="headerlink" href="#pram.rule.ResetRule.NAME" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.rule.ResetRule.apply">
<code class="sig-name descname">apply</code><span class="sig-paren">(</span><em class="sig-param">pop</em>, <em class="sig-param">group</em>, <em class="sig-param">iter</em>, <em class="sig-param">t</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.rule.ResetRule.apply" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pram.rule.ResetSchoolDayRule">
<em class="property">class </em><code class="sig-prename descclassname">pram.rule.</code><code class="sig-name descname">ResetSchoolDayRule</code><span class="sig-paren">(</span><em class="sig-param">t=5, i=None, attr_del=['t-at-school'], attr_set=None, rel_del=None, rel_set=None, name_human=None, memo=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.rule.ResetSchoolDayRule" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pram.rule.ResetRule" title="pram.rule.ResetRule"><code class="xref py py-class docutils literal notranslate"><span class="pre">pram.rule.ResetRule</span></code></a></p>
<dl class="attribute">
<dt id="pram.rule.ResetSchoolDayRule.NAME">
<code class="sig-name descname">NAME</code><em class="property"> = 'Reset school day'</em><a class="headerlink" href="#pram.rule.ResetSchoolDayRule.NAME" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.rule.ResetSchoolDayRule.is_applicable">
<code class="sig-name descname">is_applicable</code><span class="sig-paren">(</span><em class="sig-param">group</em>, <em class="sig-param">iter</em>, <em class="sig-param">t</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.rule.ResetSchoolDayRule.is_applicable" title="Permalink to this definition">¶</a></dt>
<dd><p>Verifies if the rule is applicable to the group at the current iteration and current time.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pram.rule.ResetWorkDayRule">
<em class="property">class </em><code class="sig-prename descclassname">pram.rule.</code><code class="sig-name descname">ResetWorkDayRule</code><span class="sig-paren">(</span><em class="sig-param">t=5</em>, <em class="sig-param">i=None</em>, <em class="sig-param">attr_del=None</em>, <em class="sig-param">attr_set=None</em>, <em class="sig-param">rel_del=None</em>, <em class="sig-param">rel_set=None</em>, <em class="sig-param">name_human=None</em>, <em class="sig-param">memo=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.rule.ResetWorkDayRule" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pram.rule.ResetRule" title="pram.rule.ResetRule"><code class="xref py py-class docutils literal notranslate"><span class="pre">pram.rule.ResetRule</span></code></a></p>
<dl class="attribute">
<dt id="pram.rule.ResetWorkDayRule.NAME">
<code class="sig-name descname">NAME</code><em class="property"> = 'Reset work day'</em><a class="headerlink" href="#pram.rule.ResetWorkDayRule.NAME" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.rule.ResetWorkDayRule.is_applicable">
<code class="sig-name descname">is_applicable</code><span class="sig-paren">(</span><em class="sig-param">group</em>, <em class="sig-param">iter</em>, <em class="sig-param">t</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.rule.ResetWorkDayRule.is_applicable" title="Permalink to this definition">¶</a></dt>
<dd><p>Verifies if the rule is applicable to the group at the current iteration and current time.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pram.rule.Rule">
<em class="property">class </em><code class="sig-prename descclassname">pram.rule.</code><code class="sig-name descname">Rule</code><span class="sig-paren">(</span><em class="sig-param">name='rule'</em>, <em class="sig-param">t=TimeAlways()</em>, <em class="sig-param">i=IterAlways()</em>, <em class="sig-param">name_human=None</em>, <em class="sig-param">memo=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.rule.Rule" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">abc.ABC</span></code></p>
<p>A rule that can be applied to a group and may augment that group or split it into multiple subgroups.</p>
<p>A rule will be applied if the simulation timer’s time (external to this class) falls within the range defined by
the time specification ‘t’.  Every time a rule is applied, it is applied to all groups it is compatible with.  For
instance, a rule that renders a portion of a group infection-free (i.e., marks it as recovered) can be applied to a
group of humans currently infected with some infectious disease.  The same rule, however, would not be applied to
a group of city buses.  Each rule knows how to recognize a compatible group.</p>
<dl class="attribute">
<dt id="pram.rule.Rule.ATTRS">
<code class="sig-name descname">ATTRS</code><em class="property"> = {}</em><a class="headerlink" href="#pram.rule.Rule.ATTRS" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pram.rule.Rule.NAME">
<code class="sig-name descname">NAME</code><em class="property"> = 'Rule'</em><a class="headerlink" href="#pram.rule.Rule.NAME" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pram.rule.Rule.T_UNIT_MS">
<code class="sig-name descname">T_UNIT_MS</code><em class="property"> = 3600000</em><a class="headerlink" href="#pram.rule.Rule.T_UNIT_MS" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.rule.Rule.apply">
<em class="property">abstract </em><code class="sig-name descname">apply</code><span class="sig-paren">(</span><em class="sig-param">pop</em>, <em class="sig-param">group</em>, <em class="sig-param">iter</em>, <em class="sig-param">t</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.rule.Rule.apply" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.rule.Rule.cleanup">
<code class="sig-name descname">cleanup</code><span class="sig-paren">(</span><em class="sig-param">pop</em>, <em class="sig-param">group</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.rule.Rule.cleanup" title="Permalink to this definition">¶</a></dt>
<dd><p>Run once at the end of a simulation run.  Symmetrical to the setup() method.  Also uses the group-Splitting
mechanism.</p>
</dd></dl>

<dl class="attribute">
<dt id="pram.rule.Rule.compile_spec">
<code class="sig-name descname">compile_spec</code><em class="property"> = None</em><a class="headerlink" href="#pram.rule.Rule.compile_spec" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.rule.Rule.get_inner_rules">
<code class="sig-name descname">get_inner_rules</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pram.rule.Rule.get_inner_rules" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.rule.Rule.get_rand_name">
<em class="property">static </em><code class="sig-name descname">get_rand_name</code><span class="sig-paren">(</span><em class="sig-param">name</em>, <em class="sig-param">prefix='__'</em>, <em class="sig-param">rand_len=12</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.rule.Rule.get_rand_name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.rule.Rule.is_applicable">
<code class="sig-name descname">is_applicable</code><span class="sig-paren">(</span><em class="sig-param">group</em>, <em class="sig-param">iter</em>, <em class="sig-param">t</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.rule.Rule.is_applicable" title="Permalink to this definition">¶</a></dt>
<dd><p>Verifies if the rule is applicable to the group at the current iteration and current time.</p>
</dd></dl>

<dl class="attribute">
<dt id="pram.rule.Rule.pop">
<code class="sig-name descname">pop</code><em class="property"> = None</em><a class="headerlink" href="#pram.rule.Rule.pop" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.rule.Rule.set_params">
<code class="sig-name descname">set_params</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pram.rule.Rule.set_params" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.rule.Rule.set_t_unit">
<code class="sig-name descname">set_t_unit</code><span class="sig-paren">(</span><em class="sig-param">ms</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.rule.Rule.set_t_unit" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.rule.Rule.setup">
<code class="sig-name descname">setup</code><span class="sig-paren">(</span><em class="sig-param">pop</em>, <em class="sig-param">group</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.rule.Rule.setup" title="Permalink to this definition">¶</a></dt>
<dd><p>A rule’s setup place.  If the rule relies on groups having a certain set of attributes and relations, this is
where they should be set.  For example, a rule might set an attribute of all the groups like so:</p>
<blockquote>
<div><p>return [GroupSplitSpec(p=1.0, attr_set={ ‘did-attend-school-today’: False })]</p>
</div></blockquote>
<p>This reuses the group splitting mechanism; here, each group will be split into a (possibly non-extant) new
group and the entirety of the group’s mass will be moved into that new group.</p>
<p>This is also where a rule should do any other population initialization required.  For example, a rule that may
introduce a new Site object to the simulation, should make the population object aware of that site like so:</p>
<blockquote>
<div><p>pop.add_site(Site(‘new-site’))</p>
</div></blockquote>
<p>Every rule’s setup() method is called only once by Simulation.run() method before a simulation run commences.</p>
</dd></dl>

<dl class="method">
<dt id="pram.rule.Rule.tp2rv">
<em class="property">static </em><code class="sig-name descname">tp2rv</code><span class="sig-paren">(</span><em class="sig-param">tp</em>, <em class="sig-param">a=0</em>, <em class="sig-param">b=23</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.rule.Rule.tp2rv" title="Permalink to this definition">¶</a></dt>
<dd><p>Converts a time probability distribution function (PDF) to a discrete random variable.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pram.rule.RuleAnalyzerTestRule">
<em class="property">class </em><code class="sig-prename descclassname">pram.rule.</code><code class="sig-name descname">RuleAnalyzerTestRule</code><span class="sig-paren">(</span><em class="sig-param">t=[8, 20], i=None, name_human=None, memo=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.rule.RuleAnalyzerTestRule" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pram.rule.Rule" title="pram.rule.Rule"><code class="xref py py-class docutils literal notranslate"><span class="pre">pram.rule.Rule</span></code></a></p>
<dl class="attribute">
<dt id="pram.rule.RuleAnalyzerTestRule.NAME">
<code class="sig-name descname">NAME</code><em class="property"> = 'Rule analyzer test'</em><a class="headerlink" href="#pram.rule.RuleAnalyzerTestRule.NAME" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.rule.RuleAnalyzerTestRule.an">
<code class="sig-name descname">an</code><span class="sig-paren">(</span><em class="sig-param">s</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.rule.RuleAnalyzerTestRule.an" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.rule.RuleAnalyzerTestRule.apply">
<code class="sig-name descname">apply</code><span class="sig-paren">(</span><em class="sig-param">group</em>, <em class="sig-param">iter</em>, <em class="sig-param">t</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.rule.RuleAnalyzerTestRule.apply" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.rule.RuleAnalyzerTestRule.is_applicable">
<code class="sig-name descname">is_applicable</code><span class="sig-paren">(</span><em class="sig-param">group</em>, <em class="sig-param">iter</em>, <em class="sig-param">t</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.rule.RuleAnalyzerTestRule.is_applicable" title="Permalink to this definition">¶</a></dt>
<dd><p>Verifies if the rule is applicable to the group at the current iteration and current time.</p>
</dd></dl>

<dl class="method">
<dt id="pram.rule.RuleAnalyzerTestRule.rn">
<code class="sig-name descname">rn</code><span class="sig-paren">(</span><em class="sig-param">s</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.rule.RuleAnalyzerTestRule.rn" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pram.rule.SEIRFluModel">
<em class="property">class </em><code class="sig-prename descclassname">pram.rule.</code><code class="sig-name descname">SEIRFluModel</code><span class="sig-paren">(</span><em class="sig-param">t=TimeAlways()</em>, <em class="sig-param">susceptibility=1.0</em>, <em class="sig-param">p_start_E=0.05</em>, <em class="sig-param">do_clean=True</em>, <em class="sig-param">name_human=None</em>, <em class="sig-param">memo=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.rule.SEIRFluModel" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pram.rule.SEIRModel" title="pram.rule.SEIRModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">pram.rule.SEIRModel</span></code></a></p>
<p>The SEIR model for the influenza.</p>
<dl class="simple">
<dt>Disease states (SEIR)</dt><dd><p>S  Susceptible
E  Exposed (i.e., incubation period)
IS Infectious &amp; Symptomatic (can infect other agents)
IA Infectious &amp; Asymptomatic (can infect other agents)
R  Recovered</p>
</dd>
<dt>State transition probability</dt><dd><p>S  –&gt; E   1.00
E  –&gt; IS  0.67
E  –&gt; IA  0.33
IS –&gt; R   1.00
IA –&gt; R   1.00</p>
</dd>
<dt>State transition timing</dt><dd><p>S      Until E (either by another agent or on import)
E      Median = 1.9, dispersion = 1.23 days (M= 45.60, d=29.52 hours)
IS/IA  Median = 5.0, dispersion = 1.50 days (M=120.00, d=36.00 hours)
R      Indefinite</p>
</dd>
<dt>Probability of staying home</dt><dd><p>IS/IA  0.50</p>
</dd>
<dt>Time periods</dt><dd><dl class="simple">
<dt>Drawn from a log-normal distribution</dt><dd><p>median = exp(mean)</p>
</dd>
<dt>Dispersion is equivalent to the standard deviation, but with range of [median/dispersion, median*dispersion]</dt><dd><p>E      [1.54, 2.34] days ([36.96,  56.16] hours)
IS/IA  [3.33, 7.50] days ([79.92, 180.00] hours)</p>
</dd>
</dl>
</dd>
</dl>
<p>The median and dispersion of the lognormal distribution are typically how incubation periods and symptoms are
reported in the literature (e.g., Lessler, 2009).  They are translated into to the parameters of the lognormal
distribution using the formulas:</p>
<blockquote>
<div><p>location = log(median)
scale = 0.5 * log(dispersion)</p>
</div></blockquote>
<p>We can expect that about 95% of the draws from this lognormal distribution will fall between (median / dispersion)
and (median * dispersion).</p>
<p>Example (Lessler, 2009):</p>
<blockquote>
<div><p>influenza_incubation_period_median     = 1.9
influenza_incubation_period_dispersion = 1.81
influenza_symptoms_duration_median     = 5.0
influenza_symptoms_duration_dispersion = 1.5</p>
</div></blockquote>
<p>These values give an expected incubation period of about 1 to 3.5 days, and symptoms lasting about 3 to 7.5 days.</p>
<p>This part is based on my own reading of the following article:
Lessler (2009) Incubation periods of acute respiratory viral infections – A systematic review.
——————————————————————————————————————–</p>
<dl class="simple">
<dt>Influenza A</dt><dd><p>incubation period median     = 1.9
incubation period dispersion = 1.22</p>
</dd>
<dt>Timer</dt><dd><ol class="arabic simple">
<li><p>Sample once per time step and store the current time in state as group attribute.</p></li>
<li><p>Sample once and register a timer event with the global simulation timer which will perform the appropriate
mass distribution.</p></li>
</ol>
</dd>
</dl>
<dl class="attribute">
<dt id="pram.rule.SEIRFluModel.ATTR">
<code class="sig-name descname">ATTR</code><em class="property"> = 'flu-state'</em><a class="headerlink" href="#pram.rule.SEIRFluModel.ATTR" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pram.rule.SEIRFluModel.NAME">
<code class="sig-name descname">NAME</code><em class="property"> = 'SEIR flu model'</em><a class="headerlink" href="#pram.rule.SEIRFluModel.NAME" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pram.rule.SEIRModel">
<em class="property">class </em><code class="sig-prename descclassname">pram.rule.</code><code class="sig-name descname">SEIRModel</code><span class="sig-paren">(</span><em class="sig-param">name='seir'</em>, <em class="sig-param">t=TimeAlways()</em>, <em class="sig-param">susceptibility=1.0</em>, <em class="sig-param">p_start_E=0.05</em>, <em class="sig-param">do_clean=True</em>, <em class="sig-param">name_human=None</em>, <em class="sig-param">memo=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.rule.SEIRModel" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pram.rule.Rule" title="pram.rule.Rule"><code class="xref py py-class docutils literal notranslate"><span class="pre">pram.rule.Rule</span></code></a>, <code class="xref py py-class docutils literal notranslate"><span class="pre">abc.ABC</span></code></p>
<p>The SEIR compartmental epidemiological model.</p>
<dl class="simple">
<dt>Disease states (SEIR)</dt><dd><p>S Susceptible
E Exposed (i.e., incubation period)
I Infectious (can infect other agents)
R Recovered</p>
</dd>
<dt>State transition timing</dt><dd><p>S  Until E (either by another agent or on import)
E  Random sample
I  Random sample
R  Indefinite</p>
</dd>
</dl>
<dl class="attribute">
<dt id="pram.rule.SEIRModel.ATTR">
<code class="sig-name descname">ATTR</code><em class="property"> = 'seir-state'</em><a class="headerlink" href="#pram.rule.SEIRModel.ATTR" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pram.rule.SEIRModel.ATTRS">
<code class="sig-name descname">ATTRS</code><em class="property"> = {'seir-state': [1, 2, 3, 4]}</em><a class="headerlink" href="#pram.rule.SEIRModel.ATTRS" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pram.rule.SEIRModel.NAME">
<code class="sig-name descname">NAME</code><em class="property"> = 'SEIR model'</em><a class="headerlink" href="#pram.rule.SEIRModel.NAME" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="class">
<dt id="pram.rule.SEIRModel.State">
<em class="property">class </em><code class="sig-name descname">State</code><a class="headerlink" href="#pram.rule.SEIRModel.State" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">enum.IntEnum</span></code></p>
<p>An enumeration.</p>
<dl class="attribute">
<dt id="pram.rule.SEIRModel.State.E">
<code class="sig-name descname">E</code><em class="property"> = 2</em><a class="headerlink" href="#pram.rule.SEIRModel.State.E" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pram.rule.SEIRModel.State.I">
<code class="sig-name descname">I</code><em class="property"> = 3</em><a class="headerlink" href="#pram.rule.SEIRModel.State.I" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pram.rule.SEIRModel.State.R">
<code class="sig-name descname">R</code><em class="property"> = 4</em><a class="headerlink" href="#pram.rule.SEIRModel.State.R" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pram.rule.SEIRModel.State.S">
<code class="sig-name descname">S</code><em class="property"> = 1</em><a class="headerlink" href="#pram.rule.SEIRModel.State.S" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="attribute">
<dt id="pram.rule.SEIRModel.T_UNIT_MS">
<code class="sig-name descname">T_UNIT_MS</code><em class="property"> = 86400000</em><a class="headerlink" href="#pram.rule.SEIRModel.T_UNIT_MS" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.rule.SEIRModel.apply">
<code class="sig-name descname">apply</code><span class="sig-paren">(</span><em class="sig-param">pop</em>, <em class="sig-param">group</em>, <em class="sig-param">iter</em>, <em class="sig-param">t</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.rule.SEIRModel.apply" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.rule.SEIRModel.apply_E">
<code class="sig-name descname">apply_E</code><span class="sig-paren">(</span><em class="sig-param">pop</em>, <em class="sig-param">group</em>, <em class="sig-param">iter</em>, <em class="sig-param">t</em>, <em class="sig-param">state</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.rule.SEIRModel.apply_E" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.rule.SEIRModel.apply_I">
<code class="sig-name descname">apply_I</code><span class="sig-paren">(</span><em class="sig-param">pop</em>, <em class="sig-param">group</em>, <em class="sig-param">iter</em>, <em class="sig-param">t</em>, <em class="sig-param">state</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.rule.SEIRModel.apply_I" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.rule.SEIRModel.apply_R">
<code class="sig-name descname">apply_R</code><span class="sig-paren">(</span><em class="sig-param">pop</em>, <em class="sig-param">group</em>, <em class="sig-param">iter</em>, <em class="sig-param">t</em>, <em class="sig-param">state</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.rule.SEIRModel.apply_R" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.rule.SEIRModel.apply_S">
<code class="sig-name descname">apply_S</code><span class="sig-paren">(</span><em class="sig-param">pop</em>, <em class="sig-param">group</em>, <em class="sig-param">iter</em>, <em class="sig-param">t</em>, <em class="sig-param">state</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.rule.SEIRModel.apply_S" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.rule.SEIRModel.apply_err">
<code class="sig-name descname">apply_err</code><span class="sig-paren">(</span><em class="sig-param">pop</em>, <em class="sig-param">group</em>, <em class="sig-param">iter</em>, <em class="sig-param">t</em>, <em class="sig-param">state</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.rule.SEIRModel.apply_err" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.rule.SEIRModel.cleanup">
<code class="sig-name descname">cleanup</code><span class="sig-paren">(</span><em class="sig-param">pop</em>, <em class="sig-param">group</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.rule.SEIRModel.cleanup" title="Permalink to this definition">¶</a></dt>
<dd><p>Run once at the end of a simulation run.  Symmetrical to the setup() method.  Also uses the group-Splitting
mechanism.</p>
</dd></dl>

<dl class="method">
<dt id="pram.rule.SEIRModel.is_applicable">
<code class="sig-name descname">is_applicable</code><span class="sig-paren">(</span><em class="sig-param">group</em>, <em class="sig-param">iter</em>, <em class="sig-param">t</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.rule.SEIRModel.is_applicable" title="Permalink to this definition">¶</a></dt>
<dd><p>Verifies if the rule is applicable to the group at the current iteration and current time.</p>
</dd></dl>

<dl class="method">
<dt id="pram.rule.SEIRModel.setup">
<code class="sig-name descname">setup</code><span class="sig-paren">(</span><em class="sig-param">pop</em>, <em class="sig-param">group</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.rule.SEIRModel.setup" title="Permalink to this definition">¶</a></dt>
<dd><p>A rule’s setup place.  If the rule relies on groups having a certain set of attributes and relations, this is
where they should be set.  For example, a rule might set an attribute of all the groups like so:</p>
<blockquote>
<div><p>return [GroupSplitSpec(p=1.0, attr_set={ ‘did-attend-school-today’: False })]</p>
</div></blockquote>
<p>This reuses the group splitting mechanism; here, each group will be split into a (possibly non-extant) new
group and the entirety of the group’s mass will be moved into that new group.</p>
<p>This is also where a rule should do any other population initialization required.  For example, a rule that may
introduce a new Site object to the simulation, should make the population object aware of that site like so:</p>
<blockquote>
<div><p>pop.add_site(Site(‘new-site’))</p>
</div></blockquote>
<p>Every rule’s setup() method is called only once by Simulation.run() method before a simulation run commences.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pram.rule.SIRModelGillespie">
<em class="property">class </em><code class="sig-prename descclassname">pram.rule.</code><code class="sig-name descname">SIRModelGillespie</code><span class="sig-paren">(</span><em class="sig-param">name='rule'</em>, <em class="sig-param">t=TimeAlways()</em>, <em class="sig-param">i=IterAlways()</em>, <em class="sig-param">name_human=None</em>, <em class="sig-param">memo=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.rule.SIRModelGillespie" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pram.rule.Rule" title="pram.rule.Rule"><code class="xref py py-class docutils literal notranslate"><span class="pre">pram.rule.Rule</span></code></a></p>
<p>Gillespie algorithm</p>
<p>SRC: <a class="reference external" href="https://en.wikipedia.org/wiki/Gillespie_algorithm">https://en.wikipedia.org/wiki/Gillespie_algorithm</a></p>
</dd></dl>

<dl class="class">
<dt id="pram.rule.SegregationModel">
<em class="property">class </em><code class="sig-prename descclassname">pram.rule.</code><code class="sig-name descname">SegregationModel</code><span class="sig-paren">(</span><em class="sig-param">attr</em>, <em class="sig-param">attr_dom_card</em>, <em class="sig-param">p_migrate=0.05</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.rule.SegregationModel" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pram.rule.Rule" title="pram.rule.Rule"><code class="xref py py-class docutils literal notranslate"><span class="pre">pram.rule.Rule</span></code></a></p>
<p>Segregation model.</p>
<p>—-[ Notation A ]—-</p>
<dl>
<dt>code:</dt><dd><p>SegregationModel(‘team’, 2)</p>
</dd>
<dt>init:</dt><dd><p>p_migrate = 0.05</p>
</dd>
<dt>is-applicable:</dt><dd><p>has-attr: team
has-rel: &#64;</p>
</dd>
<dt>apply:</dt><dd><p>p_team = <a class="reference external" href="mailto:n&#37;&#52;&#48;_{attr&#46;team">n<span>&#64;</span>_{attr<span>&#46;</span>team</a> = group.attr.team} / n&#64;  # …
if (p_team &lt; 0.5):</p>
<blockquote>
<div><p>rd p_migrate -&gt; R:&#64; = get_random_site()
nc 1 - p_migrate</p>
</div></blockquote>
</dd>
</dl>
<p>—-[ Notation B ]—-</p>
<p>p_team = <a class="reference external" href="mailto:n&#37;&#52;&#48;_{attr&#46;team">n<span>&#64;</span>_{attr<span>&#46;</span>team</a> = group.attr.team} / n&#64;
if (p_team &lt; 0.5) p_migrate -&gt; R:&#64; = get_random_site()</p>
<dl class="method">
<dt id="pram.rule.SegregationModel.apply">
<code class="sig-name descname">apply</code><span class="sig-paren">(</span><em class="sig-param">pop</em>, <em class="sig-param">group</em>, <em class="sig-param">iter</em>, <em class="sig-param">t</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.rule.SegregationModel.apply" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.rule.SegregationModel.get_random_site">
<code class="sig-name descname">get_random_site</code><span class="sig-paren">(</span><em class="sig-param">pop</em>, <em class="sig-param">site</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.rule.SegregationModel.get_random_site" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a random site different than the specified one.</p>
</dd></dl>

<dl class="method">
<dt id="pram.rule.SegregationModel.is_applicable">
<code class="sig-name descname">is_applicable</code><span class="sig-paren">(</span><em class="sig-param">group</em>, <em class="sig-param">iter</em>, <em class="sig-param">t</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.rule.SegregationModel.is_applicable" title="Permalink to this definition">¶</a></dt>
<dd><p>Verifies if the rule is applicable to the group at the current iteration and current time.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pram.rule.Sequence">
<em class="property">class </em><code class="sig-prename descclassname">pram.rule.</code><code class="sig-name descname">Sequence</code><span class="sig-paren">(</span><em class="sig-param">name='rule'</em>, <em class="sig-param">t=TimeAlways()</em>, <em class="sig-param">i=IterAlways()</em>, <em class="sig-param">name_human=None</em>, <em class="sig-param">memo=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.rule.Sequence" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pram.rule.Rule" title="pram.rule.Rule"><code class="xref py py-class docutils literal notranslate"><span class="pre">pram.rule.Rule</span></code></a>, <code class="xref py py-class docutils literal notranslate"><span class="pre">abc.ABC</span></code></p>
</dd></dl>

<dl class="class">
<dt id="pram.rule.SimpleFluLocationRule">
<em class="property">class </em><code class="sig-prename descclassname">pram.rule.</code><code class="sig-name descname">SimpleFluLocationRule</code><span class="sig-paren">(</span><em class="sig-param">t=TimeAlways()</em>, <em class="sig-param">name_human=None</em>, <em class="sig-param">memo=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.rule.SimpleFluLocationRule" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pram.rule.Rule" title="pram.rule.Rule"><code class="xref py py-class docutils literal notranslate"><span class="pre">pram.rule.Rule</span></code></a></p>
<p>Describes how student population changes location conditional upon being exposed to the flu.</p>
<p>—-[ Notation A ]—-</p>
<dl class="simple">
<dt>code:</dt><dd><p>SimpleFluLocationRule()</p>
</dd>
<dt>is-applicable:</dt><dd><p>has-attr: flu
has-rel: home, school</p>
</dd>
<dt>apply:</dt><dd><dl class="simple">
<dt>if group.attr.flu = ‘i’:</dt><dd><dl class="simple">
<dt>if group.attr.income = ‘l’:</dt><dd><p>rd 0.1 -&gt; R:&#64; = group.rel.home  # rd - redistribute mass
nc 0.9                          # nc - no change</p>
</dd>
<dt>if group.attr.income = ‘m’:</dt><dd><p>rd 0.6 -&gt; R:&#64; = group.rel.home
nc 0.4</p>
</dd>
</dl>
</dd>
<dt>if group.attr.flu = ‘r’:</dt><dd><p>rd 0.8 -&gt; R:&#64; = group.rel.school
nc 0.2</p>
</dd>
</dl>
</dd>
</dl>
<p>—-[ Notation B ]—-</p>
<dl class="simple">
<dt>if (flu = i)</dt><dd><dl class="simple">
<dt>if (income = l)</dt><dd><p>rd 0.1 -&gt; R:&#64; = home
nc 0.9</p>
</dd>
<dt>if (income = m)</dt><dd><p>rd 0.6 &gt; R:&#64; = home
nc 0.4</p>
</dd>
</dl>
</dd>
<dt>if (flu = r)</dt><dd><p>rd 0.8 &gt; R:&#64; = school
nc 0.2</p>
</dd>
</dl>
<dl class="attribute">
<dt id="pram.rule.SimpleFluLocationRule.ATTRS">
<code class="sig-name descname">ATTRS</code><em class="property"> = {'flu': ['s', 'i', 'r'], 'income': ['l', 'm']}</em><a class="headerlink" href="#pram.rule.SimpleFluLocationRule.ATTRS" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pram.rule.SimpleFluLocationRule.NAME">
<code class="sig-name descname">NAME</code><em class="property"> = 'Simple flu location model'</em><a class="headerlink" href="#pram.rule.SimpleFluLocationRule.NAME" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.rule.SimpleFluLocationRule.apply">
<code class="sig-name descname">apply</code><span class="sig-paren">(</span><em class="sig-param">pop</em>, <em class="sig-param">group</em>, <em class="sig-param">iter</em>, <em class="sig-param">t</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.rule.SimpleFluLocationRule.apply" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pram.rule.SimpleFluProgressMoodRule">
<em class="property">class </em><code class="sig-prename descclassname">pram.rule.</code><code class="sig-name descname">SimpleFluProgressMoodRule</code><span class="sig-paren">(</span><em class="sig-param">t=TimeAlways()</em>, <em class="sig-param">name_human=None</em>, <em class="sig-param">memo=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.rule.SimpleFluProgressMoodRule" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pram.rule.Rule" title="pram.rule.Rule"><code class="xref py py-class docutils literal notranslate"><span class="pre">pram.rule.Rule</span></code></a></p>
<p>Describes how a population transitions between the states of susceptible, infected, and recovered.  Includes the
inconsequential ‘mood’ attribute which may improve exposition of how the PRAM framework works.</p>
<p>—-[ Notation A ]—-</p>
<dl>
<dt>code:</dt><dd><p>SimpleFluProgressMoodRule()</p>
</dd>
<dt>is-applicable:</dt><dd><p>has-attr: flu</p>
</dd>
<dt>apply:</dt><dd><dl>
<dt>if group.attr.flu = ‘s’:</dt><dd><p>p_inf = <a class="reference external" href="mailto:n&#37;&#52;&#48;_{attr&#46;flu">n<span>&#64;</span>_{attr<span>&#46;</span>flu</a> = ‘i’} / n&#64;
move-mass:</p>
<blockquote>
<div><p>p_inf -&gt; A:flu = ‘i’, A:mood = ‘annoyed’</p>
</div></blockquote>
</dd>
<dt>if group.attr.flu = ‘i’:</dt><dd><dl class="simple">
<dt>move-mass:</dt><dd><p>0.2 -&gt; A:flu = ‘r’, A:mood = ‘happy’
0.5 -&gt;              A:mood = ‘bored’
0.3 -&gt;              A:mood = ‘annoyed’</p>
</dd>
</dl>
</dd>
<dt>if group.attr.flu = ‘r’:</dt><dd><dl class="simple">
<dt>move-mass:</dt><dd><p>0.1 -&gt; A:flu = ‘s’</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p>—-[ Notation B ]—-</p>
<dl class="simple">
<dt>if (flu = s)</dt><dd><p>p_inf = <a class="reference external" href="mailto:n&#37;&#52;&#48;_{attr&#46;flu">n<span>&#64;</span>_{attr<span>&#46;</span>flu</a> = i} / n&#64;
p_inf -&gt; A:flu = ‘i’, A:mood = ‘annoyed’</p>
</dd>
<dt>if (flu = i)</dt><dd><p>0.2 -&gt; A:flu = ‘r’, A:mood = ‘happy’
0.5 -&gt;              A:mood = ‘bored’
0.3 -&gt;              A:mood = ‘annoyed’</p>
</dd>
</dl>
<p>if (flu = r) 0.1 &gt; A:flu = s</p>
<dl class="attribute">
<dt id="pram.rule.SimpleFluProgressMoodRule.NAME">
<code class="sig-name descname">NAME</code><em class="property"> = 'Simple flu progression model with mood'</em><a class="headerlink" href="#pram.rule.SimpleFluProgressMoodRule.NAME" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.rule.SimpleFluProgressMoodRule.apply">
<code class="sig-name descname">apply</code><span class="sig-paren">(</span><em class="sig-param">pop</em>, <em class="sig-param">group</em>, <em class="sig-param">iter</em>, <em class="sig-param">t</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.rule.SimpleFluProgressMoodRule.apply" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pram.rule.SimpleFluProgressRule">
<em class="property">class </em><code class="sig-prename descclassname">pram.rule.</code><code class="sig-name descname">SimpleFluProgressRule</code><span class="sig-paren">(</span><em class="sig-param">t=None</em>, <em class="sig-param">i=None</em>, <em class="sig-param">name_human=None</em>, <em class="sig-param">memo=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.rule.SimpleFluProgressRule" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pram.rule.Rule" title="pram.rule.Rule"><code class="xref py py-class docutils literal notranslate"><span class="pre">pram.rule.Rule</span></code></a></p>
<p>Describes how a population transitions between the flu states of susceptible, infected, and recovered.</p>
<p>—-[ Notation A ]—-</p>
<dl>
<dt>code:</dt><dd><p>SimpleFluProgressRule()</p>
</dd>
<dt>is-applicable:</dt><dd><p>has-attr: flu</p>
</dd>
<dt>apply:</dt><dd><dl>
<dt>if group.attr.flu = ‘s’:</dt><dd><p>p_inf = <a class="reference external" href="mailto:n&#37;&#52;&#48;_{attr&#46;flu">n<span>&#64;</span>_{attr<span>&#46;</span>flu</a> = ‘i’} / n&#64;
move-mass:</p>
<blockquote>
<div><p>p_inf -&gt; A:flu = ‘i’</p>
</div></blockquote>
</dd>
<dt>if group.attr.flu = ‘i’:</dt><dd><dl class="simple">
<dt>move-mass:</dt><dd><p>0.2 -&gt; A:flu = ‘r’</p>
</dd>
</dl>
</dd>
<dt>if group.attr.flu = ‘r’:</dt><dd><dl class="simple">
<dt>move-mass:</dt><dd><p>0.1 -&gt; A:flu = ‘s’</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p>—-[ Notation B ]—-</p>
<dl class="simple">
<dt>if (flu = s)</dt><dd><p>p_inf = <a class="reference external" href="mailto:n&#37;&#52;&#48;_{attr&#46;flu">n<span>&#64;</span>_{attr<span>&#46;</span>flu</a> = i} / n&#64;
p_inf -&gt; A: flu = ‘i’</p>
</dd>
</dl>
<p>if (flu = i) 0.2 &gt; A:flu = r
if (flu = r) 0.1 &gt; A:flu = s</p>
<dl class="attribute">
<dt id="pram.rule.SimpleFluProgressRule.ATTRS">
<code class="sig-name descname">ATTRS</code><em class="property"> = {'flu': ['s', 'i', 'r']}</em><a class="headerlink" href="#pram.rule.SimpleFluProgressRule.ATTRS" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pram.rule.SimpleFluProgressRule.NAME">
<code class="sig-name descname">NAME</code><em class="property"> = 'Simple flu progression model'</em><a class="headerlink" href="#pram.rule.SimpleFluProgressRule.NAME" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.rule.SimpleFluProgressRule.apply">
<code class="sig-name descname">apply</code><span class="sig-paren">(</span><em class="sig-param">pop</em>, <em class="sig-param">group</em>, <em class="sig-param">iter</em>, <em class="sig-param">t</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.rule.SimpleFluProgressRule.apply" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.rule.SimpleFluProgressRule.setup">
<code class="sig-name descname">setup</code><span class="sig-paren">(</span><em class="sig-param">pop</em>, <em class="sig-param">group</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.rule.SimpleFluProgressRule.setup" title="Permalink to this definition">¶</a></dt>
<dd><p>A rule’s setup place.  If the rule relies on groups having a certain set of attributes and relations, this is
where they should be set.  For example, a rule might set an attribute of all the groups like so:</p>
<blockquote>
<div><p>return [GroupSplitSpec(p=1.0, attr_set={ ‘did-attend-school-today’: False })]</p>
</div></blockquote>
<p>This reuses the group splitting mechanism; here, each group will be split into a (possibly non-extant) new
group and the entirety of the group’s mass will be moved into that new group.</p>
<p>This is also where a rule should do any other population initialization required.  For example, a rule that may
introduce a new Site object to the simulation, should make the population object aware of that site like so:</p>
<blockquote>
<div><p>pop.add_site(Site(‘new-site’))</p>
</div></blockquote>
<p>Every rule’s setup() method is called only once by Simulation.run() method before a simulation run commences.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pram.rule.StationaryProcess">
<em class="property">class </em><code class="sig-prename descclassname">pram.rule.</code><code class="sig-name descname">StationaryProcess</code><span class="sig-paren">(</span><em class="sig-param">name='rule'</em>, <em class="sig-param">t=TimeAlways()</em>, <em class="sig-param">i=IterAlways()</em>, <em class="sig-param">name_human=None</em>, <em class="sig-param">memo=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.rule.StationaryProcess" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pram.rule.StochasticProcess" title="pram.rule.StochasticProcess"><code class="xref py py-class docutils literal notranslate"><span class="pre">pram.rule.StochasticProcess</span></code></a>, <code class="xref py py-class docutils literal notranslate"><span class="pre">abc.ABC</span></code></p>
<p>A stochastic process whose unconditional joint probability distribution does not change when shifted in time.</p>
</dd></dl>

<dl class="class">
<dt id="pram.rule.Stimulus">
<em class="property">class </em><code class="sig-prename descclassname">pram.rule.</code><code class="sig-name descname">Stimulus</code><span class="sig-paren">(</span><em class="sig-param">name='rule'</em>, <em class="sig-param">t=TimeAlways()</em>, <em class="sig-param">i=IterAlways()</em>, <em class="sig-param">name_human=None</em>, <em class="sig-param">memo=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.rule.Stimulus" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pram.rule.Rule" title="pram.rule.Rule"><code class="xref py py-class docutils literal notranslate"><span class="pre">pram.rule.Rule</span></code></a>, <code class="xref py py-class docutils literal notranslate"><span class="pre">abc.ABC</span></code></p>
</dd></dl>

<dl class="class">
<dt id="pram.rule.StochasticCellularAutomaton">
<em class="property">class </em><code class="sig-prename descclassname">pram.rule.</code><code class="sig-name descname">StochasticCellularAutomaton</code><span class="sig-paren">(</span><em class="sig-param">name='rule'</em>, <em class="sig-param">t=TimeAlways()</em>, <em class="sig-param">i=IterAlways()</em>, <em class="sig-param">name_human=None</em>, <em class="sig-param">memo=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.rule.StochasticCellularAutomaton" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pram.rule.CellularAutomaton" title="pram.rule.CellularAutomaton"><code class="xref py py-class docutils literal notranslate"><span class="pre">pram.rule.CellularAutomaton</span></code></a></p>
<p>Probabilistic cellular automata (PCA), random cellular automata, or locally interacting Markov chains.</p>
</dd></dl>

<dl class="class">
<dt id="pram.rule.StochasticProcess">
<em class="property">class </em><code class="sig-prename descclassname">pram.rule.</code><code class="sig-name descname">StochasticProcess</code><span class="sig-paren">(</span><em class="sig-param">name='rule'</em>, <em class="sig-param">t=TimeAlways()</em>, <em class="sig-param">i=IterAlways()</em>, <em class="sig-param">name_human=None</em>, <em class="sig-param">memo=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.rule.StochasticProcess" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pram.rule.Rule" title="pram.rule.Rule"><code class="xref py py-class docutils literal notranslate"><span class="pre">pram.rule.Rule</span></code></a>, <code class="xref py py-class docutils literal notranslate"><span class="pre">abc.ABC</span></code></p>
<p>A stochastic process is a collection of random variables indexed by time or space.</p>
</dd></dl>

<dl class="class">
<dt id="pram.rule.System">
<em class="property">class </em><code class="sig-prename descclassname">pram.rule.</code><code class="sig-name descname">System</code><span class="sig-paren">(</span><em class="sig-param">name='rule'</em>, <em class="sig-param">t=TimeAlways()</em>, <em class="sig-param">i=IterAlways()</em>, <em class="sig-param">name_human=None</em>, <em class="sig-param">memo=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.rule.System" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pram.rule.Rule" title="pram.rule.Rule"><code class="xref py py-class docutils literal notranslate"><span class="pre">pram.rule.Rule</span></code></a>, <code class="xref py py-class docutils literal notranslate"><span class="pre">abc.ABC</span></code></p>
</dd></dl>

<dl class="class">
<dt id="pram.rule.Time">
<em class="property">class </em><code class="sig-prename descclassname">pram.rule.</code><code class="sig-name descname">Time</code><a class="headerlink" href="#pram.rule.Time" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">abc.ABC</span></code></p>
</dd></dl>

<dl class="class">
<dt id="pram.rule.TimeAlways">
<em class="property">class </em><code class="sig-prename descclassname">pram.rule.</code><code class="sig-name descname">TimeAlways</code><a class="headerlink" href="#pram.rule.TimeAlways" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pram.rule.Time" title="pram.rule.Time"><code class="xref py py-class docutils literal notranslate"><span class="pre">pram.rule.Time</span></code></a></p>
</dd></dl>

<dl class="class">
<dt id="pram.rule.TimeInt">
<em class="property">class </em><code class="sig-prename descclassname">pram.rule.</code><code class="sig-name descname">TimeInt</code><span class="sig-paren">(</span><em class="sig-param">t0=0.0</em>, <em class="sig-param">t1=24.0</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.rule.TimeInt" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pram.rule.Time" title="pram.rule.Time"><code class="xref py py-class docutils literal notranslate"><span class="pre">pram.rule.Time</span></code></a></p>
<dl class="attribute">
<dt id="pram.rule.TimeInt.t0">
<code class="sig-name descname">t0</code><a class="headerlink" href="#pram.rule.TimeInt.t0" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pram.rule.TimeInt.t1">
<code class="sig-name descname">t1</code><a class="headerlink" href="#pram.rule.TimeInt.t1" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pram.rule.TimePoint">
<em class="property">class </em><code class="sig-prename descclassname">pram.rule.</code><code class="sig-name descname">TimePoint</code><span class="sig-paren">(</span><em class="sig-param">t=0.0</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.rule.TimePoint" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pram.rule.Time" title="pram.rule.Time"><code class="xref py py-class docutils literal notranslate"><span class="pre">pram.rule.Time</span></code></a></p>
<dl class="attribute">
<dt id="pram.rule.TimePoint.t">
<code class="sig-name descname">t</code><a class="headerlink" href="#pram.rule.TimePoint.t" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pram.rule.TimeSeriesFn">
<em class="property">class </em><code class="sig-prename descclassname">pram.rule.</code><code class="sig-name descname">TimeSeriesFn</code><span class="sig-paren">(</span><em class="sig-param">name='rule'</em>, <em class="sig-param">t=TimeAlways()</em>, <em class="sig-param">i=IterAlways()</em>, <em class="sig-param">name_human=None</em>, <em class="sig-param">memo=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.rule.TimeSeriesFn" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pram.rule.Rule" title="pram.rule.Rule"><code class="xref py py-class docutils literal notranslate"><span class="pre">pram.rule.Rule</span></code></a>, <code class="xref py py-class docutils literal notranslate"><span class="pre">abc.ABC</span></code></p>
<p>Function-based time series.</p>
</dd></dl>

<dl class="class">
<dt id="pram.rule.TimeSeriesObs">
<em class="property">class </em><code class="sig-prename descclassname">pram.rule.</code><code class="sig-name descname">TimeSeriesObs</code><span class="sig-paren">(</span><em class="sig-param">x</em>, <em class="sig-param">name='time-series'</em>, <em class="sig-param">t=TimeAlways()</em>, <em class="sig-param">i=IterAlways()</em>, <em class="sig-param">memo=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.rule.TimeSeriesObs" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pram.rule.Rule" title="pram.rule.Rule"><code class="xref py py-class docutils literal notranslate"><span class="pre">pram.rule.Rule</span></code></a>, <code class="xref py py-class docutils literal notranslate"><span class="pre">abc.ABC</span></code></p>
<p>Observation-based time series.</p>
<p>A rule that generates a time series given by a stochastic vector or a stochastic matrix of explicit observations
(e.g., historical data).  The following matrix</p>
<blockquote>
<div><blockquote>
<div><p>t1 t2 t3</p>
</div></blockquote>
<p>x1   1  2  3
x2   4  5  6</p>
</div></blockquote>
<p>should be provided as</p>
<blockquote>
<div><p>{ ‘x1’: [1,2,3], ‘x2’: [4,5,6] }</p>
</div></blockquote>
<dl class="method">
<dt id="pram.rule.TimeSeriesObs.apply">
<code class="sig-name descname">apply</code><span class="sig-paren">(</span><em class="sig-param">pop</em>, <em class="sig-param">group</em>, <em class="sig-param">iter</em>, <em class="sig-param">t</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.rule.TimeSeriesObs.apply" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pram.rule.WienerProcess">
<em class="property">class </em><code class="sig-prename descclassname">pram.rule.</code><code class="sig-name descname">WienerProcess</code><span class="sig-paren">(</span><em class="sig-param">name='rule'</em>, <em class="sig-param">t=TimeAlways()</em>, <em class="sig-param">i=IterAlways()</em>, <em class="sig-param">name_human=None</em>, <em class="sig-param">memo=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.rule.WienerProcess" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pram.rule.LevyProcess" title="pram.rule.LevyProcess"><code class="xref py py-class docutils literal notranslate"><span class="pre">pram.rule.LevyProcess</span></code></a>, <a class="reference internal" href="#pram.rule.DiffusionProcess" title="pram.rule.DiffusionProcess"><code class="xref py py-class docutils literal notranslate"><span class="pre">pram.rule.DiffusionProcess</span></code></a></p>
<p>Markov processes in continuous time.</p>
<p>Brownian motion process or Brownian motion.</p>
<p>A limit of simple random walk.</p>
</dd></dl>

</div>
<div class="section" id="module-pram.signal">
<span id="pram-signal-module"></span><h2>pram.signal module<a class="headerlink" href="#module-pram.signal" title="Permalink to this headline">¶</a></h2>
<p>Contains signal-processing relevant code.</p>
<p>When considered over time, agent mass dynamics and other time series that PyPRAM outputs can be seen as signals.
Signal processing toolkit can therefore be used to process those signals.  Because PyPRAM currently is a discrete-time
system (i.e., it only supports iteration over time steps), all signals it outputs are also discrete.  However, with a
sufficiently small time step size those signals can be a reasonably good approximation of the continuous-time
data-generating processes.  One example of that are systems of ordinary differential equations (ODEs).  Because ODEs
need to be numerically integrated (PyPRAM does not support analytical solvers), the time step size typically needs to
be very small.</p>
<dl class="class">
<dt id="pram.signal.Signal">
<em class="property">class </em><code class="sig-prename descclassname">pram.signal.</code><code class="sig-name descname">Signal</code><span class="sig-paren">(</span><em class="sig-param">series=None</em>, <em class="sig-param">names=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.signal.Signal" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Multivariate time series as a signal.</p>
<p>A signal is a list of numpy arrays refered to as series.  What every single of those array denotes depends on the
outside algorithm that creates the signal.  For example, they might (and often will) contain the time series of
mass locus of a simulation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>series</strong> (<a class="reference internal" href="#pram.signal.Signal" title="pram.signal.Signal"><em>Signal</em></a><em>, </em><em>numpy.ndarray</em><em>, </em><em>optional</em>) – Data for one or more series.</p></li>
<li><p><strong>names</strong> (<em>list</em><em>(</em><em>str</em><em>)</em><em>, </em><em>optional</em>) – Names of all the series specified.</p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>ValueError</strong> – </p>
</dd>
</dl>
<dl class="method">
<dt id="pram.signal.Signal.add_series">
<code class="sig-name descname">add_series</code><span class="sig-paren">(</span><em class="sig-param">s</em>, <em class="sig-param">name=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.signal.Signal.add_series" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds one or more series to the series already stored.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>s</strong> (<em>list</em><em>(</em><em>float</em><em>)</em><em>, </em><em>numpy.ndarray</em>) – The series being added.</p></li>
<li><p><strong>name</strong> (<em>str</em><em>, </em><em>optional</em>) – The name of the series being added.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>For method chaining.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>self</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pram.signal.Signal.plot_autocorr">
<code class="sig-name descname">plot_autocorr</code><span class="sig-paren">(</span><em class="sig-param">size</em>, <em class="sig-param">filename=None</em>, <em class="sig-param">do_ret_plot=False</em>, <em class="sig-param">dpi=100</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.signal.Signal.plot_autocorr" title="Permalink to this definition">¶</a></dt>
<dd><p>Generated autocorrelation plot.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>size</strong> (<em>tuple</em><em>(</em><em>int</em><em>,</em><em>int</em><em>)</em>) – Figure size in the (w,h) format.</p></li>
<li><p><strong>filename</strong> (<em>string</em><em>, </em><em>optional</em>) – Filename.</p></li>
<li><p><strong>do_ret_plot</strong> (<em>bool</em>) – Flag: Return the figure or self?</p></li>
<li><p><strong>dpi</strong> (<em>int</em>) – Resolution.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>Figure if ‘do_ret_plot’ is True and self otherwise (for method chaining)</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pram.signal.Signal.quantize">
<code class="sig-name descname">quantize</code><span class="sig-paren">(</span><em class="sig-param">bitdepth=16</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.signal.Signal.quantize" title="Permalink to this definition">¶</a></dt>
<dd><p>Quantizes all series in the signal.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>bitdepth</strong> (<em>int</em>) – Number of bits to use.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pram.sim">
<span id="pram-sim-module"></span><h2>pram.sim module<a class="headerlink" href="#module-pram.sim" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="pram.sim.DayTimer">
<em class="property">class </em><code class="sig-prename descclassname">pram.sim.</code><code class="sig-name descname">DayTimer</code><span class="sig-paren">(</span><em class="sig-param">iter=inf</em>, <em class="sig-param">do_disp_zero=True</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.sim.DayTimer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pram.sim.Timer" title="pram.sim.Timer"><code class="xref py py-class docutils literal notranslate"><span class="pre">pram.sim.Timer</span></code></a></p>
</dd></dl>

<dl class="class">
<dt id="pram.sim.DynamicRuleAnalyzer">
<em class="property">class </em><code class="sig-prename descclassname">pram.sim.</code><code class="sig-name descname">DynamicRuleAnalyzer</code><span class="sig-paren">(</span><em class="sig-param">sim</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.sim.DynamicRuleAnalyzer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Analyze rule conditioning after running the simulation.  This is done by processing group attributes and
relations that the simulation has recorded as accessed by at least one rule.  The evidence of attributes and
relations having been actually accessed is a strong one.  However, as tempting as it may be to use this
information to prune groups, it’s possible that further simulation iterations depend on other sets of
attributes and relations.  As a consequence, it is not possible to perform error-free groups auto-pruning based
on this analysis alone.</p>
<p>The sets of attributes and relations used (i.e., conditioned on by at least one rule) are not cleared between
simulation runs, only updated.  This way a simulation will always be aware of what was relevant from the very
beginning.  This information will also be persisted if the simulation object is serialized to continue
execution on another system.</p>
<dl class="method">
<dt id="pram.sim.DynamicRuleAnalyzer.analyze">
<code class="sig-name descname">analyze</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pram.sim.DynamicRuleAnalyzer.analyze" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pram.sim.HourTimer">
<em class="property">class </em><code class="sig-prename descclassname">pram.sim.</code><code class="sig-name descname">HourTimer</code><span class="sig-paren">(</span><em class="sig-param">iter=inf</em>, <em class="sig-param">do_disp_zero=True</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.sim.HourTimer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pram.sim.Timer" title="pram.sim.Timer"><code class="xref py py-class docutils literal notranslate"><span class="pre">pram.sim.Timer</span></code></a></p>
</dd></dl>

<dl class="class">
<dt id="pram.sim.MilsecTimer">
<em class="property">class </em><code class="sig-prename descclassname">pram.sim.</code><code class="sig-name descname">MilsecTimer</code><span class="sig-paren">(</span><em class="sig-param">iter=inf</em>, <em class="sig-param">do_disp_zero=True</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.sim.MilsecTimer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pram.sim.Timer" title="pram.sim.Timer"><code class="xref py py-class docutils literal notranslate"><span class="pre">pram.sim.Timer</span></code></a></p>
</dd></dl>

<dl class="class">
<dt id="pram.sim.MinTimer">
<em class="property">class </em><code class="sig-prename descclassname">pram.sim.</code><code class="sig-name descname">MinTimer</code><span class="sig-paren">(</span><em class="sig-param">iter=inf</em>, <em class="sig-param">do_disp_zero=True</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.sim.MinTimer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pram.sim.Timer" title="pram.sim.Timer"><code class="xref py py-class docutils literal notranslate"><span class="pre">pram.sim.Timer</span></code></a></p>
</dd></dl>

<dl class="class">
<dt id="pram.sim.MonthTimer">
<em class="property">class </em><code class="sig-prename descclassname">pram.sim.</code><code class="sig-name descname">MonthTimer</code><span class="sig-paren">(</span><em class="sig-param">iter=inf</em>, <em class="sig-param">do_disp_zero=True</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.sim.MonthTimer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pram.sim.Timer" title="pram.sim.Timer"><code class="xref py py-class docutils literal notranslate"><span class="pre">pram.sim.Timer</span></code></a></p>
</dd></dl>

<dl class="class">
<dt id="pram.sim.SecTimer">
<em class="property">class </em><code class="sig-prename descclassname">pram.sim.</code><code class="sig-name descname">SecTimer</code><span class="sig-paren">(</span><em class="sig-param">iter=inf</em>, <em class="sig-param">do_disp_zero=True</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.sim.SecTimer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pram.sim.Timer" title="pram.sim.Timer"><code class="xref py py-class docutils literal notranslate"><span class="pre">pram.sim.Timer</span></code></a></p>
</dd></dl>

<dl class="class">
<dt id="pram.sim.Simulation">
<em class="property">class </em><code class="sig-prename descclassname">pram.sim.</code><code class="sig-name descname">Simulation</code><span class="sig-paren">(</span><em class="sig-param">traj=None</em>, <em class="sig-param">rand_seed=None</em>, <em class="sig-param">do_keep_mass_flow_specs=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.sim.Simulation" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>A PRAM simulation.</p>
<p>At this point, this simulation is a discrete-event simulation (DES).  DES models the operation of a system as a
(discrete) sequence of events in time.  DES contrast with continuous simulation in which the system state is
changed continuously over time on the basis of a set of differential equations defining the rates of change of
state variables.</p>
<p>All function callbacks (cb) should take only one argument, the Simulation object, because everything is accessible
given that single reference.</p>
<dl class="method">
<dt id="pram.sim.Simulation._load">
<em class="property">static </em><code class="sig-name descname">_load</code><span class="sig-paren">(</span><em class="sig-param">fpath</em>, <em class="sig-param">fn</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.sim.Simulation._load" title="Permalink to this definition">¶</a></dt>
<dd><p>Args:</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>For method call chaining.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>self</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pram.sim.Simulation.add">
<code class="sig-name descname">add</code><span class="sig-paren">(</span><em class="sig-param">lst=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.sim.Simulation.add" title="Permalink to this definition">¶</a></dt>
<dd><p>Args:</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>For method call chaining.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>self</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pram.sim.Simulation.add_group">
<code class="sig-name descname">add_group</code><span class="sig-paren">(</span><em class="sig-param">group</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.sim.Simulation.add_group" title="Permalink to this definition">¶</a></dt>
<dd><p>Args:</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>For method call chaining.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>self</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pram.sim.Simulation.add_groups">
<code class="sig-name descname">add_groups</code><span class="sig-paren">(</span><em class="sig-param">groups</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.sim.Simulation.add_groups" title="Permalink to this definition">¶</a></dt>
<dd><p>Args:</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>For method call chaining.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>self</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pram.sim.Simulation.add_probe">
<code class="sig-name descname">add_probe</code><span class="sig-paren">(</span><em class="sig-param">probe</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.sim.Simulation.add_probe" title="Permalink to this definition">¶</a></dt>
<dd><p>Args:</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>For method call chaining.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>self</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pram.sim.Simulation.add_probes">
<code class="sig-name descname">add_probes</code><span class="sig-paren">(</span><em class="sig-param">probes</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.sim.Simulation.add_probes" title="Permalink to this definition">¶</a></dt>
<dd><p>Args:</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>For method call chaining.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>self</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pram.sim.Simulation.add_rule">
<code class="sig-name descname">add_rule</code><span class="sig-paren">(</span><em class="sig-param">rule</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.sim.Simulation.add_rule" title="Permalink to this definition">¶</a></dt>
<dd><p>Args:</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>For method call chaining.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>self</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pram.sim.Simulation.add_rules">
<code class="sig-name descname">add_rules</code><span class="sig-paren">(</span><em class="sig-param">rules</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.sim.Simulation.add_rules" title="Permalink to this definition">¶</a></dt>
<dd><p>Args:</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>For method call chaining.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>self</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pram.sim.Simulation.add_site">
<code class="sig-name descname">add_site</code><span class="sig-paren">(</span><em class="sig-param">site</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.sim.Simulation.add_site" title="Permalink to this definition">¶</a></dt>
<dd><p>Args:</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>For method call chaining.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>self</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pram.sim.Simulation.add_sites">
<code class="sig-name descname">add_sites</code><span class="sig-paren">(</span><em class="sig-param">sites</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.sim.Simulation.add_sites" title="Permalink to this definition">¶</a></dt>
<dd><p>Args:</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>For method call chaining.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>self</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pram.sim.Simulation.analyze_rules_dynamic">
<code class="sig-name descname">analyze_rules_dynamic</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pram.sim.Simulation.analyze_rules_dynamic" title="Permalink to this definition">¶</a></dt>
<dd><p>Args:</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>For method call chaining.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>self</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pram.sim.Simulation.analyze_rules_dynamic_old">
<code class="sig-name descname">analyze_rules_dynamic_old</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pram.sim.Simulation.analyze_rules_dynamic_old" title="Permalink to this definition">¶</a></dt>
<dd><p>Args:</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>For method call chaining.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>self</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pram.sim.Simulation.analyze_rules_static">
<code class="sig-name descname">analyze_rules_static</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pram.sim.Simulation.analyze_rules_static" title="Permalink to this definition">¶</a></dt>
<dd><p>Args:</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>For method call chaining.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>self</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pram.sim.Simulation.clear_probes">
<code class="sig-name descname">clear_probes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pram.sim.Simulation.clear_probes" title="Permalink to this definition">¶</a></dt>
<dd><p>Args:</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>For method call chaining.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>self</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pram.sim.Simulation.clear_rules">
<code class="sig-name descname">clear_rules</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pram.sim.Simulation.clear_rules" title="Permalink to this definition">¶</a></dt>
<dd><p>Args:</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>For method call chaining.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>self</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pram.sim.Simulation.commit_group">
<code class="sig-name descname">commit_group</code><span class="sig-paren">(</span><em class="sig-param">group</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.sim.Simulation.commit_group" title="Permalink to this definition">¶</a></dt>
<dd><p>Args:</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>For method call chaining.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>self</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pram.sim.Simulation.compact">
<code class="sig-name descname">compact</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pram.sim.Simulation.compact" title="Permalink to this definition">¶</a></dt>
<dd><p>Args:</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>For method call chaining.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>self</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pram.sim.Simulation.db">
<code class="sig-name descname">db</code><span class="sig-paren">(</span><em class="sig-param">fpath</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.sim.Simulation.db" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.sim.Simulation.gen_ast">
<code class="sig-name descname">gen_ast</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pram.sim.Simulation.gen_ast" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>Code to AST</dt><dd><p><a class="reference external" href="https://greentreesnakes.readthedocs.io">https://greentreesnakes.readthedocs.io</a></p>
</dd>
<dt>AST to code</dt><dd><p><a class="reference external" href="https://astor.readthedocs.io">https://astor.readthedocs.io</a></p>
</dd>
<dt>Visualizing</dt><dd><p><a class="reference external" href="https://vpyast.appspot.com">https://vpyast.appspot.com</a>
<a class="reference external" href="https://ucb-sejits.github.io/ctree-docs/ipythontips.html">https://ucb-sejits.github.io/ctree-docs/ipythontips.html</a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pram.sim.Simulation.gen_diagram">
<code class="sig-name descname">gen_diagram</code><span class="sig-paren">(</span><em class="sig-param">fpath_diag</em>, <em class="sig-param">fpath_pdf</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.sim.Simulation.gen_diagram" title="Permalink to this definition">¶</a></dt>
<dd><dl>
<dt>Languages</dt><dd><dl class="simple">
<dt>DOT</dt><dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/DOT_(graph_description_language">https://en.wikipedia.org/wiki/DOT_(graph_description_language</a>)</p>
</dd>
</dl>
</dd>
<dt>Misc</dt><dd><dl class="simple">
<dt>Graphviz</dt><dd><p>Graph Visualization Tools
Plots DOTs
<a class="reference external" href="https://gitlab.com/graphviz/graphviz">https://gitlab.com/graphviz/graphviz</a></p>
</dd>
</dl>
</dd>
<dt>JavaScript graph editor library</dt><dd><dl>
<dt>List</dt><dd><p><a class="reference external" href="https://modeling-languages.com/javascript-drawing-libraries-diagrams">https://modeling-languages.com/javascript-drawing-libraries-diagrams</a></p>
</dd>
<dt>Free</dt><dd><dl>
<dt>Processing</dt><dd><p><a class="reference external" href="https://p5js.org">https://p5js.org</a>
<a class="reference external" href="https://p5js.org/examples">https://p5js.org/examples</a>  [links to examples]</p>
</dd>
<dt>jGraph / MxGraph</dt><dd><dl>
<dt><a class="reference external" href="https://github.com/jgraph">https://github.com/jgraph</a></dt><dd><dl class="simple">
<dt><a class="reference external" href="https://github.com/jgraph/mxgraph">https://github.com/jgraph/mxgraph</a></dt><dd><p><a class="reference external" href="https://jgraph.github.io/mxgraph/javascript/index.html">https://jgraph.github.io/mxgraph/javascript/index.html</a>  [links to examples]</p>
</dd>
</dl>
<p><a class="reference external" href="https://github.com/jgraph/drawio">https://github.com/jgraph/drawio</a></p>
</dd>
</dl>
</dd>
<dt>DiagramJS</dt><dd><dl class="simple">
<dt><a class="reference external" href="https://github.com/bpmn-io/diagram-js">https://github.com/bpmn-io/diagram-js</a></dt><dd><p><a class="reference external" href="https://github.com/bpmn-io/diagram-js/tree/master/example">https://github.com/bpmn-io/diagram-js/tree/master/example</a></p>
</dd>
</dl>
</dd>
<dt>draw2d</dt><dd><dl class="simple">
<dt><a class="reference external" href="http://www.draw2d.org/draw2d">http://www.draw2d.org/draw2d</a></dt><dd><p><a class="reference external" href="http://www.draw2d.org/draw2d_touch/jsdoc_6/#!/example">http://www.draw2d.org/draw2d_touch/jsdoc_6/#!/example</a>  [good examples library]</p>
</dd>
</dl>
</dd>
<dt>Cystoscape.js</dt><dd><p>Graph theory (network) library for visualisation and analysis
<a class="reference external" href="https://js.cytoscape.org">https://js.cytoscape.org</a></p>
</dd>
</dl>
</dd>
<dt>Commercial</dt><dd><dl class="simple">
<dt>GoJS</dt><dd><dl class="simple">
<dt><a class="reference external" href="https://gojs.net">https://gojs.net</a></dt><dd><p><a class="reference external" href="https://gojs.net/latest/samples/basic.html">https://gojs.net/latest/samples/basic.html</a>  [good examples library]</p>
</dd>
</dl>
</dd>
<dt>JointJS</dt><dd><p><a class="reference external" href="https://www.jointjs.com">https://www.jointjs.com</a></p>
</dd>
<dt>DHTMLX</dt><dd><dl class="simple">
<dt><a class="reference external" href="https://dhtmlx.com/docs/products/dhtmlxDiagram">https://dhtmlx.com/docs/products/dhtmlxDiagram</a></dt><dd><dl class="simple">
<dt><a class="reference external" href="https://docs.dhtmlx.com/diagram/samples/06_diagram_editor">https://docs.dhtmlx.com/diagram/samples/06_diagram_editor</a></dt><dd><p><a class="reference external" href="https://docs.dhtmlx.com/diagram/samples/06_diagram_editor/01_editor.html">https://docs.dhtmlx.com/diagram/samples/06_diagram_editor/01_editor.html</a>
<a class="reference external" href="https://docs.dhtmlx.com/diagram/samples/06_diagram_editor/01_editor.html">https://docs.dhtmlx.com/diagram/samples/06_diagram_editor/01_editor.html</a></p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</dd>
<dt>Python</dt><dd><dl>
<dt>List</dt><dd><p><a class="reference external" href="https://code.activestate.com/pypm/search:diagram/">https://code.activestate.com/pypm/search:diagram/</a></p>
</dd>
<dt>Free</dt><dd><dl class="simple">
<dt>diagram</dt><dd><p>Text mode diagrams using UTF-8 characters and fancy colors
<a class="reference external" href="https://pypi.org/project/diagram">https://pypi.org/project/diagram</a></p>
</dd>
</dl>
<p>pygraph
python-graph</p>
<blockquote>
<div><p><a class="reference external" href="https://github.com/Shoobx/python-graph">https://github.com/Shoobx/python-graph</a></p>
</div></blockquote>
<dl class="simple">
<dt>bdp</dt><dd><p>bdp (Block Diagram in Python) is a package that translates diagrams described using Python objects to TikZ
<a class="reference external" href="https://github.com/bogdanvuk/bdp">https://github.com/bogdanvuk/bdp</a></p>
</dd>
<dt>TikZ and PGF</dt><dd><p>TikZ and PGF are TeX packages for creating graphics programmatically
<a class="reference external" href="http://www.texample.net/tikz/examples/spacetime">http://www.texample.net/tikz/examples/spacetime</a></p>
</dd>
<dt>blockdiag</dt><dd><p>blockdiag and its family generate diagram images from simple text files
<a class="reference external" href="http://blockdiag.com">http://blockdiag.com</a>
<a class="reference external" href="http://blockdiag.com/en/blockdiag/examples.html">http://blockdiag.com/en/blockdiag/examples.html</a>  [good examples library]
<a class="reference external" href="https://www.jitsejan.com/creating-block-diagram.html">https://www.jitsejan.com/creating-block-diagram.html</a></p>
</dd>
<dt>graphics.py</dt><dd><p><a class="reference external" href="http://anh.cs.luc.edu/handsonPythonTutorial/graphics.html">http://anh.cs.luc.edu/handsonPythonTutorial/graphics.html</a></p>
</dd>
</dl>
</dd>
</dl>
</dd>
<dt>D3</dt><dd><p><a class="reference external" href="https://github.com/d3/d3/wiki/Gallery">https://github.com/d3/d3/wiki/Gallery</a>  [good examples library]
<a class="reference external" href="http://nvd3.org">http://nvd3.org</a>
<a class="reference external" href="https://www.fullstackpython.com/d3-js.html">https://www.fullstackpython.com/d3-js.html</a></p>
</dd>
<dt>Python to D3</dt><dd><dl class="simple">
<dt>Python NVD3</dt><dd><p><a class="reference external" href="https://github.com/areski/python-nvd3">https://github.com/areski/python-nvd3</a></p>
</dd>
<dt>mpld3</dt><dd><p><a class="reference external" href="http://mpld3.github.io/">http://mpld3.github.io/</a></p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pram.sim.Simulation.gen_groups_from_db">
<code class="sig-name descname">gen_groups_from_db</code><span class="sig-paren">(</span><em class="sig-param">fpath_db</em>, <em class="sig-param">tbl</em>, <em class="sig-param">attr_db=[]</em>, <em class="sig-param">rel_db=[]</em>, <em class="sig-param">attr_fix={}</em>, <em class="sig-param">rel_fix={}</em>, <em class="sig-param">rel_at=None</em>, <em class="sig-param">limit=0</em>, <em class="sig-param">is_verbose=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.sim.Simulation.gen_groups_from_db" title="Permalink to this definition">¶</a></dt>
<dd><p>Args:</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>For method call chaining.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>self</p>
</dd>
</dl>
<p>Here is a usage example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">Simulation</span><span class="p">()</span><span class="o">.</span>
    <span class="n">add</span><span class="p">()</span><span class="o">.</span>
        <span class="n">rule</span><span class="p">(</span><span class="o">...</span><span class="p">)</span><span class="o">.</span>
        <span class="n">probe</span><span class="p">(</span><span class="o">...</span><span class="p">)</span><span class="o">.</span>
        <span class="n">done</span><span class="p">()</span><span class="o">.</span>
    <span class="n">gen_groups_from_db</span><span class="p">(</span>
        <span class="n">fpath_db</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="vm">__file__</span><span class="p">),</span> <span class="s1">&#39;db&#39;</span><span class="p">,</span> <span class="s1">&#39;allegheny-students.sqlite3&#39;</span><span class="p">)</span>
        <span class="n">tbl</span>      <span class="o">=</span> <span class="s1">&#39;students&#39;</span><span class="p">,</span>
        <span class="n">attr_db</span>  <span class="o">=</span> <span class="p">[],</span>
        <span class="n">rel_db</span>   <span class="o">=</span> <span class="p">[</span><span class="n">GroupDBRelSpec</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;school&#39;</span><span class="p">,</span> <span class="n">col</span><span class="o">=</span><span class="s1">&#39;school_id&#39;</span><span class="p">)],</span>
        <span class="n">attr_fix</span> <span class="o">=</span> <span class="p">{},</span>
        <span class="n">rel_fix</span>  <span class="o">=</span> <span class="p">{</span> <span class="s1">&#39;home&#39;</span><span class="p">:</span> <span class="n">Site</span><span class="p">(</span><span class="s1">&#39;home&#39;</span><span class="p">)</span> <span class="p">},</span>
        <span class="n">rel_at</span>   <span class="o">=</span> <span class="s1">&#39;school&#39;</span>
    <span class="p">)</span><span class="o">.</span>
    <span class="n">run</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pram.sim.Simulation.gen_groups_from_db_old">
<code class="sig-name descname">gen_groups_from_db_old</code><span class="sig-paren">(</span><em class="sig-param">fpath_db</em>, <em class="sig-param">tbl</em>, <em class="sig-param">attr={}</em>, <em class="sig-param">rel={}</em>, <em class="sig-param">attr_db=[]</em>, <em class="sig-param">rel_db=[]</em>, <em class="sig-param">rel_at=None</em>, <em class="sig-param">limit=0</em>, <em class="sig-param">fpath=None</em>, <em class="sig-param">is_verbose=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.sim.Simulation.gen_groups_from_db_old" title="Permalink to this definition">¶</a></dt>
<dd><p>Args:</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>For method call chaining.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>self</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pram.sim.Simulation.gen_sites_from_db">
<em class="property">static </em><code class="sig-name descname">gen_sites_from_db</code><span class="sig-paren">(</span><em class="sig-param">fpath_db</em>, <em class="sig-param">fn_gen=None</em>, <em class="sig-param">fpath=None</em>, <em class="sig-param">is_verbose=False</em>, <em class="sig-param">pragma_live_info=False</em>, <em class="sig-param">pragma_live_info_ts=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.sim.Simulation.gen_sites_from_db" title="Permalink to this definition">¶</a></dt>
<dd><p>Args:</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>For method call chaining.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>self</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pram.sim.Simulation.gen_sites_from_db_new">
<code class="sig-name descname">gen_sites_from_db_new</code><span class="sig-paren">(</span><em class="sig-param">fpath_db</em>, <em class="sig-param">tbl</em>, <em class="sig-param">name_col</em>, <em class="sig-param">rel_name='&#64;'</em>, <em class="sig-param">attr=[]</em>, <em class="sig-param">limit=0</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.sim.Simulation.gen_sites_from_db_new" title="Permalink to this definition">¶</a></dt>
<dd><p>Args:</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>For method call chaining.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>self</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pram.sim.Simulation.get_pragma">
<code class="sig-name descname">get_pragma</code><span class="sig-paren">(</span><em class="sig-param">name</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.sim.Simulation.get_pragma" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.sim.Simulation.get_pragma_analyze">
<code class="sig-name descname">get_pragma_analyze</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pram.sim.Simulation.get_pragma_analyze" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.sim.Simulation.get_pragma_autocompact">
<code class="sig-name descname">get_pragma_autocompact</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pram.sim.Simulation.get_pragma_autocompact" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.sim.Simulation.get_pragma_autoprune_groups">
<code class="sig-name descname">get_pragma_autoprune_groups</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pram.sim.Simulation.get_pragma_autoprune_groups" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.sim.Simulation.get_pragma_autostop">
<code class="sig-name descname">get_pragma_autostop</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pram.sim.Simulation.get_pragma_autostop" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.sim.Simulation.get_pragma_autostop_n">
<code class="sig-name descname">get_pragma_autostop_n</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pram.sim.Simulation.get_pragma_autostop_n" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.sim.Simulation.get_pragma_autostop_p">
<code class="sig-name descname">get_pragma_autostop_p</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pram.sim.Simulation.get_pragma_autostop_p" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.sim.Simulation.get_pragma_autostop_t">
<code class="sig-name descname">get_pragma_autostop_t</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pram.sim.Simulation.get_pragma_autostop_t" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.sim.Simulation.get_pragma_live_info">
<code class="sig-name descname">get_pragma_live_info</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pram.sim.Simulation.get_pragma_live_info" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.sim.Simulation.get_pragma_live_info_ts">
<code class="sig-name descname">get_pragma_live_info_ts</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pram.sim.Simulation.get_pragma_live_info_ts" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.sim.Simulation.get_pragma_probe_capture_init">
<code class="sig-name descname">get_pragma_probe_capture_init</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pram.sim.Simulation.get_pragma_probe_capture_init" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.sim.Simulation.get_pragma_rule_analysis_for_db_gen">
<code class="sig-name descname">get_pragma_rule_analysis_for_db_gen</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pram.sim.Simulation.get_pragma_rule_analysis_for_db_gen" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.sim.Simulation.get_state">
<code class="sig-name descname">get_state</code><span class="sig-paren">(</span><em class="sig-param">do_camelize=True</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.sim.Simulation.get_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Args:</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>For method call chaining.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>self</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pram.sim.Simulation.load">
<em class="property">static </em><code class="sig-name descname">load</code><span class="sig-paren">(</span><em class="sig-param">fpath</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.sim.Simulation.load" title="Permalink to this definition">¶</a></dt>
<dd><p>Args:</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>For method call chaining.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>self</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pram.sim.Simulation.load_bz2">
<em class="property">static </em><code class="sig-name descname">load_bz2</code><span class="sig-paren">(</span><em class="sig-param">fpath</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.sim.Simulation.load_bz2" title="Permalink to this definition">¶</a></dt>
<dd><p>Args:</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>For method call chaining.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>self</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pram.sim.Simulation.load_gz">
<em class="property">static </em><code class="sig-name descname">load_gz</code><span class="sig-paren">(</span><em class="sig-param">fpath</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.sim.Simulation.load_gz" title="Permalink to this definition">¶</a></dt>
<dd><p>Args:</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>For method call chaining.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>self</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pram.sim.Simulation.new_group">
<code class="sig-name descname">new_group</code><span class="sig-paren">(</span><em class="sig-param">name=None</em>, <em class="sig-param">m=0.0</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.sim.Simulation.new_group" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.sim.Simulation.plot">
<code class="sig-name descname">plot</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pram.sim.Simulation.plot" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.sim.Simulation.plot_group_size">
<code class="sig-name descname">plot_group_size</code><span class="sig-paren">(</span><em class="sig-param">do_log=False</em>, <em class="sig-param">fpath=None</em>, <em class="sig-param">title='Distribution of Group Size'</em>, <em class="sig-param">nx=250</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.sim.Simulation.plot_group_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Args:</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>For method call chaining.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>self</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pram.sim.Simulation.plot_site_size">
<code class="sig-name descname">plot_site_size</code><span class="sig-paren">(</span><em class="sig-param">do_log=False</em>, <em class="sig-param">fpath=None</em>, <em class="sig-param">title='Distribution of Site Size'</em>, <em class="sig-param">nx=250</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.sim.Simulation.plot_site_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Args:</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>For method call chaining.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>self</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pram.sim.Simulation.rem_probe">
<code class="sig-name descname">rem_probe</code><span class="sig-paren">(</span><em class="sig-param">probe</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.sim.Simulation.rem_probe" title="Permalink to this definition">¶</a></dt>
<dd><p>Args:</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>For method call chaining.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>self</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pram.sim.Simulation.rem_rule">
<code class="sig-name descname">rem_rule</code><span class="sig-paren">(</span><em class="sig-param">rule</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.sim.Simulation.rem_rule" title="Permalink to this definition">¶</a></dt>
<dd><p>Args:</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>For method call chaining.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>self</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pram.sim.Simulation.reset_cb">
<code class="sig-name descname">reset_cb</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pram.sim.Simulation.reset_cb" title="Permalink to this definition">¶</a></dt>
<dd><p>Args:</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>For method call chaining.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>self</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pram.sim.Simulation.reset_pop">
<code class="sig-name descname">reset_pop</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pram.sim.Simulation.reset_pop" title="Permalink to this definition">¶</a></dt>
<dd><p>Args:</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>For method call chaining.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>self</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pram.sim.Simulation.reset_pragmas">
<code class="sig-name descname">reset_pragmas</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pram.sim.Simulation.reset_pragmas" title="Permalink to this definition">¶</a></dt>
<dd><p>Args:</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>For method call chaining.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>self</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pram.sim.Simulation.reset_probes">
<code class="sig-name descname">reset_probes</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pram.sim.Simulation.reset_probes" title="Permalink to this definition">¶</a></dt>
<dd><p>Args:</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>For method call chaining.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>self</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pram.sim.Simulation.reset_rules">
<code class="sig-name descname">reset_rules</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pram.sim.Simulation.reset_rules" title="Permalink to this definition">¶</a></dt>
<dd><p>Args:</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>For method call chaining.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>self</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pram.sim.Simulation.run">
<code class="sig-name descname">run</code><span class="sig-paren">(</span><em class="sig-param">iter_or_dur=1</em>, <em class="sig-param">do_disp_t=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.sim.Simulation.run" title="Permalink to this definition">¶</a></dt>
<dd><p>Args:</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>For method call chaining.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>self</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pram.sim.Simulation.save">
<code class="sig-name descname">save</code><span class="sig-paren">(</span><em class="sig-param">fpath</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.sim.Simulation.save" title="Permalink to this definition">¶</a></dt>
<dd><p>Args:</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>For method call chaining.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>self</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pram.sim.Simulation.save_bz2">
<code class="sig-name descname">save_bz2</code><span class="sig-paren">(</span><em class="sig-param">fpath</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.sim.Simulation.save_bz2" title="Permalink to this definition">¶</a></dt>
<dd><p>Args:</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>For method call chaining.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>self</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pram.sim.Simulation.save_gz">
<code class="sig-name descname">save_gz</code><span class="sig-paren">(</span><em class="sig-param">fpath</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.sim.Simulation.save_gz" title="Permalink to this definition">¶</a></dt>
<dd><p>Args:</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>For method call chaining.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>self</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pram.sim.Simulation.set">
<code class="sig-name descname">set</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pram.sim.Simulation.set" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.sim.Simulation.set_cb_after_iter">
<code class="sig-name descname">set_cb_after_iter</code><span class="sig-paren">(</span><em class="sig-param">fn</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.sim.Simulation.set_cb_after_iter" title="Permalink to this definition">¶</a></dt>
<dd><p>Args:</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>For method call chaining.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>self</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pram.sim.Simulation.set_cb_before_iter">
<code class="sig-name descname">set_cb_before_iter</code><span class="sig-paren">(</span><em class="sig-param">fn</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.sim.Simulation.set_cb_before_iter" title="Permalink to this definition">¶</a></dt>
<dd><p>Args:</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>For method call chaining.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>self</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pram.sim.Simulation.set_dur">
<code class="sig-name descname">set_dur</code><span class="sig-paren">(</span><em class="sig-param">dur</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.sim.Simulation.set_dur" title="Permalink to this definition">¶</a></dt>
<dd><p>Args:</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>For method call chaining.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>self</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pram.sim.Simulation.set_fn_group_setup">
<code class="sig-name descname">set_fn_group_setup</code><span class="sig-paren">(</span><em class="sig-param">fn</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.sim.Simulation.set_fn_group_setup" title="Permalink to this definition">¶</a></dt>
<dd><p>Args:</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>For method call chaining.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>self</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pram.sim.Simulation.set_iter_cnt">
<code class="sig-name descname">set_iter_cnt</code><span class="sig-paren">(</span><em class="sig-param">iter_cnt</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.sim.Simulation.set_iter_cnt" title="Permalink to this definition">¶</a></dt>
<dd><p>Args:</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>For method call chaining.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>self</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pram.sim.Simulation.set_pragma">
<code class="sig-name descname">set_pragma</code><span class="sig-paren">(</span><em class="sig-param">name</em>, <em class="sig-param">value</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.sim.Simulation.set_pragma" title="Permalink to this definition">¶</a></dt>
<dd><p>Args:</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>For method call chaining.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>self</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pram.sim.Simulation.set_pragma_analyze">
<code class="sig-name descname">set_pragma_analyze</code><span class="sig-paren">(</span><em class="sig-param">value</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.sim.Simulation.set_pragma_analyze" title="Permalink to this definition">¶</a></dt>
<dd><p>Args:</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>For method call chaining.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>self</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pram.sim.Simulation.set_pragma_autocompact">
<code class="sig-name descname">set_pragma_autocompact</code><span class="sig-paren">(</span><em class="sig-param">value</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.sim.Simulation.set_pragma_autocompact" title="Permalink to this definition">¶</a></dt>
<dd><p>Args:</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>For method call chaining.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>self</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pram.sim.Simulation.set_pragma_autoprune_groups">
<code class="sig-name descname">set_pragma_autoprune_groups</code><span class="sig-paren">(</span><em class="sig-param">value</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.sim.Simulation.set_pragma_autoprune_groups" title="Permalink to this definition">¶</a></dt>
<dd><p>Args:</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>For method call chaining.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>self</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pram.sim.Simulation.set_pragma_autostop">
<code class="sig-name descname">set_pragma_autostop</code><span class="sig-paren">(</span><em class="sig-param">value</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.sim.Simulation.set_pragma_autostop" title="Permalink to this definition">¶</a></dt>
<dd><p>Args:</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>For method call chaining.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>self</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pram.sim.Simulation.set_pragma_autostop_n">
<code class="sig-name descname">set_pragma_autostop_n</code><span class="sig-paren">(</span><em class="sig-param">value</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.sim.Simulation.set_pragma_autostop_n" title="Permalink to this definition">¶</a></dt>
<dd><p>Args:</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>For method call chaining.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>self</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pram.sim.Simulation.set_pragma_autostop_p">
<code class="sig-name descname">set_pragma_autostop_p</code><span class="sig-paren">(</span><em class="sig-param">value</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.sim.Simulation.set_pragma_autostop_p" title="Permalink to this definition">¶</a></dt>
<dd><p>Args:</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>For method call chaining.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>self</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pram.sim.Simulation.set_pragma_autostop_t">
<code class="sig-name descname">set_pragma_autostop_t</code><span class="sig-paren">(</span><em class="sig-param">value</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.sim.Simulation.set_pragma_autostop_t" title="Permalink to this definition">¶</a></dt>
<dd><p>Args:</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>For method call chaining.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>self</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pram.sim.Simulation.set_pragma_live_info">
<code class="sig-name descname">set_pragma_live_info</code><span class="sig-paren">(</span><em class="sig-param">value</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.sim.Simulation.set_pragma_live_info" title="Permalink to this definition">¶</a></dt>
<dd><p>Args:</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>For method call chaining.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>self</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pram.sim.Simulation.set_pragma_live_info_ts">
<code class="sig-name descname">set_pragma_live_info_ts</code><span class="sig-paren">(</span><em class="sig-param">value</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.sim.Simulation.set_pragma_live_info_ts" title="Permalink to this definition">¶</a></dt>
<dd><p>Args:</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>For method call chaining.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>self</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pram.sim.Simulation.set_pragma_probe_capture_init">
<code class="sig-name descname">set_pragma_probe_capture_init</code><span class="sig-paren">(</span><em class="sig-param">value</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.sim.Simulation.set_pragma_probe_capture_init" title="Permalink to this definition">¶</a></dt>
<dd><p>Args:</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>For method call chaining.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>self</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pram.sim.Simulation.set_pragma_rule_analysis_for_db_gen">
<code class="sig-name descname">set_pragma_rule_analysis_for_db_gen</code><span class="sig-paren">(</span><em class="sig-param">value</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.sim.Simulation.set_pragma_rule_analysis_for_db_gen" title="Permalink to this definition">¶</a></dt>
<dd><p>Args:</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>For method call chaining.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>self</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pram.sim.Simulation.set_rand_seed">
<code class="sig-name descname">set_rand_seed</code><span class="sig-paren">(</span><em class="sig-param">rand_seed</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.sim.Simulation.set_rand_seed" title="Permalink to this definition">¶</a></dt>
<dd><p>Args:</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>For method call chaining.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>self</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pram.sim.Simulation.show_rule_analysis">
<code class="sig-name descname">show_rule_analysis</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pram.sim.Simulation.show_rule_analysis" title="Permalink to this definition">¶</a></dt>
<dd><p>Args:</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>For method call chaining.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>self</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pram.sim.Simulation.show_rule_analysis_dynamic">
<code class="sig-name descname">show_rule_analysis_dynamic</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pram.sim.Simulation.show_rule_analysis_dynamic" title="Permalink to this definition">¶</a></dt>
<dd><p>Args:</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>For method call chaining.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>self</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pram.sim.Simulation.show_rule_analysis_static">
<code class="sig-name descname">show_rule_analysis_static</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pram.sim.Simulation.show_rule_analysis_static" title="Permalink to this definition">¶</a></dt>
<dd><p>Args:</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>For method call chaining.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>self</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pram.sim.Simulation.summary">
<code class="sig-name descname">summary</code><span class="sig-paren">(</span><em class="sig-param">do_header=True</em>, <em class="sig-param">n_groups=8</em>, <em class="sig-param">n_sites=8</em>, <em class="sig-param">n_rules=8</em>, <em class="sig-param">n_probes=8</em>, <em class="sig-param">end_line_cnt=(0</em>, <em class="sig-param">0)</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.sim.Simulation.summary" title="Permalink to this definition">¶</a></dt>
<dd><p>Args:</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>For method call chaining.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>self</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pram.sim.SimulationAdder">
<em class="property">class </em><code class="sig-prename descclassname">pram.sim.</code><code class="sig-name descname">SimulationAdder</code><span class="sig-paren">(</span><em class="sig-param">sim</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.sim.SimulationAdder" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<dl class="method">
<dt id="pram.sim.SimulationAdder.done">
<code class="sig-name descname">done</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pram.sim.SimulationAdder.done" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.sim.SimulationAdder.group">
<code class="sig-name descname">group</code><span class="sig-paren">(</span><em class="sig-param">group</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.sim.SimulationAdder.group" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.sim.SimulationAdder.groups">
<code class="sig-name descname">groups</code><span class="sig-paren">(</span><em class="sig-param">groups</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.sim.SimulationAdder.groups" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.sim.SimulationAdder.probe">
<code class="sig-name descname">probe</code><span class="sig-paren">(</span><em class="sig-param">probe</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.sim.SimulationAdder.probe" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.sim.SimulationAdder.probes">
<code class="sig-name descname">probes</code><span class="sig-paren">(</span><em class="sig-param">probes</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.sim.SimulationAdder.probes" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.sim.SimulationAdder.rule">
<code class="sig-name descname">rule</code><span class="sig-paren">(</span><em class="sig-param">rule</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.sim.SimulationAdder.rule" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.sim.SimulationAdder.rules">
<code class="sig-name descname">rules</code><span class="sig-paren">(</span><em class="sig-param">rules</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.sim.SimulationAdder.rules" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.sim.SimulationAdder.site">
<code class="sig-name descname">site</code><span class="sig-paren">(</span><em class="sig-param">site</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.sim.SimulationAdder.site" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.sim.SimulationAdder.sites">
<code class="sig-name descname">sites</code><span class="sig-paren">(</span><em class="sig-param">sites</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.sim.SimulationAdder.sites" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="exception">
<dt id="pram.sim.SimulationConstructionError">
<em class="property">exception </em><code class="sig-prename descclassname">pram.sim.</code><code class="sig-name descname">SimulationConstructionError</code><a class="headerlink" href="#pram.sim.SimulationConstructionError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">Exception</span></code></p>
</dd></dl>

<dl class="exception">
<dt id="pram.sim.SimulationConstructionWarning">
<em class="property">exception </em><code class="sig-prename descclassname">pram.sim.</code><code class="sig-name descname">SimulationConstructionWarning</code><a class="headerlink" href="#pram.sim.SimulationConstructionWarning" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">Warning</span></code></p>
</dd></dl>

<dl class="class">
<dt id="pram.sim.SimulationDBI">
<em class="property">class </em><code class="sig-prename descclassname">pram.sim.</code><code class="sig-name descname">SimulationDBI</code><span class="sig-paren">(</span><em class="sig-param">sim</em>, <em class="sig-param">fpath</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.sim.SimulationDBI" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<dl class="method">
<dt id="pram.sim.SimulationDBI.done">
<code class="sig-name descname">done</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pram.sim.SimulationDBI.done" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.sim.SimulationDBI.gen_groups">
<code class="sig-name descname">gen_groups</code><span class="sig-paren">(</span><em class="sig-param">tbl</em>, <em class="sig-param">attr_db=[]</em>, <em class="sig-param">rel_db=[]</em>, <em class="sig-param">attr_fix={}</em>, <em class="sig-param">rel_fix={}</em>, <em class="sig-param">rel_at=None</em>, <em class="sig-param">limit=0</em>, <em class="sig-param">is_verbose=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.sim.SimulationDBI.gen_groups" title="Permalink to this definition">¶</a></dt>
<dd><p>Here is a usage example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">Simulation</span><span class="p">()</span><span class="o">.</span>
    <span class="n">add</span><span class="p">()</span><span class="o">.</span>
        <span class="n">rule</span><span class="p">(</span><span class="o">...</span><span class="p">)</span><span class="o">.</span>
        <span class="n">probe</span><span class="p">(</span><span class="o">...</span><span class="p">)</span><span class="o">.</span>
        <span class="n">done</span><span class="p">()</span><span class="o">.</span>
    <span class="n">db</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="vm">__file__</span><span class="p">),</span> <span class="s1">&#39;db&#39;</span><span class="p">,</span> <span class="s1">&#39;allegheny-students.sqlite3&#39;</span><span class="p">))</span><span class="o">.</span>
        <span class="n">gen_groups</span><span class="p">(</span>
            <span class="n">tbl</span>      <span class="o">=</span> <span class="s1">&#39;students&#39;</span><span class="p">,</span>
            <span class="n">attr_db</span>  <span class="o">=</span> <span class="p">[],</span>
            <span class="n">rel_db</span>   <span class="o">=</span> <span class="p">[</span><span class="n">GroupDBRelSpec</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;school&#39;</span><span class="p">,</span> <span class="n">col</span><span class="o">=</span><span class="s1">&#39;school_id&#39;</span><span class="p">)],</span>
            <span class="n">attr_fix</span> <span class="o">=</span> <span class="p">{},</span>
            <span class="n">rel_fix</span>  <span class="o">=</span> <span class="p">{</span> <span class="s1">&#39;home&#39;</span><span class="p">:</span> <span class="n">Site</span><span class="p">(</span><span class="s1">&#39;home&#39;</span><span class="p">)</span> <span class="p">},</span>
            <span class="n">rel_at</span>   <span class="o">=</span> <span class="s1">&#39;school&#39;</span>
        <span class="p">)</span><span class="o">.</span>
        <span class="n">done</span><span class="p">()</span><span class="o">.</span>
    <span class="n">run</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pram.sim.SimulationPlotter">
<em class="property">class </em><code class="sig-prename descclassname">pram.sim.</code><code class="sig-name descname">SimulationPlotter</code><span class="sig-paren">(</span><em class="sig-param">sim</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.sim.SimulationPlotter" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<dl class="method">
<dt id="pram.sim.SimulationPlotter.done">
<code class="sig-name descname">done</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pram.sim.SimulationPlotter.done" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.sim.SimulationPlotter.group_size">
<code class="sig-name descname">group_size</code><span class="sig-paren">(</span><em class="sig-param">do_log=False</em>, <em class="sig-param">fpath=None</em>, <em class="sig-param">title='Distribution of Group Size'</em>, <em class="sig-param">nx=250</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.sim.SimulationPlotter.group_size" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pram.sim.SimulationSetter">
<em class="property">class </em><code class="sig-prename descclassname">pram.sim.</code><code class="sig-name descname">SimulationSetter</code><span class="sig-paren">(</span><em class="sig-param">sim</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.sim.SimulationSetter" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<dl class="method">
<dt id="pram.sim.SimulationSetter.cb_after_iter">
<code class="sig-name descname">cb_after_iter</code><span class="sig-paren">(</span><em class="sig-param">fn</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.sim.SimulationSetter.cb_after_iter" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.sim.SimulationSetter.cb_before_iter">
<code class="sig-name descname">cb_before_iter</code><span class="sig-paren">(</span><em class="sig-param">fn</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.sim.SimulationSetter.cb_before_iter" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.sim.SimulationSetter.done">
<code class="sig-name descname">done</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pram.sim.SimulationSetter.done" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.sim.SimulationSetter.dur">
<code class="sig-name descname">dur</code><span class="sig-paren">(</span><em class="sig-param">dur</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.sim.SimulationSetter.dur" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.sim.SimulationSetter.fn_group_setup">
<code class="sig-name descname">fn_group_setup</code><span class="sig-paren">(</span><em class="sig-param">fn</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.sim.SimulationSetter.fn_group_setup" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.sim.SimulationSetter.iter_cnt">
<code class="sig-name descname">iter_cnt</code><span class="sig-paren">(</span><em class="sig-param">n</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.sim.SimulationSetter.iter_cnt" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.sim.SimulationSetter.pragma">
<code class="sig-name descname">pragma</code><span class="sig-paren">(</span><em class="sig-param">name</em>, <em class="sig-param">value</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.sim.SimulationSetter.pragma" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.sim.SimulationSetter.pragma_analyze">
<code class="sig-name descname">pragma_analyze</code><span class="sig-paren">(</span><em class="sig-param">value</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.sim.SimulationSetter.pragma_analyze" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.sim.SimulationSetter.pragma_autocompact">
<code class="sig-name descname">pragma_autocompact</code><span class="sig-paren">(</span><em class="sig-param">value</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.sim.SimulationSetter.pragma_autocompact" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.sim.SimulationSetter.pragma_autoprune_groups">
<code class="sig-name descname">pragma_autoprune_groups</code><span class="sig-paren">(</span><em class="sig-param">value</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.sim.SimulationSetter.pragma_autoprune_groups" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.sim.SimulationSetter.pragma_autostop">
<code class="sig-name descname">pragma_autostop</code><span class="sig-paren">(</span><em class="sig-param">value</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.sim.SimulationSetter.pragma_autostop" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.sim.SimulationSetter.pragma_autostop_n">
<code class="sig-name descname">pragma_autostop_n</code><span class="sig-paren">(</span><em class="sig-param">value</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.sim.SimulationSetter.pragma_autostop_n" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.sim.SimulationSetter.pragma_autostop_p">
<code class="sig-name descname">pragma_autostop_p</code><span class="sig-paren">(</span><em class="sig-param">value</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.sim.SimulationSetter.pragma_autostop_p" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.sim.SimulationSetter.pragma_autostop_t">
<code class="sig-name descname">pragma_autostop_t</code><span class="sig-paren">(</span><em class="sig-param">value</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.sim.SimulationSetter.pragma_autostop_t" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.sim.SimulationSetter.pragma_live_info">
<code class="sig-name descname">pragma_live_info</code><span class="sig-paren">(</span><em class="sig-param">value</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.sim.SimulationSetter.pragma_live_info" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.sim.SimulationSetter.pragma_live_info_ts">
<code class="sig-name descname">pragma_live_info_ts</code><span class="sig-paren">(</span><em class="sig-param">value</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.sim.SimulationSetter.pragma_live_info_ts" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.sim.SimulationSetter.pragma_probe_capture_init">
<code class="sig-name descname">pragma_probe_capture_init</code><span class="sig-paren">(</span><em class="sig-param">value</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.sim.SimulationSetter.pragma_probe_capture_init" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.sim.SimulationSetter.pragma_rule_analysis_for_db_gen">
<code class="sig-name descname">pragma_rule_analysis_for_db_gen</code><span class="sig-paren">(</span><em class="sig-param">value</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.sim.SimulationSetter.pragma_rule_analysis_for_db_gen" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.sim.SimulationSetter.rand_seed">
<code class="sig-name descname">rand_seed</code><span class="sig-paren">(</span><em class="sig-param">rand_seed</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.sim.SimulationSetter.rand_seed" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pram.sim.StaticRuleAnalyzer">
<em class="property">class </em><code class="sig-prename descclassname">pram.sim.</code><code class="sig-name descname">StaticRuleAnalyzer</code><a class="headerlink" href="#pram.sim.StaticRuleAnalyzer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Analyzes the syntax (i.e., abstract syntax trees or ASTs) of rule objects to identify group attributes and
relations these rules condition on.</p>
<p>Apart from attempting to deduce the attributes and rules, this class keeps track of the numbers of recognized and
unrecognized attributes and relations (compartmentalized by method type, e.g., ‘has_attr’ and ‘get_attr’).</p>
<dl>
<dt>References</dt><dd><p><a class="reference external" href="https://docs.python.org/3.6/library/dis.html">https://docs.python.org/3.6/library/dis.html</a>
<a class="reference external" href="https://docs.python.org/3.6/library/inspect.html">https://docs.python.org/3.6/library/inspect.html</a>
<a class="reference external" href="https://docs.python.org/3.6/library/ast.html">https://docs.python.org/3.6/library/ast.html</a></p>
<p><a class="reference external" href="https://github.com/hchasestevens/astpath">https://github.com/hchasestevens/astpath</a>
<a class="reference external" href="https://astsearch.readthedocs.io/en/latest">https://astsearch.readthedocs.io/en/latest</a></p>
</dd>
</dl>
<p># TODO: Double check the case of multiple sequential simulation runs.</p>
<dl class="method">
<dt id="pram.sim.StaticRuleAnalyzer._analyze">
<code class="sig-name descname">_analyze</code><span class="sig-paren">(</span><em class="sig-param">node</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.sim.StaticRuleAnalyzer._analyze" title="Permalink to this definition">¶</a></dt>
<dd><p>Processe a node of the AST recursively looking for method calls that suggest group attribute and relation names
conditioned on by the rule.  It also updates counts of all known and unknown names (compartmentalized by the
method name).</p>
<dl class="simple">
<dt>References</dt><dd><p><a class="reference external" href="https://docs.python.org/3.6/library/ast.html#abstract-grammar">https://docs.python.org/3.6/library/ast.html#abstract-grammar</a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pram.sim.StaticRuleAnalyzer._dump">
<code class="sig-name descname">_dump</code><span class="sig-paren">(</span><em class="sig-param">node</em>, <em class="sig-param">annotate_fields=True</em>, <em class="sig-param">include_attributes=False</em>, <em class="sig-param">indent='  '</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.sim.StaticRuleAnalyzer._dump" title="Permalink to this definition">¶</a></dt>
<dd><p>Source: <a class="reference external" href="https://bitbucket.org/takluyver/greentreesnakes/src/default/astpp.py?fileviewer=file-view-default">https://bitbucket.org/takluyver/greentreesnakes/src/default/astpp.py?fileviewer=file-view-default</a></p>
</dd></dl>

<dl class="method">
<dt id="pram.sim.StaticRuleAnalyzer._format">
<code class="sig-name descname">_format</code><span class="sig-paren">(</span><em class="sig-param">node</em>, <em class="sig-param">level=0</em>, <em class="sig-param">annotate_fields=True</em>, <em class="sig-param">include_attributes=False</em>, <em class="sig-param">indent='  '</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.sim.StaticRuleAnalyzer._format" title="Permalink to this definition">¶</a></dt>
<dd><p>Source: <a class="reference external" href="https://bitbucket.org/takluyver/greentreesnakes/src/default/astpp.py?fileviewer=file-view-default">https://bitbucket.org/takluyver/greentreesnakes/src/default/astpp.py?fileviewer=file-view-default</a></p>
</dd></dl>

<dl class="method">
<dt id="pram.sim.StaticRuleAnalyzer.analyze_groups">
<code class="sig-name descname">analyze_groups</code><span class="sig-paren">(</span><em class="sig-param">groups</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.sim.StaticRuleAnalyzer.analyze_groups" title="Permalink to this definition">¶</a></dt>
<dd><p>Should be called after all the groups have been added.</p>
</dd></dl>

<dl class="method">
<dt id="pram.sim.StaticRuleAnalyzer.analyze_rule">
<code class="sig-name descname">analyze_rule</code><span class="sig-paren">(</span><em class="sig-param">rule</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.sim.StaticRuleAnalyzer.analyze_rule" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.sim.StaticRuleAnalyzer.analyze_rules">
<code class="sig-name descname">analyze_rules</code><span class="sig-paren">(</span><em class="sig-param">rules</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.sim.StaticRuleAnalyzer.analyze_rules" title="Permalink to this definition">¶</a></dt>
<dd><p>Can be (and in fact is) called before any groups have been added.</p>
</dd></dl>

<dl class="method">
<dt id="pram.sim.StaticRuleAnalyzer.dump">
<code class="sig-name descname">dump</code><span class="sig-paren">(</span><em class="sig-param">rule</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.sim.StaticRuleAnalyzer.dump" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.sim.StaticRuleAnalyzer.get_str">
<em class="property">static </em><code class="sig-name descname">get_str</code><span class="sig-paren">(</span><em class="sig-param">node</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.sim.StaticRuleAnalyzer.get_str" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.sim.StaticRuleAnalyzer.reset">
<code class="sig-name descname">reset</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pram.sim.StaticRuleAnalyzer.reset" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pram.sim.Timer">
<em class="property">class </em><code class="sig-prename descclassname">pram.sim.</code><code class="sig-name descname">Timer</code><span class="sig-paren">(</span><em class="sig-param">ms=1</em>, <em class="sig-param">iter=inf</em>, <em class="sig-param">t0=0</em>, <em class="sig-param">tmin=0</em>, <em class="sig-param">tmax=10</em>, <em class="sig-param">do_disp_zero=True</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.sim.Timer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Simulation timer.</p>
<p>This discrete time is unitless; it is the simulation context that defines the appropriate granularity.  For
instance, million years (myr) might be appropriate for geological processes while Plank time might be appropriate
for modeling quantum phenomena.  For example, one interpretation of ‘self.t == 4’ is that the current simulation
time is 4am.</p>
<p>To enable natural blending of rules that operate on different time scales, the number of milliseconds is stored by
the object.  Because of this, rule times, which define the number of milliseconds in a time unit, can be scaled.</p>
<p>Apart from time, this timers also stores the iteration count.</p>
<dl class="attribute">
<dt id="pram.sim.Timer.POSIX_DT">
<code class="sig-name descname">POSIX_DT</code><em class="property"> = datetime.datetime(1970, 1, 1, 0, 0)</em><a class="headerlink" href="#pram.sim.Timer.POSIX_DT" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.sim.Timer.add_dur">
<code class="sig-name descname">add_dur</code><span class="sig-paren">(</span><em class="sig-param">dur</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.sim.Timer.add_dur" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.sim.Timer.add_iter">
<code class="sig-name descname">add_iter</code><span class="sig-paren">(</span><em class="sig-param">iter</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.sim.Timer.add_iter" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.sim.Timer.by_ms">
<em class="property">static </em><code class="sig-name descname">by_ms</code><span class="sig-paren">(</span><em class="sig-param">ms</em>, <em class="sig-param">**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.sim.Timer.by_ms" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a Timer object which matched the specified number of milliseconds.</p>
</dd></dl>

<dl class="method">
<dt id="pram.sim.Timer.get_i">
<code class="sig-name descname">get_i</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pram.sim.Timer.get_i" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.sim.Timer.get_i_left">
<code class="sig-name descname">get_i_left</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pram.sim.Timer.get_i_left" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.sim.Timer.get_t">
<code class="sig-name descname">get_t</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pram.sim.Timer.get_t" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.sim.Timer.get_t_left">
<code class="sig-name descname">get_t_left</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pram.sim.Timer.get_t_left" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.sim.Timer.get_t_loop_cnt">
<code class="sig-name descname">get_t_loop_cnt</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pram.sim.Timer.get_t_loop_cnt" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.sim.Timer.get_ts">
<em class="property">static </em><code class="sig-name descname">get_ts</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pram.sim.Timer.get_ts" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.sim.Timer.reset">
<code class="sig-name descname">reset</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pram.sim.Timer.reset" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.sim.Timer.set_dur">
<code class="sig-name descname">set_dur</code><span class="sig-paren">(</span><em class="sig-param">dur</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.sim.Timer.set_dur" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.sim.Timer.set_iter">
<code class="sig-name descname">set_iter</code><span class="sig-paren">(</span><em class="sig-param">iter</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.sim.Timer.set_iter" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.sim.Timer.start">
<code class="sig-name descname">start</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pram.sim.Timer.start" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.sim.Timer.step">
<code class="sig-name descname">step</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pram.sim.Timer.step" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.sim.Timer.stop">
<code class="sig-name descname">stop</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pram.sim.Timer.stop" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pram.sim.WeekTimer">
<em class="property">class </em><code class="sig-prename descclassname">pram.sim.</code><code class="sig-name descname">WeekTimer</code><span class="sig-paren">(</span><em class="sig-param">iter=inf</em>, <em class="sig-param">do_disp_zero=True</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.sim.WeekTimer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pram.sim.Timer" title="pram.sim.Timer"><code class="xref py py-class docutils literal notranslate"><span class="pre">pram.sim.Timer</span></code></a></p>
</dd></dl>

<dl class="class">
<dt id="pram.sim.YearTimer">
<em class="property">class </em><code class="sig-prename descclassname">pram.sim.</code><code class="sig-name descname">YearTimer</code><span class="sig-paren">(</span><em class="sig-param">iter=inf</em>, <em class="sig-param">do_disp_zero=True</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.sim.YearTimer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#pram.sim.Timer" title="pram.sim.Timer"><code class="xref py py-class docutils literal notranslate"><span class="pre">pram.sim.Timer</span></code></a></p>
</dd></dl>

</div>
<div class="section" id="module-pram.traj">
<span id="pram-traj-module"></span><h2>pram.traj module<a class="headerlink" href="#module-pram.traj" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="pram.traj.Trajectory">
<em class="property">class </em><code class="sig-prename descclassname">pram.traj.</code><code class="sig-name descname">Trajectory</code><span class="sig-paren">(</span><em class="sig-param">sim=None</em>, <em class="sig-param">name=None</em>, <em class="sig-param">memo=None</em>, <em class="sig-param">ensemble=None</em>, <em class="sig-param">id=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.traj.Trajectory" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>A time-ordered sequence of system configurations that occur as the system state evolves.</p>
<p>Also called orbit.  Can also be thought of as a sequence of vectors in the state space (or a point in a phase
space).</p>
<p>This class delegates persistance management to the TrajectoryEnsemble class that contains it.</p>
<p>This class keeps a reference to a simulation object, but that reference is only needed when running the simulation
is desired.  When working with a historical trajectory (i.e., the trace of past simulation run), ‘self.sim’ can be
None.  For example, the mass graph created by the Trajectory class is not based on an instatiated Simulation object
even if that object has been used to generate the substrate data; instead, the database content is the graph’s
basis.</p>
<dl class="method">
<dt id="pram.traj.Trajectory.comp_fft">
<em class="property">static </em><code class="sig-name descname">comp_fft</code><span class="sig-paren">(</span><em class="sig-param">y</em>, <em class="sig-param">T</em>, <em class="sig-param">N</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.traj.Trajectory.comp_fft" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes Fast Fourier Transform (FFT).</p>
<p>y - the signal
T - Nyquist sampling criterion
N - sampling rate</p>
</dd></dl>

<dl class="method">
<dt id="pram.traj.Trajectory.compact">
<code class="sig-name descname">compact</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pram.traj.Trajectory.compact" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.traj.Trajectory.gen_agent">
<code class="sig-name descname">gen_agent</code><span class="sig-paren">(</span><em class="sig-param">n_iter=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.traj.Trajectory.gen_agent" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.traj.Trajectory.gen_agent_pop">
<code class="sig-name descname">gen_agent_pop</code><span class="sig-paren">(</span><em class="sig-param">n_agents=1</em>, <em class="sig-param">n_iter=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.traj.Trajectory.gen_agent_pop" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.traj.Trajectory.gen_mass_graph">
<code class="sig-name descname">gen_mass_graph</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pram.traj.Trajectory.gen_mass_graph" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.traj.Trajectory.get_signal">
<code class="sig-name descname">get_signal</code><span class="sig-paren">(</span><em class="sig-param">do_prob=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.traj.Trajectory.get_signal" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.traj.Trajectory.get_time_series">
<code class="sig-name descname">get_time_series</code><span class="sig-paren">(</span><em class="sig-param">group_hash</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.traj.Trajectory.get_time_series" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.traj.Trajectory.load_sim">
<code class="sig-name descname">load_sim</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pram.traj.Trajectory.load_sim" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.traj.Trajectory.plot_heatmap">
<code class="sig-name descname">plot_heatmap</code><span class="sig-paren">(</span><em class="sig-param">size</em>, <em class="sig-param">filepath</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.traj.Trajectory.plot_heatmap" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.traj.Trajectory.plot_mass_flow_time_series">
<code class="sig-name descname">plot_mass_flow_time_series</code><span class="sig-paren">(</span><em class="sig-param">scale=(1.0</em>, <em class="sig-param">1.0)</em>, <em class="sig-param">filepath=None</em>, <em class="sig-param">iter_range=(-1</em>, <em class="sig-param">-1)</em>, <em class="sig-param">v_prop=False</em>, <em class="sig-param">e_prop=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.traj.Trajectory.plot_mass_flow_time_series" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.traj.Trajectory.plot_mass_locus_fft">
<code class="sig-name descname">plot_mass_locus_fft</code><span class="sig-paren">(</span><em class="sig-param">size</em>, <em class="sig-param">filepath</em>, <em class="sig-param">iter_range=(-1</em>, <em class="sig-param">-1)</em>, <em class="sig-param">sampling_rate=1</em>, <em class="sig-param">do_sort=False</em>, <em class="sig-param">do_ret_plot=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.traj.Trajectory.plot_mass_locus_fft" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.traj.Trajectory.plot_mass_locus_line">
<code class="sig-name descname">plot_mass_locus_line</code><span class="sig-paren">(</span><em class="sig-param">size</em>, <em class="sig-param">filepath</em>, <em class="sig-param">iter_range=(-1</em>, <em class="sig-param">-1)</em>, <em class="sig-param">stroke_w=1</em>, <em class="sig-param">col_scheme='set1'</em>, <em class="sig-param">do_ret_plot=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.traj.Trajectory.plot_mass_locus_line" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.traj.Trajectory.plot_mass_locus_recurrence">
<code class="sig-name descname">plot_mass_locus_recurrence</code><span class="sig-paren">(</span><em class="sig-param">size</em>, <em class="sig-param">filepath</em>, <em class="sig-param">iter_range=(-1</em>, <em class="sig-param">-1)</em>, <em class="sig-param">neighbourhood=&lt;pyrqa.neighbourhood.FixedRadius object&gt;</em>, <em class="sig-param">embedding_dimension=1</em>, <em class="sig-param">time_delay=2</em>, <em class="sig-param">do_ret_plot=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.traj.Trajectory.plot_mass_locus_recurrence" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.traj.Trajectory.plot_mass_locus_scaleogram">
<code class="sig-name descname">plot_mass_locus_scaleogram</code><span class="sig-paren">(</span><em class="sig-param">size</em>, <em class="sig-param">filepath</em>, <em class="sig-param">iter_range=(-1</em>, <em class="sig-param">-1)</em>, <em class="sig-param">sampling_rate=1</em>, <em class="sig-param">do_sort=False</em>, <em class="sig-param">do_ret_plot=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.traj.Trajectory.plot_mass_locus_scaleogram" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.traj.Trajectory.plot_mass_locus_spectrogram">
<code class="sig-name descname">plot_mass_locus_spectrogram</code><span class="sig-paren">(</span><em class="sig-param">size</em>, <em class="sig-param">filepath</em>, <em class="sig-param">iter_range=(-1</em>, <em class="sig-param">-1)</em>, <em class="sig-param">sampling_rate=None</em>, <em class="sig-param">win_len=None</em>, <em class="sig-param">noverlap=None</em>, <em class="sig-param">do_sort=False</em>, <em class="sig-param">do_ret_plot=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.traj.Trajectory.plot_mass_locus_spectrogram" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.traj.Trajectory.plot_mass_locus_streamgraph">
<code class="sig-name descname">plot_mass_locus_streamgraph</code><span class="sig-paren">(</span><em class="sig-param">size</em>, <em class="sig-param">filepath</em>, <em class="sig-param">iter_range=(-1</em>, <em class="sig-param">-1)</em>, <em class="sig-param">do_sort=False</em>, <em class="sig-param">do_ret_plot=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.traj.Trajectory.plot_mass_locus_streamgraph" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.traj.Trajectory.rem_mass_graph">
<code class="sig-name descname">rem_mass_graph</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pram.traj.Trajectory.rem_mass_graph" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.traj.Trajectory.run">
<code class="sig-name descname">run</code><span class="sig-paren">(</span><em class="sig-param">iter_or_dur=1</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.traj.Trajectory.run" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.traj.Trajectory.save_sim">
<code class="sig-name descname">save_sim</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pram.traj.Trajectory.save_sim" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.traj.Trajectory.save_state">
<code class="sig-name descname">save_state</code><span class="sig-paren">(</span><em class="sig-param">mass_flow_specs</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.traj.Trajectory.save_state" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pram.traj.TrajectoryEnsemble">
<em class="property">class </em><code class="sig-prename descclassname">pram.traj.</code><code class="sig-name descname">TrajectoryEnsemble</code><span class="sig-paren">(</span><em class="sig-param">fpath_db=None</em>, <em class="sig-param">do_load_sims=True</em>, <em class="sig-param">flush_every=16</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.traj.TrajectoryEnsemble" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>A collection of trajectories.</p>
<p>All database-related logic is implemented in this class, even if it might as well belong to the Trajectory class.
This provides an important benefit of keeping that logic from being spread all over the class hierarchy.</p>
<dl class="simple">
<dt>Database design notes</dt><dd><ul class="simple">
<li><p>While having a ‘traj_id’ field in the ‘grp_name’ table seems like a reasonable choice, a trajectory ensemble
is assumed to hold only similar trajectories.  Therefore, the ‘grp’ and ‘grp_name’ tables can simply be
joined on the ‘hash’ field.</p></li>
</ul>
</dd>
</dl>
<p>In mathematical physics, especially as introduced into statistical mechanics and thermodynamics by J. Willard Gibbs
in 1902, an ensemble (also statistical ensemble) is an idealization consisting of a large number of virtual copies
(sometimes infinitely many) of a system, considered all at once, each of which represents a possible state that the
real system might be in. In other words, a statistical ensemble is a probability distribution for the state of the
system.</p>
<dl class="attribute">
<dt id="pram.traj.TrajectoryEnsemble.DDL">
<code class="sig-name descname">DDL</code><em class="property"> = '\n        CREATE TABLE traj (\n        id   INTEGER PRIMARY KEY AUTOINCREMENT,\n        ts   DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,\n        name TEXT,\n        memo TEXT,\n        sim  BLOB\n        );\n\n        CREATE TABLE iter (\n        id      INTEGER PRIMARY KEY AUTOINCREMENT,\n        ts      DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,\n        traj_id INTEGER,\n        i       INTEGER NOT NULL,\n        host    TEXT NOT NULL,\n        UNIQUE (traj_id, i),\n        CONSTRAINT fk__iter__traj FOREIGN KEY (traj_id) REFERENCES traj (id) ON UPDATE CASCADE ON DELETE CASCADE\n        );\n\n        CREATE TABLE mass_locus (\n        id      INTEGER PRIMARY KEY AUTOINCREMENT,\n        iter_id INTEGER,\n        grp_id  INTEGER,\n        m       REAL NOT NULL,\n        m_p     REAL NOT NULL,\n        UNIQUE (iter_id, grp_id),\n        CONSTRAINT fk__mass_locus__iter FOREIGN KEY (iter_id) REFERENCES iter (id) ON UPDATE CASCADE ON DELETE CASCADE,\n        CONSTRAINT fk__mass_locus__grp  FOREIGN KEY (grp_id)  REFERENCES grp  (id) ON UPDATE CASCADE ON DELETE CASCADE\n        );\n\n        CREATE TABLE mass_flow (\n        id         INTEGER PRIMARY KEY AUTOINCREMENT,\n        iter_id    INTEGER,\n        grp_src_id INTEGER,\n        grp_dst_id INTEGER,\n        m          REAL NOT NULL,\n        m_p        REAL NOT NULL,\n        CONSTRAINT fk__mass_flow__iter    FOREIGN KEY (iter_id)    REFERENCES iter (id) ON UPDATE CASCADE ON DELETE CASCADE,\n        CONSTRAINT fk__mass_flow__grp_src FOREIGN KEY (grp_src_id) REFERENCES grp  (id) ON UPDATE CASCADE ON DELETE CASCADE,\n        CONSTRAINT fk__mass_flow__grp_dst FOREIGN KEY (grp_dst_id) REFERENCES grp  (id) ON UPDATE CASCADE ON DELETE CASCADE\n        );\n\n        CREATE TABLE grp (\n        id      INTEGER PRIMARY KEY AUTOINCREMENT,\n        hash    TEXT NOT NULL UNIQUE,\n        attr    BLOB,\n        rel     BLOB\n        );\n\n        CREATE TABLE grp_name (\n        id   INTEGER PRIMARY KEY AUTOINCREMENT,\n        ord  INTEGER,\n        hash TEXT NOT NULL UNIQUE,\n        name TEXT NOT NULL\n        );\n        '</em><a class="headerlink" href="#pram.traj.TrajectoryEnsemble.DDL" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pram.traj.TrajectoryEnsemble.FLUSH_EVERY">
<code class="sig-name descname">FLUSH_EVERY</code><em class="property"> = 16</em><a class="headerlink" href="#pram.traj.TrajectoryEnsemble.FLUSH_EVERY" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.traj.TrajectoryEnsemble._db_conn_open">
<code class="sig-name descname">_db_conn_open</code><span class="sig-paren">(</span><em class="sig-param">fpath_db=None</em>, <em class="sig-param">do_load_sims=True</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.traj.TrajectoryEnsemble._db_conn_open" title="Permalink to this definition">¶</a></dt>
<dd><p>Opens the DB connection and, if the file exists already, populates the trajectories dictionary with those from
the DB.</p>
</dd></dl>

<dl class="method">
<dt id="pram.traj.TrajectoryEnsemble.add_trajectories">
<code class="sig-name descname">add_trajectories</code><span class="sig-paren">(</span><em class="sig-param">traj</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.traj.TrajectoryEnsemble.add_trajectories" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.traj.TrajectoryEnsemble.add_trajectory">
<code class="sig-name descname">add_trajectory</code><span class="sig-paren">(</span><em class="sig-param">t</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.traj.TrajectoryEnsemble.add_trajectory" title="Permalink to this definition">¶</a></dt>
<dd><p>For convenience, ‘t’ can be either a Trajectory class instance of a Simulation class instance.  In the latter
case, a Trajectory object will automatically be created with the default values.</p>
</dd></dl>

<dl class="method">
<dt id="pram.traj.TrajectoryEnsemble.clear_group_names">
<code class="sig-name descname">clear_group_names</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pram.traj.TrajectoryEnsemble.clear_group_names" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.traj.TrajectoryEnsemble.compact">
<code class="sig-name descname">compact</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pram.traj.TrajectoryEnsemble.compact" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.traj.TrajectoryEnsemble.gen_agent">
<code class="sig-name descname">gen_agent</code><span class="sig-paren">(</span><em class="sig-param">traj</em>, <em class="sig-param">n_iter=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.traj.TrajectoryEnsemble.gen_agent" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a single agent’s group transition path based on population-level mass dynamics that a PRAM simulation
operates on.</p>
<p>This is a two-step process:</p>
<p>(1)  Pick the agent’s initial group taking into account the initial mass distribution among the groups
(2+) Pick the next group taking into account transition probabilities to all possible next groups</p>
<p>Because step 1 always takes place, the resulting list of agent’s states will be of size ‘n_iter + 1’.</p>
</dd></dl>

<dl class="method">
<dt id="pram.traj.TrajectoryEnsemble.gen_agent_pop">
<code class="sig-name descname">gen_agent_pop</code><span class="sig-paren">(</span><em class="sig-param">traj</em>, <em class="sig-param">n_agents=1</em>, <em class="sig-param">n_iter=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.traj.TrajectoryEnsemble.gen_agent_pop" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.traj.TrajectoryEnsemble.gen_mass_graph">
<code class="sig-name descname">gen_mass_graph</code><span class="sig-paren">(</span><em class="sig-param">traj</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.traj.TrajectoryEnsemble.gen_mass_graph" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.traj.TrajectoryEnsemble.get_signal">
<code class="sig-name descname">get_signal</code><span class="sig-paren">(</span><em class="sig-param">traj</em>, <em class="sig-param">do_prob=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.traj.TrajectoryEnsemble.get_signal" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns time series of masses of all groups.  Proportions of the total mass can be requested as well.</p>
</dd></dl>

<dl class="method">
<dt id="pram.traj.TrajectoryEnsemble.get_time_series">
<code class="sig-name descname">get_time_series</code><span class="sig-paren">(</span><em class="sig-param">traj</em>, <em class="sig-param">group_hash</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.traj.TrajectoryEnsemble.get_time_series" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.traj.TrajectoryEnsemble.load_sim">
<code class="sig-name descname">load_sim</code><span class="sig-paren">(</span><em class="sig-param">traj</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.traj.TrajectoryEnsemble.load_sim" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.traj.TrajectoryEnsemble.load_sims">
<code class="sig-name descname">load_sims</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pram.traj.TrajectoryEnsemble.load_sims" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.traj.TrajectoryEnsemble.normalize_iter_range">
<code class="sig-name descname">normalize_iter_range</code><span class="sig-paren">(</span><em class="sig-param">range=(-1</em>, <em class="sig-param">-1)</em>, <em class="sig-param">qry='SELECT MAX(i) FROM iter'</em>, <em class="sig-param">qry_args=[]</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.traj.TrajectoryEnsemble.normalize_iter_range" title="Permalink to this definition">¶</a></dt>
<dd><p>The SQL query should return the maximum number of iterations, as desired.  That is overall within the ensemble
or for a given trajectory or a set thereof.</p>
</dd></dl>

<dl class="method">
<dt id="pram.traj.TrajectoryEnsemble.plot_mass_locus_bubble">
<code class="sig-name descname">plot_mass_locus_bubble</code><span class="sig-paren">(</span><em class="sig-param">size</em>, <em class="sig-param">filepath</em>, <em class="sig-param">iter_range=(-1</em>, <em class="sig-param">-1)</em>, <em class="sig-param">do_sort=False</em>, <em class="sig-param">do_ret_plot=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.traj.TrajectoryEnsemble.plot_mass_locus_bubble" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.traj.TrajectoryEnsemble.plot_mass_locus_fft">
<code class="sig-name descname">plot_mass_locus_fft</code><span class="sig-paren">(</span><em class="sig-param">traj</em>, <em class="sig-param">size</em>, <em class="sig-param">filepath</em>, <em class="sig-param">iter_range=(-1</em>, <em class="sig-param">-1)</em>, <em class="sig-param">sampling_rate=1</em>, <em class="sig-param">do_sort=False</em>, <em class="sig-param">do_ret_plot=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.traj.TrajectoryEnsemble.plot_mass_locus_fft" title="Permalink to this definition">¶</a></dt>
<dd><p>Fast Fourier Transform (FFT)</p>
<p>The Fourier Transform will work very well when the frequency spectrum is stationary.</p>
</dd></dl>

<dl class="method">
<dt id="pram.traj.TrajectoryEnsemble.plot_mass_locus_line">
<code class="sig-name descname">plot_mass_locus_line</code><span class="sig-paren">(</span><em class="sig-param">size</em>, <em class="sig-param">filepath</em>, <em class="sig-param">iter_range=(-1</em>, <em class="sig-param">-1)</em>, <em class="sig-param">traj=None</em>, <em class="sig-param">nsamples=0</em>, <em class="sig-param">opacity_min=0.1</em>, <em class="sig-param">stroke_w=1</em>, <em class="sig-param">col_scheme='set1'</em>, <em class="sig-param">do_ret_plot=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.traj.TrajectoryEnsemble.plot_mass_locus_line" title="Permalink to this definition">¶</a></dt>
<dd><p>If ‘traj’ is not None, only that trajectory is plotted.  Otherwise, ‘nsample’ determines the number of
trajectories plotted.  Specifically, if smaller than or equal to zero, all trajectories are plotted; otherwise,
the given number of trajectories is selected randomly.  If the number provided exceeds the number of
trajectories present in the ensamble, all of them are plotted.</p>
</dd></dl>

<dl class="method">
<dt id="pram.traj.TrajectoryEnsemble.plot_mass_locus_line_aggr">
<code class="sig-name descname">plot_mass_locus_line_aggr</code><span class="sig-paren">(</span><em class="sig-param">size</em>, <em class="sig-param">filepath</em>, <em class="sig-param">iter_range=(-1</em>, <em class="sig-param">-1)</em>, <em class="sig-param">band_type='ci'</em>, <em class="sig-param">stroke_w=1</em>, <em class="sig-param">col_scheme='set1'</em>, <em class="sig-param">do_ret_plot=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.traj.TrajectoryEnsemble.plot_mass_locus_line_aggr" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>Ordering the legend of a composite chart</dt><dd><p><a class="reference external" href="https://stackoverflow.com/questions/55783286/control-legend-color-and-order-when-joining-two-charts-in-altair">https://stackoverflow.com/questions/55783286/control-legend-color-and-order-when-joining-two-charts-in-altair</a>
<a class="reference external" href="https://github.com/altair-viz/altair/issues/820">https://github.com/altair-viz/altair/issues/820</a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pram.traj.TrajectoryEnsemble.plot_mass_locus_polar">
<code class="sig-name descname">plot_mass_locus_polar</code><span class="sig-paren">(</span><em class="sig-param">size</em>, <em class="sig-param">filepath</em>, <em class="sig-param">iter_range=(-1</em>, <em class="sig-param">-1)</em>, <em class="sig-param">nsamples=0</em>, <em class="sig-param">n_iter_per_rot=0</em>, <em class="sig-param">do_sort=False</em>, <em class="sig-param">do_ret_plot=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.traj.TrajectoryEnsemble.plot_mass_locus_polar" title="Permalink to this definition">¶</a></dt>
<dd><p>Altair does not currently support projections, so we must revert to good old matplotlib.</p>
</dd></dl>

<dl class="method">
<dt id="pram.traj.TrajectoryEnsemble.plot_mass_locus_recurrence">
<code class="sig-name descname">plot_mass_locus_recurrence</code><span class="sig-paren">(</span><em class="sig-param">traj</em>, <em class="sig-param">size</em>, <em class="sig-param">filepath</em>, <em class="sig-param">iter_range=(-1</em>, <em class="sig-param">-1)</em>, <em class="sig-param">neighbourhood=&lt;pyrqa.neighbourhood.FixedRadius object&gt;</em>, <em class="sig-param">embedding_dimension=1</em>, <em class="sig-param">time_delay=2</em>, <em class="sig-param">do_ret_plot=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.traj.TrajectoryEnsemble.plot_mass_locus_recurrence" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference external" href="https://en.wikipedia.org/wiki/Recurrence_plot">https://en.wikipedia.org/wiki/Recurrence_plot</a></p>
<p>TODO: Multivariate extensions of recurrence plots include cross recurrence plots and joint recurrence plots.</p>
</dd></dl>

<dl class="method">
<dt id="pram.traj.TrajectoryEnsemble.plot_mass_locus_scaleogram">
<code class="sig-name descname">plot_mass_locus_scaleogram</code><span class="sig-paren">(</span><em class="sig-param">traj</em>, <em class="sig-param">size</em>, <em class="sig-param">filepath</em>, <em class="sig-param">iter_range=(-1</em>, <em class="sig-param">-1)</em>, <em class="sig-param">sampling_rate=1</em>, <em class="sig-param">do_sort=False</em>, <em class="sig-param">do_ret_plot=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.traj.TrajectoryEnsemble.plot_mass_locus_scaleogram" title="Permalink to this definition">¶</a></dt>
<dd><p>Currently, Image Mark in not supported in Vega-Lite.  Consequently, raster images cannot be displayed via
Altair.  The relevant issue is: <a class="reference external" href="https://github.com/vega/vega-lite/issues/3758">https://github.com/vega/vega-lite/issues/3758</a></p>
</dd></dl>

<dl class="method">
<dt id="pram.traj.TrajectoryEnsemble.plot_mass_locus_spectrogram">
<code class="sig-name descname">plot_mass_locus_spectrogram</code><span class="sig-paren">(</span><em class="sig-param">traj</em>, <em class="sig-param">size</em>, <em class="sig-param">filepath</em>, <em class="sig-param">iter_range=(-1</em>, <em class="sig-param">-1)</em>, <em class="sig-param">sampling_rate=None</em>, <em class="sig-param">win_len=None</em>, <em class="sig-param">noverlap=None</em>, <em class="sig-param">do_sort=False</em>, <em class="sig-param">do_ret_plot=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.traj.TrajectoryEnsemble.plot_mass_locus_spectrogram" title="Permalink to this definition">¶</a></dt>
<dd><dl>
<dt>Docs</dt><dd><p><a class="reference external" href="https://kite.com/python/docs/matplotlib.mlab.specgram">https://kite.com/python/docs/matplotlib.mlab.specgram</a></p>
</dd>
<dt>Examples</dt><dd><p><a class="reference external" href="https://matplotlib.org/3.1.1/gallery/images_contours_and_fields/specgram_demo.html#sphx-glr-gallery-images-contours-and-fields-specgram-demo-py">https://matplotlib.org/3.1.1/gallery/images_contours_and_fields/specgram_demo.html#sphx-glr-gallery-images-contours-and-fields-specgram-demo-py</a>
<a class="reference external" href="https://stackoverflow.com/questions/35932145/plotting-with-matplotlib-specgram">https://stackoverflow.com/questions/35932145/plotting-with-matplotlib-specgram</a>
<a class="reference external" href="https://pythontic.com/visualization/signals/spectrogram">https://pythontic.com/visualization/signals/spectrogram</a>
<a class="reference external" href="http://www.toolsmiths.com/wavelet/wavbox">http://www.toolsmiths.com/wavelet/wavbox</a></p>
</dd>
<dt>TODO</dt><dd><p><a class="reference external" href="http://ataspinar.com/2018/12/21/a-guide-for-using-the-wavelet-transform-in-machine-learning/">http://ataspinar.com/2018/12/21/a-guide-for-using-the-wavelet-transform-in-machine-learning/</a></p>
<p><a class="reference external" href="https://www.sciencedirect.com/topics/neuroscience/signal-processing">https://www.sciencedirect.com/topics/neuroscience/signal-processing</a>
<a class="reference external" href="https://www.google.com/search?client=firefox-b-1-d&amp;q=Signal+Processing+for+Neuroscientists+pdf">https://www.google.com/search?client=firefox-b-1-d&amp;q=Signal+Processing+for+Neuroscientists+pdf</a></p>
<p><a class="reference external" href="https://docs.scipy.org/doc/scipy-0.15.1/reference/generated/scipy.signal.cwt.html">https://docs.scipy.org/doc/scipy-0.15.1/reference/generated/scipy.signal.cwt.html</a>
<a class="reference external" href="https://www.semanticscholar.org/paper/A-wavelet-based-tool-for-studying-non-periodicity-Ben%C3%ADtez-Bol%C3%B3s/b7cb0789bd2d29222f2def7b70095f95eb72358c">https://www.semanticscholar.org/paper/A-wavelet-based-tool-for-studying-non-periodicity-Ben%C3%ADtez-Bol%C3%B3s/b7cb0789bd2d29222f2def7b70095f95eb72358c</a>
<a class="reference external" href="https://www.google.com/search?q=time-frequency+plane+decomposition&amp;client=firefox-b-1-d&amp;source=lnms&amp;tbm=isch&amp;sa=X&amp;ved=0ahUKEwiDxu3R9bXkAhWXqp4KHUSuBqYQ_AUIEigB&amp;biw=1374&amp;bih=829#imgrc=q2MCGaBIY3lrSM">https://www.google.com/search?q=time-frequency+plane+decomposition&amp;client=firefox-b-1-d&amp;source=lnms&amp;tbm=isch&amp;sa=X&amp;ved=0ahUKEwiDxu3R9bXkAhWXqp4KHUSuBqYQ_AUIEigB&amp;biw=1374&amp;bih=829#imgrc=q2MCGaBIY3lrSM</a>:
<a class="reference external" href="https://www.mathworks.com/help/wavelet/examples/classify-time-series-using-wavelet-analysis-and-deep-learning.html;jsessionid=de786cc8324218efefc12d75c292">https://www.mathworks.com/help/wavelet/examples/classify-time-series-using-wavelet-analysis-and-deep-learning.html;jsessionid=de786cc8324218efefc12d75c292</a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pram.traj.TrajectoryEnsemble.plot_mass_locus_streamgraph">
<code class="sig-name descname">plot_mass_locus_streamgraph</code><span class="sig-paren">(</span><em class="sig-param">traj</em>, <em class="sig-param">size</em>, <em class="sig-param">filepath</em>, <em class="sig-param">iter_range=(-1</em>, <em class="sig-param">-1)</em>, <em class="sig-param">do_sort=False</em>, <em class="sig-param">do_ret_plot=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.traj.TrajectoryEnsemble.plot_mass_locus_streamgraph" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.traj.TrajectoryEnsemble.plot_matplotlib">
<code class="sig-name descname">plot_matplotlib</code><span class="sig-paren">(</span><em class="sig-param">size</em>, <em class="sig-param">filepath</em>, <em class="sig-param">iter_range=(-1</em>, <em class="sig-param">-1)</em>, <em class="sig-param">do_sort=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.traj.TrajectoryEnsemble.plot_matplotlib" title="Permalink to this definition">¶</a></dt>
<dd><p>TODO: Remove (a more general version has been implemented).</p>
</dd></dl>

<dl class="method">
<dt id="pram.traj.TrajectoryEnsemble.run">
<code class="sig-name descname">run</code><span class="sig-paren">(</span><em class="sig-param">iter_or_dur=1</em>, <em class="sig-param">do_memoize_group_ids=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.traj.TrajectoryEnsemble.run" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>Parallelization</dt><dd><p><a class="reference external" href="https://docs.python.org/2/library/multiprocessing.html">https://docs.python.org/2/library/multiprocessing.html</a>
<a class="reference external" href="https://pyfora.readthedocs.io">https://pyfora.readthedocs.io</a></p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pram.traj.TrajectoryEnsemble.save_groups">
<code class="sig-name descname">save_groups</code><span class="sig-paren">(</span><em class="sig-param">traj</em>, <em class="sig-param">iter_id</em>, <em class="sig-param">conn</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.traj.TrajectoryEnsemble.save_groups" title="Permalink to this definition">¶</a></dt>
<dd><p>Inserts all groups for the given iteration and trajectory.  This captures the current simulation state (at
least to the degree that we care about for the time being).</p>
<p><a class="reference external" href="https://stackoverflow.com/questions/198692/can-i-pickle-a-python-dictionary-into-a-sqlite3-text-field">https://stackoverflow.com/questions/198692/can-i-pickle-a-python-dictionary-into-a-sqlite3-text-field</a></p>
</dd></dl>

<dl class="method">
<dt id="pram.traj.TrajectoryEnsemble.save_iter">
<code class="sig-name descname">save_iter</code><span class="sig-paren">(</span><em class="sig-param">traj</em>, <em class="sig-param">conn</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.traj.TrajectoryEnsemble.save_iter" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.traj.TrajectoryEnsemble.save_mass_flow">
<code class="sig-name descname">save_mass_flow</code><span class="sig-paren">(</span><em class="sig-param">traj</em>, <em class="sig-param">iter_id</em>, <em class="sig-param">mass_flow_specs</em>, <em class="sig-param">conn</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.traj.TrajectoryEnsemble.save_mass_flow" title="Permalink to this definition">¶</a></dt>
<dd><p>Inserts the mass flow among all groups for the given iteration and trajectory.  Mass flow is present for all
but the initial state of a simulation.</p>
</dd></dl>

<dl class="method">
<dt id="pram.traj.TrajectoryEnsemble.save_mass_locus">
<code class="sig-name descname">save_mass_locus</code><span class="sig-paren">(</span><em class="sig-param">traj</em>, <em class="sig-param">iter_id</em>, <em class="sig-param">conn</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.traj.TrajectoryEnsemble.save_mass_locus" title="Permalink to this definition">¶</a></dt>
<dd><p>Persists all new groups and masses of all groups participating in the current iteration and trajectory.  The
attributes and relations of all groups are saved in the database which enables restoring the state of the
simulation at any point in time.</p>
<p><a class="reference external" href="https://stackoverflow.com/questions/198692/can-i-pickle-a-python-dictionary-into-a-sqlite3-text-field">https://stackoverflow.com/questions/198692/can-i-pickle-a-python-dictionary-into-a-sqlite3-text-field</a></p>
</dd></dl>

<dl class="method">
<dt id="pram.traj.TrajectoryEnsemble.save_sim">
<code class="sig-name descname">save_sim</code><span class="sig-paren">(</span><em class="sig-param">traj</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.traj.TrajectoryEnsemble.save_sim" title="Permalink to this definition">¶</a></dt>
<dd><p>To pickle the Simulation object, we need to temporarily disconnect it from its Trajectory object container.
This is because the Trajectory object is connected to the TrajectoryEnsemble object which holds a database
connection object and those objects cannot be pickled.  Besides, there is no point in saving the entire class
hierarchy anyway.</p>
</dd></dl>

<dl class="method">
<dt id="pram.traj.TrajectoryEnsemble.save_sims">
<code class="sig-name descname">save_sims</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pram.traj.TrajectoryEnsemble.save_sims" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.traj.TrajectoryEnsemble.save_state">
<code class="sig-name descname">save_state</code><span class="sig-paren">(</span><em class="sig-param">traj</em>, <em class="sig-param">mass_flow_specs</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.traj.TrajectoryEnsemble.save_state" title="Permalink to this definition">¶</a></dt>
<dd><p>For saving both initial and regular states of simulations (i.e., ones involving mass flow).</p>
</dd></dl>

<dl class="method">
<dt id="pram.traj.TrajectoryEnsemble.set_group_name">
<code class="sig-name descname">set_group_name</code><span class="sig-paren">(</span><em class="sig-param">ord</em>, <em class="sig-param">name</em>, <em class="sig-param">hash</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.traj.TrajectoryEnsemble.set_group_name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.traj.TrajectoryEnsemble.set_group_names">
<code class="sig-name descname">set_group_names</code><span class="sig-paren">(</span><em class="sig-param">ord_name_hash</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.traj.TrajectoryEnsemble.set_group_names" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.traj.TrajectoryEnsemble.set_hosts">
<code class="sig-name descname">set_hosts</code><span class="sig-paren">(</span><em class="sig-param">hosts</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.traj.TrajectoryEnsemble.set_hosts" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.traj.TrajectoryEnsemble.set_pragma_memoize_group_ids">
<code class="sig-name descname">set_pragma_memoize_group_ids</code><span class="sig-paren">(</span><em class="sig-param">value</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.traj.TrajectoryEnsemble.set_pragma_memoize_group_ids" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.traj.TrajectoryEnsemble.stats">
<code class="sig-name descname">stats</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pram.traj.TrajectoryEnsemble.stats" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="exception">
<dt id="pram.traj.TrajectoryError">
<em class="property">exception </em><code class="sig-prename descclassname">pram.traj.</code><code class="sig-name descname">TrajectoryError</code><a class="headerlink" href="#pram.traj.TrajectoryError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">Exception</span></code></p>
</dd></dl>

</div>
<div class="section" id="module-pram.util">
<span id="pram-util-module"></span><h2>pram.util module<a class="headerlink" href="#module-pram.util" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="pram.util.DB">
<em class="property">class </em><code class="sig-prename descclassname">pram.util.</code><code class="sig-name descname">DB</code><a class="headerlink" href="#pram.util.DB" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Currently supports only SQLite3.</p>
<dl class="attribute">
<dt id="pram.util.DB.PATT_VALID_NAME">
<code class="sig-name descname">PATT_VALID_NAME</code><em class="property"> = re.compile('^[a-zA-Z][a-zA-Z0-9_]*$')</em><a class="headerlink" href="#pram.util.DB.PATT_VALID_NAME" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pram.util.DB.VALID_CHARS">
<code class="sig-name descname">VALID_CHARS</code><em class="property"> = '_abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'</em><a class="headerlink" href="#pram.util.DB.VALID_CHARS" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.util.DB.blob2obj">
<em class="property">static </em><code class="sig-name descname">blob2obj</code><span class="sig-paren">(</span><em class="sig-param">b</em>, <em class="sig-param">do_decompress=True</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.util.DB.blob2obj" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.util.DB.get_cnt">
<em class="property">static </em><code class="sig-name descname">get_cnt</code><span class="sig-paren">(</span><em class="sig-param">conn</em>, <em class="sig-param">tbl</em>, <em class="sig-param">where=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.util.DB.get_cnt" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.util.DB.get_fk">
<em class="property">static </em><code class="sig-name descname">get_fk</code><span class="sig-paren">(</span><em class="sig-param">conn</em>, <em class="sig-param">tbl</em>, <em class="sig-param">col_from</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.util.DB.get_fk" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the foreign key constraint for the specified table and column.</p>
</dd></dl>

<dl class="method">
<dt id="pram.util.DB.get_id">
<em class="property">static </em><code class="sig-name descname">get_id</code><span class="sig-paren">(</span><em class="sig-param">conn</em>, <em class="sig-param">tbl</em>, <em class="sig-param">col='rowid'</em>, <em class="sig-param">where=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.util.DB.get_id" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.util.DB.get_num">
<em class="property">static </em><code class="sig-name descname">get_num</code><span class="sig-paren">(</span><em class="sig-param">conn</em>, <em class="sig-param">tbl</em>, <em class="sig-param">col</em>, <em class="sig-param">where=None</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.util.DB.get_num" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.util.DB.obj2blob">
<em class="property">static </em><code class="sig-name descname">obj2blob</code><span class="sig-paren">(</span><em class="sig-param">o</em>, <em class="sig-param">do_compress=True</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.util.DB.obj2blob" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.util.DB.open_conn">
<em class="property">static </em><code class="sig-name descname">open_conn</code><span class="sig-paren">(</span><em class="sig-param">fpath</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.util.DB.open_conn" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.util.DB.str_to_name">
<em class="property">static </em><code class="sig-name descname">str_to_name</code><span class="sig-paren">(</span><em class="sig-param">s</em>, <em class="sig-param">do_raise_on_empty=True</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.util.DB.str_to_name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.util.DB.str_to_type">
<em class="property">static </em><code class="sig-name descname">str_to_type</code><span class="sig-paren">(</span><em class="sig-param">s</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.util.DB.str_to_type" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pram.util.Data">
<em class="property">class </em><code class="sig-prename descclassname">pram.util.</code><code class="sig-name descname">Data</code><a class="headerlink" href="#pram.util.Data" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<dl class="method">
<dt id="pram.util.Data.rand_bin_lst">
<em class="property">static </em><code class="sig-name descname">rand_bin_lst</code><span class="sig-paren">(</span><em class="sig-param">n</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.util.Data.rand_bin_lst" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.util.Data.rand_float_lst">
<em class="property">static </em><code class="sig-name descname">rand_float_lst</code><span class="sig-paren">(</span><em class="sig-param">l</em>, <em class="sig-param">u</em>, <em class="sig-param">n</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.util.Data.rand_float_lst" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pram.util.Err">
<em class="property">class </em><code class="sig-prename descclassname">pram.util.</code><code class="sig-name descname">Err</code><a class="headerlink" href="#pram.util.Err" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<dl class="method">
<dt id="pram.util.Err.type">
<em class="property">static </em><code class="sig-name descname">type</code><span class="sig-paren">(</span><em class="sig-param">arg</em>, <em class="sig-param">arg_name</em>, <em class="sig-param">type</em>, <em class="sig-param">can_be_none=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.util.Err.type" title="Permalink to this definition">¶</a></dt>
<dd><p>Raises a TypeError exception if the argument isn’t of the required type.  Returns ‘True’ which enables it to be
used as a logical condition.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pram.util.FS">
<em class="property">class </em><code class="sig-prename descclassname">pram.util.</code><code class="sig-name descname">FS</code><a class="headerlink" href="#pram.util.FS" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<dl class="method">
<dt id="pram.util.FS.bz2">
<em class="property">static </em><code class="sig-name descname">bz2</code><span class="sig-paren">(</span><em class="sig-param">fpath_src</em>, <em class="sig-param">fpath_dst=None</em>, <em class="sig-param">compress_lvl=9</em>, <em class="sig-param">do_del=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.util.FS.bz2" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.util.FS.bz2_decomp">
<em class="property">static </em><code class="sig-name descname">bz2_decomp</code><span class="sig-paren">(</span><em class="sig-param">fpath_src</em>, <em class="sig-param">fpath_dst=None</em>, <em class="sig-param">do_del=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.util.FS.bz2_decomp" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.util.FS.dir_mk">
<em class="property">static </em><code class="sig-name descname">dir_mk</code><span class="sig-paren">(</span><em class="sig-param">path</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.util.FS.dir_mk" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.util.FS.gz">
<em class="property">static </em><code class="sig-name descname">gz</code><span class="sig-paren">(</span><em class="sig-param">fpath_src</em>, <em class="sig-param">fpath_dst=None</em>, <em class="sig-param">compress_lvl=9</em>, <em class="sig-param">do_del=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.util.FS.gz" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.util.FS.gz_decomp">
<em class="property">static </em><code class="sig-name descname">gz_decomp</code><span class="sig-paren">(</span><em class="sig-param">fpath_src</em>, <em class="sig-param">fpath_dst=None</em>, <em class="sig-param">do_del=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.util.FS.gz_decomp" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.util.FS.load">
<em class="property">static </em><code class="sig-name descname">load</code><span class="sig-paren">(</span><em class="sig-param">fpath</em>, <em class="sig-param">mode='r'</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.util.FS.load" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.util.FS.load_bz2">
<em class="property">static </em><code class="sig-name descname">load_bz2</code><span class="sig-paren">(</span><em class="sig-param">fpath</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.util.FS.load_bz2" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.util.FS.load_gz">
<em class="property">static </em><code class="sig-name descname">load_gz</code><span class="sig-paren">(</span><em class="sig-param">fpath</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.util.FS.load_gz" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.util.FS.load_or_gen">
<em class="property">static </em><code class="sig-name descname">load_or_gen</code><span class="sig-paren">(</span><em class="sig-param">fpath</em>, <em class="sig-param">fn_gen</em>, <em class="sig-param">name='data'</em>, <em class="sig-param">is_verbose=False</em>, <em class="sig-param">hostname_gen={}</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.util.FS.load_or_gen" title="Permalink to this definition">¶</a></dt>
<dd><p>If the ‘fpath’ file exists, it is ungzipped and unpickled.  If it does not exist, ‘fn_gen()’ is called and the
result is pickled and gzipped in ‘fpath’ and returned.  Name can be redefined for customized progress messages.
No filesystem interactions are made if ‘fpath’ is None.</p>
<p>Generation of the data can be restricted to a set of machines designated by hostname.</p>
</dd></dl>

<dl class="method">
<dt id="pram.util.FS.req_file">
<em class="property">static </em><code class="sig-name descname">req_file</code><span class="sig-paren">(</span><em class="sig-param">fpath</em>, <em class="sig-param">msg</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.util.FS.req_file" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.util.FS.save">
<em class="property">static </em><code class="sig-name descname">save</code><span class="sig-paren">(</span><em class="sig-param">fpath</em>, <em class="sig-param">data</em>, <em class="sig-param">mode='w'</em>, <em class="sig-param">compress_lvl=9</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.util.FS.save" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.util.FS.save_bz2">
<em class="property">static </em><code class="sig-name descname">save_bz2</code><span class="sig-paren">(</span><em class="sig-param">fpath</em>, <em class="sig-param">data</em>, <em class="sig-param">compress_lvl=9</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.util.FS.save_bz2" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.util.FS.save_gz">
<em class="property">static </em><code class="sig-name descname">save_gz</code><span class="sig-paren">(</span><em class="sig-param">fpath</em>, <em class="sig-param">data</em>, <em class="sig-param">compress_lvl=9</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.util.FS.save_gz" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pram.util.Hash">
<em class="property">class </em><code class="sig-prename descclassname">pram.util.</code><code class="sig-name descname">Hash</code><a class="headerlink" href="#pram.util.Hash" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
</dd></dl>

<dl class="class">
<dt id="pram.util.MPCounter">
<em class="property">class </em><code class="sig-prename descclassname">pram.util.</code><code class="sig-name descname">MPCounter</code><span class="sig-paren">(</span><em class="sig-param">val_init=0</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.util.MPCounter" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Fixes issues with locking of multiprocessing’s Value object.</p>
<p>Source: eli.thegreenplace.net/2012/01/04/shared-counter-with-pythons-multiprocessing</p>
<dl class="method">
<dt id="pram.util.MPCounter.dec">
<code class="sig-name descname">dec</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pram.util.MPCounter.dec" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.util.MPCounter.inc">
<code class="sig-name descname">inc</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pram.util.MPCounter.inc" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.util.MPCounter.value">
<code class="sig-name descname">value</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pram.util.MPCounter.value" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pram.util.Size">
<em class="property">class </em><code class="sig-prename descclassname">pram.util.</code><code class="sig-name descname">Size</code><a class="headerlink" href="#pram.util.Size" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<dl class="method">
<dt id="pram.util.Size.b2h">
<em class="property">static </em><code class="sig-name descname">b2h</code><span class="sig-paren">(</span><em class="sig-param">b</em>, <em class="sig-param">do_ret_tuple=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.util.Size.b2h" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.util.Size.bytes2human">
<em class="property">static </em><code class="sig-name descname">bytes2human</code><span class="sig-paren">(</span><em class="sig-param">b</em>, <em class="sig-param">do_ret_tuple=False</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.util.Size.bytes2human" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.util.Size.get_size">
<em class="property">static </em><code class="sig-name descname">get_size</code><span class="sig-paren">(</span><em class="sig-param">obj0</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.util.Size.get_size" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference external" href="https://stackoverflow.com/questions/449560/how-do-i-determine-the-size-of-an-object-in-python/30316760#30316760">https://stackoverflow.com/questions/449560/how-do-i-determine-the-size-of-an-object-in-python/30316760#30316760</a></p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pram.util.Str">
<em class="property">class </em><code class="sig-prename descclassname">pram.util.</code><code class="sig-name descname">Str</code><a class="headerlink" href="#pram.util.Str" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<dl class="method">
<dt id="pram.util.Str.float">
<em class="property">static </em><code class="sig-name descname">float</code><span class="sig-paren">(</span><em class="sig-param">s</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.util.Str.float" title="Permalink to this definition">¶</a></dt>
<dd><p>Formats a string containing a floating point number to suppress scientific notation and strip trailing zeros.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="pram.util.Tee">
<em class="property">class </em><code class="sig-prename descclassname">pram.util.</code><code class="sig-name descname">Tee</code><span class="sig-paren">(</span><em class="sig-param">fname</em>, <em class="sig-param">fmode='a'</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.util.Tee" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Script output forker.</p>
<p>When instantiated, this class writes the output of the script to stdout and to a file at the same time (much like
the UNIX command line utility by the same name).</p>
<dl class="method">
<dt id="pram.util.Tee.end">
<code class="sig-name descname">end</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pram.util.Tee.end" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.util.Tee.flush">
<code class="sig-name descname">flush</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pram.util.Tee.flush" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.util.Tee.write">
<code class="sig-name descname">write</code><span class="sig-paren">(</span><em class="sig-param">data</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.util.Tee.write" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pram.util.Time">
<em class="property">class </em><code class="sig-prename descclassname">pram.util.</code><code class="sig-name descname">Time</code><a class="headerlink" href="#pram.util.Time" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>POSIX (or UNIX) time (i.e., Jan 1, 1970) is the point of reference for this class.</p>
<p>All timestamps and datetime differences default to milliseconds (as opposed to seconds, which is what the
‘datetime’ module seems to prefer).</p>
<dl class="attribute">
<dt id="pram.util.Time.DOTW_NUM2STR">
<code class="sig-name descname">DOTW_NUM2STR</code><em class="property"> = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat']</em><a class="headerlink" href="#pram.util.Time.DOTW_NUM2STR" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pram.util.Time.MS">
<code class="sig-name descname">MS</code><a class="headerlink" href="#pram.util.Time.MS" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pram.util.Time.PATT_STR_DUR">
<code class="sig-name descname">PATT_STR_DUR</code><em class="property"> = re.compile('^(\\d+)\\s*(\\w+)$')</em><a class="headerlink" href="#pram.util.Time.PATT_STR_DUR" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pram.util.Time.POSIX_DT">
<code class="sig-name descname">POSIX_DT</code><em class="property"> = datetime.datetime(1970, 1, 1, 0, 0)</em><a class="headerlink" href="#pram.util.Time.POSIX_DT" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pram.util.Time.POSIX_TS">
<code class="sig-name descname">POSIX_TS</code><em class="property"> = datetime.datetime(1970, 1, 1, 0, 0)</em><a class="headerlink" href="#pram.util.Time.POSIX_TS" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.util.Time.diff">
<em class="property">static </em><code class="sig-name descname">diff</code><span class="sig-paren">(</span><em class="sig-param">dt_0</em>, <em class="sig-param">dt_1</em>, <em class="sig-param">do_ms=True</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.util.Time.diff" title="Permalink to this definition">¶</a></dt>
<dd><p>Difference between two datetime objects (‘dt_0’ being the earlier one). There is no point in providing a ‘diff’
method for timestamps because being floats they can simply be subtracted.</p>
</dd></dl>

<dl class="method">
<dt id="pram.util.Time.diffs">
<em class="property">static </em><code class="sig-name descname">diffs</code><span class="sig-paren">(</span><em class="sig-param">dt_0</em>, <em class="sig-param">dt_1</em>, <em class="sig-param">do_ms=True</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.util.Time.diffs" title="Permalink to this definition">¶</a></dt>
<dd><p>Casts the return of ‘diff()’ to string. This method is useful because it guarantees a proper formatting of the
resulting float (i.e., no scientific notation and trailing zeros stripped) making it a good choice for the
purpose of display, log, etc.</p>
</dd></dl>

<dl class="method">
<dt id="pram.util.Time.dotw">
<em class="property">static </em><code class="sig-name descname">dotw</code><span class="sig-paren">(</span><em class="sig-param">dt</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.util.Time.dotw" title="Permalink to this definition">¶</a></dt>
<dd><p>String short name of day-of-the-week.</p>
</dd></dl>

<dl class="method">
<dt id="pram.util.Time.dt">
<em class="property">static </em><code class="sig-name descname">dt</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pram.util.Time.dt" title="Permalink to this definition">¶</a></dt>
<dd><p>Datetime now.</p>
</dd></dl>

<dl class="method">
<dt id="pram.util.Time.dt2ts">
<em class="property">static </em><code class="sig-name descname">dt2ts</code><span class="sig-paren">(</span><em class="sig-param">dt</em>, <em class="sig-param">do_ms=True</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.util.Time.dt2ts" title="Permalink to this definition">¶</a></dt>
<dd><p>Datetime to timestamp.</p>
</dd></dl>

<dl class="method">
<dt id="pram.util.Time.dur2ms">
<em class="property">static </em><code class="sig-name descname">dur2ms</code><span class="sig-paren">(</span><em class="sig-param">s</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.util.Time.dur2ms" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pram.util.Time.sec2time">
<em class="property">static </em><code class="sig-name descname">sec2time</code><span class="sig-paren">(</span><em class="sig-param">sec</em>, <em class="sig-param">n_msec=0</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.util.Time.sec2time" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert seconds to ‘D days, HH:MM:SS.FFF’</p>
<dl class="simple">
<dt>References</dt><dd><p>stackoverflow.com/questions/775049/python-time-seconds-to-hms
humanfriendly.readthedocs.io/en/latest/#humanfriendly.format_timespan</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="pram.util.Time.ts">
<em class="property">static </em><code class="sig-name descname">ts</code><span class="sig-paren">(</span><em class="sig-param">do_ms=True</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.util.Time.ts" title="Permalink to this definition">¶</a></dt>
<dd><p>Timestamp now.</p>
</dd></dl>

<dl class="method">
<dt id="pram.util.Time.ts2dt">
<em class="property">static </em><code class="sig-name descname">ts2dt</code><span class="sig-paren">(</span><em class="sig-param">dt</em>, <em class="sig-param">is_ts_ms=True</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.util.Time.ts2dt" title="Permalink to this definition">¶</a></dt>
<dd><p>Timestamp to datetime.</p>
</dd></dl>

<dl class="method">
<dt id="pram.util.Time.ts_sec">
<em class="property">static </em><code class="sig-name descname">ts_sec</code><span class="sig-paren">(</span><em class="sig-param">sec</em>, <em class="sig-param">do_ms=True</em><span class="sig-paren">)</span><a class="headerlink" href="#pram.util.Time.ts_sec" title="Permalink to this definition">¶</a></dt>
<dd><p>Timestamp at the specified number of seconds.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pram">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-pram" title="Permalink to this headline">¶</a></h2>
</div>
</div>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<p class="logo">
  <a href="index.html">
    <img class="logo" src="_static/logo.png" alt="Logo"/>
    
  </a>
</p>






<p>
<iframe src="https://ghbtns.com/github-btn.html?user=momacs&repo=pram&type=watch&count=true&size=large&v=2"
  allowtransparency="true" frameborder="0" scrolling="0" width="200px" height="35px"></iframe>
</p>





<h3>Navigation</h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="intro.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="details.html">Details</a></li>
<li class="toctree-l1"><a class="reference internal" href="examples.html">Example Simulations</a></li>
<li class="toctree-l1"><a class="reference internal" href="front-ends.html">Front-Ends</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">API Reference</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#subpackages">Subpackages</a></li>
<li class="toctree-l2"><a class="reference internal" href="#submodules">Submodules</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-pram.data">pram.data module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-pram.entity">pram.entity module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-pram.event">pram.event module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-pram.graph">pram.graph module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-pram.pop">pram.pop module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-pram.rule">pram.rule module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-pram.signal">pram.signal module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-pram.sim">pram.sim module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-pram.traj">pram.traj module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-pram.util">pram.util module</a></li>
<li class="toctree-l2"><a class="reference internal" href="#module-pram">Module contents</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="license.html">License</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
      <li>Previous: <a href="front-ends.html" title="previous chapter">Front-Ends</a></li>
      <li>Next: <a href="pram.log.html" title="next chapter">pram.log package</a></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2018-2019, momacs.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.2.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="_sources/pram.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>